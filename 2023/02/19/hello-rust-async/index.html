<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>《Hello Rust Async》</title><meta name="description" content="行万里路，读万卷书"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "https://hm.baidu.com/hm.js?" + '2c076421eb9f21a0a143f8ee9c4ab171';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><meta name="referrer" content="no-referrer"><link rel="icon" href="/null"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="摘录与 Asynchronous Programming in Rust
一、Getting Started1.1 Rust 的异步 vs 其他语言的尽管很多语言都支持异步编程，但实现细节上有很多不一样。Rust的异步实现和大部分语言的在以下方面有区别：

Rust中 Futures 是惰性的，并且只有被轮询才会进一步执行。丢弃（Dropping）一个future可以阻止它继续执行。
Rust中的异步是零成本的，这意味着你只需要为你所使用的东西付出代价。特别来说，你使用异步时可以不需要堆分配或动态分发，这对性能来说是好事！这也使得你能够在约束环境下使用异步，例如嵌入式系统。
Rust不提供内置运行时。相反，运行时由社区维护的库提供。
Rust里单线程的和多线程的运行时都可用，而他们会有不同的优劣。

Dem.."><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Ryo's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">《Hello Rust Async》</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Getting-Started"><span class="toc-text">一、Getting Started</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Rust-%E7%9A%84%E5%BC%82%E6%AD%A5-vs-%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%9A%84"><span class="toc-text">1.1 Rust 的异步 vs 其他语言的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-async-await%E5%88%9D%E6%AD%A5"><span class="toc-text">1.2 async&#x2F;.await初步</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%89%A7%E8%A1%8C-Future-%E4%B8%8E%E4%BB%BB%E5%8A%A1%EF%BC%88Task%EF%BC%89"><span class="toc-text">二、执行 Future 与任务（Task）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Future-trait"><span class="toc-text">2.1 Future trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E7%94%A8-Waker-%E5%94%A4%E9%86%92%E4%BB%BB%E5%8A%A1"><span class="toc-text">2.2. 用 Waker 唤醒任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%BA%94%E7%94%A8%EF%BC%9A%E6%9E%84%E5%BB%BA%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="toc-text">2.3 应用：构建执行器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81async-await"><span class="toc-text">三、async&#x2F;.await</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Pinning"><span class="toc-text">四、Pinning</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81Streams"><span class="toc-text">五、Streams</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%90%8C%E6%97%B6%E6%89%A7%E8%A1%8C%E5%A4%9A%E4%B8%AA-Future"><span class="toc-text">六、同时执行多个 Future</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%8E%8C%E6%8F%A1%E5%B9%B6%E5%96%9C%E7%88%B1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-text">七、掌握并喜爱的解决方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81Async-%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F"><span class="toc-text">八、Async 生态系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%B9%B6%E5%8F%91-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">九、并发 Web 服务器</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Book"><i class="tag post-item-tag">Book</i></a><a href="/tags/Rust"><i class="tag post-item-tag">Rust</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">《Hello Rust Async》</h1><time class="has-text-grey" datetime="2023-02-19T02:08:08.000Z">2023-02-19</time><article class="mt-2 post-content"><p>摘录与 <a target="_blank" rel="noopener" href="https://rust-lang.github.io/async-book">Asynchronous Programming in Rust</a></p>
<h1 id="一、Getting-Started"><a href="#一、Getting-Started" class="headerlink" title="一、Getting Started"></a>一、Getting Started</h1><h2 id="1-1-Rust-的异步-vs-其他语言的"><a href="#1-1-Rust-的异步-vs-其他语言的" class="headerlink" title="1.1 Rust 的异步 vs 其他语言的"></a>1.1 Rust 的异步 vs 其他语言的</h2><p>尽管很多语言都支持异步编程，但实现细节上有很多不一样。<code>Rust</code>的异步实现和大部分语言的在以下方面有区别：</p>
<ul>
<li><code>Rust</code>中 <strong>Futures 是惰性的</strong>，并且只有被轮询才会进一步执行。丢弃（<code>Dropping</code>）一个<code>future</code>可以阻止它继续执行。</li>
<li><code>Rust</code>中的<strong>异步是零成本的</strong>，这意味着你只需要为你所使用的东西付出代价。特别来说，你使用异步时可以不需要堆分配或动态分发，这对性能来说是好事！这也使得你能够在约束环境下使用异步，例如嵌入式系统。</li>
<li><code>Rust</code><strong>不提供内置运行时</strong>。相反，运行时由社区维护的库提供。</li>
<li><code>Rust</code>里<strong>单线程的和多线程的</strong>运行时都可用，而他们会有不同的优劣。</li>
</ul>
<p>Demo</p>
<pre><code>fn get_two_sites() {
    // 生成两个线程来下载网页.
    let thread_one = thread::spawn(|| download("https:://www.foo.com"));
    let thread_two = thread::spawn(|| download("https:://www.bar.com"));

    // 等待两个线程运行下载完成.
    thread_one.join().expect("thread one panicked");
    thread_two.join().expect("thread two panicked");
}
</code></pre>
<p>然而，下载网页是小任务，为了这么少量工作创建线程相当浪费。对更大的应用来说，这很容易就会变成瓶颈。在异步<code>Rust</code>，我们能够并发地运行这些任务而不需要额外的线程：</p>
<pre><code>async fn get_two_sites_async() {
    // 创建两个不同的 "futures", 当创建完成之后将异步下载网页.
    let future_one = download_async("https:://www.foo.com");
    let future_two = download_async("https:://www.bar.com");

    // 同时运行两个 "futures" 直到完成.
    join!(future_one, future_two);
}
</code></pre>
<h2 id="1-2-async-await初步"><a href="#1-2-async-await初步" class="headerlink" title="1.2 async/.await初步"></a>1.2 async/.await初步</h2><p><code>async/.await</code>是<code>Rust</code>内置语法，用于让异步函数编写得像同步代码。<code>async</code>将代码块转化成实现了<code>Future trait</code>的状态机。使用同步方法调用阻塞函数会阻塞整个线程，但阻塞<code>Future</code>只会让出（<code>yield</code>）线程控制权，让其他<code>Future</code>继续执行。</p>
<pre><code>[dependencies]
futures = "0.3"

use futures::executor::block_on;

// 你可以使用async fn语法创建异步函数：
async fn hello_world() {
    println!("hello, world!");
}

fn main() {
    let future = hello_world(); // Nothing is printed
    // 需要执行器来执行这个
    block_on(future); //`future`is run and "hello, world!" is printed
}
</code></pre>
<p><code>Async Demo</code></p>
<pre><code>async fn learn_and_sing() {
    let song = learn_song().await;
    sing_song(song).await;
}

async fn async_main() {
    let f1 = learn_and_sing();
    let f2 = dance();

    futures::join!(f1, f2);
}

fn main() {
    block_on(async_main());
}
</code></pre>
<h1 id="二、执行-Future-与任务（Task）"><a href="#二、执行-Future-与任务（Task）" class="headerlink" title="二、执行 Future 与任务（Task）"></a>二、执行 Future 与任务（Task）</h1><h2 id="2-1-Future-trait"><a href="#2-1-Future-trait" class="headerlink" title="2.1 Future trait"></a>2.1 Future trait</h2><ul>
<li><p><code>Future trait</code>是<code>Rust Async</code>编程的核心</p>
</li>
<li><p><code>Future</code>是一种异步计算，它可以产生一个值</p>
</li>
<li><p>实现了<code>Future</code>类型的表示目前可能还不可用的值</p>
</li>
<li><p>下面是一个简化版的<code>Future trait</code></p>
<pre><code>  trait SimpleFuture {
      type Output;
      fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt;;
  }
  
  enum Poll&lt;T&gt; {
      Ready(T),
      Pending,
  }
</code></pre>
</li>
<li><p><code>Future</code>代表着一种你可以检验其是否完成的操作</p>
</li>
<li><p><code>Future</code>可以通过调用<code>poll</code>函数来取得进展</p>
<ul>
<li><code>poll</code>函数会驱动<code>Future</code>尽可能接近完成</li>
<li>如果<code>Future</code>完成了，就返回<code>poll::Ready(result)</code>，其中<code>result</code>就是最终结果</li>
<li>如果<code>Future</code>还无法完成：就返回<code>poll::Pending</code>，并当<code>Future</code>准备好去的更多进展时调用一个<code>waker</code>的<code>wake()</code>函数</li>
</ul>
</li>
<li><p>针对<code>Future</code>，你唯一做的就是使用<code>poll</code>来敲打它，知道一个值掉出来。</p>
</li>
</ul>
<p><strong>wake() 函数</strong></p>
<ul>
<li>当<code>wake()</code>函数被调用时：<ul>
<li>执行器将驱动<code>Future</code>再次调用<code>poll</code>函数，以便<code>Future</code>能取得更多的进展</li>
</ul>
</li>
<li>没有<code>wake()</code>函数，执行器就不知道特定的<code>Future</code>何时能取得进展（就得不断地<code>poll</code>）</li>
<li>通过<code>wake()</code>函数，执行器就确切的知道哪些<code>Future</code>已经准备好进行<code>poll()</code>的调用   </li>
</ul>
<p>伪代码：</p>
<pre><code>pub struct SocketRead&lt;'a&gt; {
    socket: &amp;'a Socket,
}

impl SimpleFuture for SocketRead&lt;'_&gt; {
    type Output = Vec&lt;u8&gt;;

    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt; {
        if self.socket.has_data_to_read() {
            // The socket has data -- read it into a buffer and return it.
            Poll::Ready(self.socket.read_buf())
        } else {
            // The socket does not yet have data.
            //
            // Arrange for`wake`to be called once data is available.
            // When data becomes available,`wake`will be called, and the
            // user of this`Future`will know to call`poll`again and
            // receive data.
            self.socket.set_readable_callback(wake);
            Poll::Pending
        }
    }
}
</code></pre>
<p><strong>真正的Future代码</strong>    </p>
<pre><code>trait Future {
    type Output;
    fn poll(
        // Note the change from`&amp;mut self`to`Pin&lt;&amp;mut Self&gt;`:
        self: Pin&lt;&amp;mut Self&gt;,
        // and the change from`wake: fn()`to`cx: &amp;mut Context&lt;'_&gt;`:
        cx: &amp;mut Context&lt;'_&gt;,
    ) -&gt; Poll&lt;Self::Output&gt;;
}


/*
async fn read_from_file1() -&gt; String {
    sleep(Duration::new(4,0));
    println!("{:?}", "Processing file 1");
    String::from("Hello, there from file 1")
}
*/
// Future
// use std::thread::sleep;
// use std::time::Duration;
// 等同 async fn read_from_file1() -&gt; String 代码
use std::future::Future;
fn read_from_file1() -&gt; impl Future&lt;Output = String&gt; { 
    async {
        sleep(Duration::new(4,0));
        println!("{:?}", "Processing file 1");
        String::from("Hello, there from file 1")
    }
}
</code></pre>
<p><strong>Future Demo1</strong></p>
<pre><code>use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::thread::sleep;
use std::time::Duration;
struct ReadFileFuture {}
impl Future for ReadFileFuture {
    type Output = String;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        println!("Tokio! Stop polling me");
        cx.waker().wake_by_ref(); // first change
        // Poll::Pending // orig design
        Poll::Ready(String::from("Hello, there from file 1")) // 2nd change
        // why the Poll::Ready cannot print in stdout?
    }
}
#[tokio::main]
async fn main() {
    println!("Hello before reading file!");
    let h1 = tokio::spawn(async {
        let future1 = ReadFileFuture {};
        future1.await
    });
    let h2 = tokio::spawn(async {
        let file2_contents = read_from_file2().await;
        println!("{:?}", file2_contents);
    });
    let _ = tokio::join!(h1, h2);
}
fn read_from_file2() -&gt; impl Future&lt;Output = String&gt; {
    async {
        sleep(Duration::new(2,0));
        println!("{:?}", "Processing file 2");
        String::from("Hello, there from file 2")
    }
}
</code></pre>
<p><strong>Future Demo2</strong></p>
<pre><code>use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::thread::sleep;
use std::time::{Duration, Instant};

struct AsyncTimer { expiration_time: Instant, }

impl Future for AsyncTimer {
    type Output = String;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        if Instant::now() &gt;= self.expiration_time {
            println!("Hello, it's time for Future 1");
            Poll::Ready(String::from("Future 1 has completed"))
        } else {
            println!("Hello, it's not yet time for Future 1, Going to sleep");
            let waker = cx.waker().clone();
            let expiration_time = self.expiration_time;
            std::thread::spawn(move || {
                println!("start new thread with sleep blocking");
                let curr_time = Instant::now();
                if curr_time &lt; expiration_time {
                    std::thread::sleep(expiration_time - curr_time);
                }
                println!("end sleep and wake.wake()");
                waker.wake();
                println!("end wake.wake()");
            });
            println!("end new thread and return Poll::Pending");
            Poll::Pending
        }
    }
}
#[tokio::main]
async fn main() {
    println!("start tokio::main");
    let h1 = tokio::spawn(async {
        println!("start future1 handle");
        // let future1 = AsyncTimer{ expiration_time: Instant::now() + Duration::from_millis(4000), };
        let future1 = AsyncTimer{ expiration_time: Instant::now() + Duration::from_secs(4), };
        println!("generate future1 handle, then run future1.await");
        println!("{:?}", future1.await);
        println!("after future1.await");
    });

    let h2 = tokio::spawn(async {
        println!("start future2 handle");
        let file2_contents = read_from_file2().await;
        println!("{:?}", file2_contents);
        println!("end future2 handle");
    });

    let _ = tokio::join!(h1, h2);
}

fn read_from_file2() -&gt; impl Future&lt;Output = String&gt; {
    async {
        sleep(Duration::new(4,0));
        String::from("Future 2 has completed")
    }
}
</code></pre>
<h2 id="2-2-用-Waker-唤醒任务"><a href="#2-2-用-Waker-唤醒任务" class="headerlink" title="2.2. 用 Waker 唤醒任务"></a>2.2. 用 Waker 唤醒任务</h2><ul>
<li><code>Future</code>在第一次<code>poll</code>的时候通常无法完成任务，所以<code>Future</code>需要保证在准备好去的更多进展后，可以再次被<code>poll</code></li>
<li>每次<code>Future</code>被<code>poll</code>，它都是作为一个任务的一部分</li>
<li>任务（<code>Task</code>）就是被提交给执行者顶层的<code>Future</code></li>
</ul>
<h2 id="2-3-应用：构建执行器"><a href="#2-3-应用：构建执行器" class="headerlink" title="2.3 应用：构建执行器"></a>2.3 应用：构建执行器</h2><p><code>Rust</code>的<code>Future</code>是惰性的：它们不会干任何事，除非它们被驱动执行。一个驱动<code>future</code>类型的方法是在<code>async</code>函数中使用<code>.await</code>调用，但这只是将问题抛到上一层：谁来跑在顶层<code>async</code>函数返回的<code>future</code>实例呢？为此，我们需要执行<code>Future</code>的执行器。</p>
<p><code>Future</code>执行器会拿一组顶层<code>Future</code>去跑<code>poll</code>方法，无论这些<code>Future</code>能否进展。通常， 执行器会<code>poll</code>一个<code>future</code>实例来启动。当<code>Future</code>通过调用<code>wake()</code>方法来指示他们准备好继续进展，执行器就会把它们放入队列并再一次<code>poll</code>，重复这一过程直到<code>Future</code>完成。</p>
<p><code>src/main.rs</code></p>
<pre><code>#![allow(unused)]
use {
    futures::{
        future::{BoxFuture, FutureExt},
        task::{waker_ref, ArcWake},
    },
    std::{
        future::Future,
        sync::mpsc::{sync_channel, Receiver, SyncSender},
        sync::{Arc, Mutex},
        task::{Context, Poll},
        time::Duration,
    },
    // // 引入之前实现的定时器模块
    // async_tokio::TimerFuture,
};

/// 任务执行器，负责从通道中接收任务然后执行
struct Executor {
    ready_queue: Receiver&lt;Arc&lt;Task&gt;&gt;,
}

///`Spawner`负责创建新的`Future`然后将它发送到任务通道中
#[derive(Clone)]
struct Spawner {
    task_sender: SyncSender&lt;Arc&lt;Task&gt;&gt;,
}

/// 添加一个方法用于生成 Future , 然后将它放入任务通道中
impl Spawner {
    fn spawn(&amp;self, future: impl Future&lt;Output = ()&gt; + 'static + Send) {
        let future = future.boxed();
        let task = Arc::new(Task {
            future: Mutex::new(Some(future)),
            task_sender: self.task_sender.clone(),
        });
        self.task_sender.send(task).expect("任务队列已满");
    }
}

/// 一个Future，它可以调度自己(将自己放入任务通道中)，然后等待执行器去`poll`
struct Task {
    /// 进行中的Future，在未来的某个时间点会被完成
    ///
    /// 按理来说`Mutex`在这里是多余的，因为我们只有一个线程来执行任务。但是由于
    /// Rust并不聪明，它无法知道`Future`只会在一个线程内被修改，并不会被跨线程修改。因此
    /// 我们需要使用`Mutex`来满足这个笨笨的编译器对线程安全的执着。
    ///
    /// 如果是生产级的执行器实现，不会使用`Mutex`，因为会带来性能上的开销，取而代之的是使用`UnsafeCell`
    future: Mutex&lt;Option&lt;BoxFuture&lt;'static, ()&gt;&gt;&gt;,

    /// 可以将该任务自身放回到任务通道中，等待执行器的poll
    task_sender: SyncSender&lt;Arc&lt;Task&gt;&gt;,
}

fn new_executor_and_spawner() -&gt; (Executor, Spawner) {
    // 任务通道允许的最大缓冲数(任务队列的最大长度)
    // 当前的实现仅仅是为了简单，在实际的执行中，并不会这么使用
    const MAX_QUEUED_TASKS: usize = 10_000;
    let (task_sender, ready_queue) = sync_channel(MAX_QUEUED_TASKS);
    (Executor { ready_queue }, Spawner { task_sender })
}

impl ArcWake for Task {
    fn wake_by_ref(arc_self: &amp;Arc&lt;Self&gt;) {
        // 通过发送任务到任务管道的方式来实现`wake`，这样`wake`后，任务就能被执行器`poll`
        let cloned = arc_self.clone();
        arc_self
            .task_sender
            .send(cloned)
            .expect("任务队列已满");
    }
}

impl Executor {
    fn run(&amp;self) {
        while let Ok(task) = self.ready_queue.recv() {
            // 获取一个future，若它还没有完成(仍然是Some，不是None)，则对它进行一次poll并尝试完成它
            let mut future_slot = task.future.lock().unwrap();
            if let Some(mut future) = future_slot.take() {
                // 基于任务自身创建一个`LocalWaker`
                let waker = waker_ref(&amp;task);
                let context = &amp;mut Context::from_waker(&amp;*waker);
                //`BoxFuture&lt;T&gt;`是`Pin&lt;Box&lt;dyn Future&lt;Output = T&gt; + Send + 'static&gt;&gt;`的类型别名
                // 通过调用`as_mut`方法，可以将上面的类型转换成`Pin&lt;&amp;mut dyn Future + Send + 'static&gt;`
                if future.as_mut().poll(context).is_pending() {
                    // Future还没执行完，因此将它放回任务中，等待下次被poll
                    *future_slot = Some(future);
                }
            }
        }
    }
}


use timer_future::TimerFuture;

fn main() {
    let (executor, spawner) = new_executor_and_spawner();

    // 生成一个任务
    spawner.spawn(async {
        println!("howdy!");
        // 创建定时器Future，并等待它完成
        TimerFuture::new(Duration::new(2, 0)).await;
        println!("done!");
    });

    // drop掉任务，这样执行器就知道任务已经完成，不会再有新的任务进来
    drop(spawner);

    // 运行执行器直到任务队列为空
    // 任务运行后，会先打印`howdy!`, 暂停2秒，接着打印`done!`
    executor.run();
}
</code></pre>
<p><code>src/lib.rs</code></p>
<pre><code> #![allow(unused)]
use std::{
    future::Future,
    pin::Pin,
    sync::{Arc, Mutex},
    task::{Context, Poll, Waker},
    thread,
    time::Duration,
};

pub struct TimerFuture {
    shared_state: Arc&lt;Mutex&lt;SharedState&gt;&gt;,
}

/// 在`future`线程和`awiting`线程之间共享状态
struct SharedState {
    /// 是否已经达到休眠时间.
    completed: bool,

    ///`TimerFuture`表示正在运行的`waker`.
    /// 线程可以在设置完`completed = true`之后来通知`TimerFuture`任务被唤醒并
    /// 检查`completed = true`，然后继续执行.
    waker: Option&lt;Waker&gt;,
}

impl Future for TimerFuture {
    type Output = ();
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        // 检查共享状态，检查定时器是否已经完成.
        let mut shared_state = self.shared_state.lock().unwrap();
        if shared_state.completed {
            Poll::Ready(())
        } else {
            // 设置`waker`， 让线程可以在定时器完成时唤醒当前`waker`，确保
            // 再次轮询`future`并获知`completed = true`.
            //
            // 这样做是非常不错的，而不用每次都重复`clone``waker`. 然而, 这个`TimerFuture`
            // 可以在执行器之间移动, 这可能会导致旧的`waker`指向错误的`waker`, 这会阻止
            //`TimerFuture`被正确得唤醒.
            //
            // 注意：可以使用`Waker::will_wake`函数来做检查, 但是
            // 为了简单起见，我们忽略了他.
            shared_state.waker = Some(cx.waker().clone());
            Poll::Pending
        }
    }
}

impl TimerFuture {
    /// 创建一个新的`TimerFuture`，它将在提供的超时之后完成.
    pub fn new(duration: Duration) -&gt; Self {
        let shared_state = Arc::new(Mutex::new(SharedState {
            completed: false,
            waker: None,
        }));

        // 创建一个新的线程.
        let thread_shared_state = shared_state.clone();
        thread::spawn(move || {
            thread::sleep(duration);
            let mut shared_state = thread_shared_state.lock().unwrap();
            // 设置状态，表示定时器已经完成，并唤醒轮询`future`中的最后一个
            // 任务 (如果存在的话).
            shared_state.completed = true;
            if let Some(waker) = shared_state.waker.take() {
                waker.wake()
            }
        });

        TimerFuture { shared_state }
    }
}
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-0569bb5523d22710.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Step 1"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-3eec6211249fa113.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Step 2"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-7bc874cc73c28d3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Step 3"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-bb7af21f083bb2e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Step 4"></p>
<h1 id="三、async-await"><a href="#三、async-await" class="headerlink" title="三、async/.await"></a>三、async/.await</h1><p><code>async/.await</code>是<code>Rust</code>的特殊语法，在发生阻塞的时，它让放弃当前线程控制权成为可能，这就允许在等待操作完成的时候，允许其他代码取得进展。</p>
<p>使用<code>async</code>的两种方式</p>
<pre><code>// This function:
async fn foo(x: &amp;u8) -&gt; u8 { *x }

// Is equivalent to this function:
fn foo_expanded&lt;'a&gt;(x: &amp;'a u8) -&gt; impl Future&lt;Output = u8&gt; + 'a {
    async move { *x }
}
</code></pre>
<p>Demo</p>
<pre><code>[dependencies]
async-std = { version = "1.9.0", features = ["unstable"] }

use async_std::io::prelude::*;
use async_std::net;
use async_std::task;

// async 申明函数
// Rust 编译器会自动把 std::io::Result&lt;String&gt; 包装成一个 Feature&lt;OutPut=T&gt; 返回
async fn cheapo_request(host: &amp;str, port: u16, path: &amp;str) -&gt; std::io::Result&lt;String&gt; {
    // .await 会等待，直到 future 变成 ready
    // await 最终会解析出 future 的值
    let mut socket = net::TcpStream::connect((host, port)).await?;
    let request = format!("GET {} HTTP/1.1\r\nHost: {}\r\n\n", path, host);

    socket.write_all(request.as_bytes()).await?;
    socket.shutdown(net::Shutdown::Write)?;

    let mut response = String::new();
    socket.read_to_string(&amp;mut response).await?;

    Ok(response)
}


fn main() -&gt; std::io::Result&lt;()&gt; {
    let response = task::block_on(cheapo_request("baidu.com", 80, "/"))?;
    println!("{}", response);
    Ok(())
}
</code></pre>
<p>第一次对<code>cheapo_request</code>进行<code>poll</code>时：</p>
<ul>
<li>从函数体顶部开始执行</li>
<li>直到第一个<code>await</code>(针对<code>TcpStream::connect</code>返回的<code>Future</code>)</li>
<li>如果<code>TcpStream::connect</code>还没完成，就会返回<code>Pending</code></li>
<li>针对<code>cheapo_request</code>的<code>poll</code>也无法继续，直到<code>connect</code>的<code>Future</code>返回<code>ready</code></li>
</ul>
<p><code>await</code>:</p>
<ul>
<li>获得<code>Future</code>的所有权，并对其进行<code>poll</code></li>
<li>如果<code>Future Ready</code>，其最终值就是<code>await</code>表达式的值，这时执行就可以继续了</li>
<li>否则就返回<code>Pending</code>给调用者</li>
</ul>
<p>第二次对<code>cheapo_request</code>的<code>Future</code>进行<code>poll</code>时</p>
<ul>
<li>并不在函数体顶部开始执行</li>
<li>它会在<code>connect Future</code>进行<code>poll</code>的地方继续执行，直到它变成<code>Ready</code>，才会继续在函数体往下下走</li>
</ul>
<p>随着<code>cheapo_request</code>的<code>Future</code>不断被<code>poll</code>，其执行就是从一个<code>await</code>到下一个<code>await</code>，而且只有子<code>Future</code>的<code>await</code>变成<code>Ready</code>之后才继续.</p>
<p><code>cheapo_request</code>的<code>Future</code>会追踪：</p>
<ul>
<li>下一次<code>poll</code>应恢复继续的那个点</li>
<li>以及所需的本地状态（变量、参数、临时变量等）</li>
</ul>
<p>这种途中能暂停执行，然后恢复执行的能力是<code>async</code>所独有的由于<code>await</code>表达式依赖于“可恢复执行”这个特性，所以<code>await</code>只能用在<code>async</code>里。</p>
<p><strong>async 的生命周期</strong></p>
<ul>
<li>与传统函数不同：<code>async fn</code>，如果它的参数是引用或是其他非<code>'static</code>的，那么它返回的<code>Future</code>就会绑定到参数的生命周期上。</li>
<li>这意味着<code>async fn</code>返回的<code>future</code>，在<code>.await</code>的同时，<code>fn</code>的非<code>'static</code>的参数必须保持有效</li>
</ul>
<p>Demo</p>
<pre><code>// This function:
async fn foo(x: &amp;u8) -&gt; u8 { *x }

// Is equivalent to this function:
fn foo_expanded&lt;'a&gt;(x: &amp;'a u8) -&gt; impl Future&lt;Output = u8&gt; + 'a {
    async move { *x }
}
</code></pre>
<p>存储<code>future</code>或传递<code>future</code></p>
<ul>
<li>通常，<code>async</code>的函数在调用后会立即<code>.await</code>，这就不是问题：<ul>
<li>例如：<code>foo(&amp;x).await</code></li>
</ul>
</li>
<li>如果存储<code>future</code>或将其传递给其他任务或者线程，就有问题了。。</li>
<li>一种变通方法：<ul>
<li>思路：把使用引用作为参数的<code>async fn</code>转为一个<code>'static future</code></li>
<li>做法：在<code>async</code>块里，将参数和<code>async fn</code>的调用捆绑到一起（延长参数的生命周期来匹配<code>future</code>）</li>
</ul>
</li>
<li><code>async</code>库和闭包都支持<code>move</code></li>
<li><code>async move</code>块会获得其引用变量的所有权：<ul>
<li>允许其比当前所在的作用域活得长</li>
<li>但同时也放弃了与其它代码共享的这些变量的能力</li>
</ul>
</li>
</ul>
<p>Demo</p>
<pre><code>fn bad() -&gt; impl Future&lt;Output = u8&gt; {
    let x = 5;
    borrow_x(&amp;x) // ERROR:`x`does not live long enough
}

fn good() -&gt; impl Future&lt;Output = u8&gt; {
    async {
        let x = 5;
        borrow_x(&amp;x).await
    }
}
</code></pre>
<p><strong>在多线程执行者上进行.await</strong></p>
<ul>
<li>当使用多线程<code>future</code>执行者时，<code>future</code>就可以在线程间移：<ul>
<li>所以<code>async</code>体里面用的变量必须能够在线程间移动</li>
<li>因为任何的<code>.await</code>都可能导致切换到一个新的线程 </li>
</ul>
</li>
<li>这意味着使用以下类型是不安全的：<ul>
<li><code>Rc</code>，<code>&amp;RefCell</code>和任何其它没有实现<code>Send trait</code>的类型，包括没实现<code>Sync trait</code>的引用</li>
<li> 注意：调用<code>.await</code>时，只要这些类型不在作用域内，就可以使用他们。</li>
</ul>
</li>
<li>在跨域一个<code>.await</code>期间，持有传统的、对<code>future</code>无感知的锁，也不是好主意：<ul>
<li>可导致线程池锁定</li>
<li>为此，可使用<code>futures::lock</code>里的<code>Mutex</code>而不是<code>std:sync</code>里的     </li>
</ul>
</li>
</ul>
<h1 id="四、Pinning"><a href="#四、Pinning" class="headerlink" title="四、Pinning"></a>四、Pinning</h1><pre><code>#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
}

impl Test {
    fn new(txt: &amp;str) -&gt; Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
        }
    }

    fn init(&amp;mut self) {
        let self_ref: *const String = &amp;self.a;
        self.b = self_ref;
    }

    fn a(&amp;self) -&gt; &amp;str {
        &amp;self.a
    }

    fn b(&amp;self) -&gt; &amp;String {
        assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
        unsafe { &amp;*(self.b) }
    }
}



fn main() {
    let mut test1 = Test::new("test1");
    test1.init();
    let mut test2 = Test::new("test2");
    test2.init();
    std::mem::swap(&amp;mut test1, &amp;mut test2);

    println!("a: {}, b: {}", test1.a(), test1.b());
    println!("a: {}, b: {}", test2.a(), test2.b());

}
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-cd9fb4200c7345b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>Pin的实践</strong></p>
<ul>
<li><code>Pin</code>类型会包裹指针类型，保证指针指向的值不被移动</li>
<li>例如：<code>Pin&lt;&amp;mut T&gt;</code>,<code>Pin&lt;&amp;T&gt;</code>,<code>Pin&lt;Box&lt;T&gt;&gt;</code><ul>
<li>即使<code>T:!Unpin</code>,也能保证<code>T</code>不被移动 </li>
</ul>
</li>
</ul>
<p><strong>Unpin trait</strong></p>
<ul>
<li>大多数类型如果被移动，不会造成问题，它们实现了<code>Unpin</code></li>
<li>指向<code>Unpin</code>类型的指针，可自由的放入或从<code>Pin</code>中取出<ul>
<li>例如：<code>u8</code>是<code>Unpin</code>的，<code>Pin&lt;&amp;mut u8&gt;</code>和普通的<code>&amp;mut u8</code>一样。</li>
</ul>
</li>
<li>如果类型拥有<code>!Unpin</code>标记，那么在<code>Pin</code>之后它们就无法移动了。 </li>
</ul>
<p><strong>Pin到栈内存的Demo</strong></p>
<pre><code>use std::marker::PhantomPinned;
use std::pin::Pin;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}

impl Test {
    fn new(txt: &amp;str) -&gt; Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned,
        }
    }

    fn init(self: Pin&lt;&amp;mut Self&gt;) {
        let self_ptr: *const String = &amp;self.a;
        let this = unsafe { self.get_unchecked_mut() };
        this.b = self_ptr;
    }

    fn a(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;str {
        &amp;self.get_ref().a
    }

    fn b(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;String {
        unsafe { &amp;*self.b }
    }
}

fn main() {
    println!("Hello, world!");

    let mut test1 = Test::new("test1");
    let mut test1 = unsafe { Pin::new_unchecked(&amp;mut test1) };
    Test::init(test1.as_mut());

    let mut test2 = Test::new("test2");
    let mut test2 = unsafe { Pin::new_unchecked(&amp;mut test2) };
    Test::init(test2.as_mut());
    std::mem::swap(&amp;mut test1, &amp;mut test2);

    println!(
        "test1: {}, {}",
        Test::a(test1.as_ref()),
        Test::b(test1.as_ref())
    );
    println!(
        "test2: {}, {}",
        Test::a(test2.as_ref()),
        Test::b(test2.as_ref())
    );
    // std::mem::swap(test1.get_mut(), test2.get_mut());
}
</code></pre>
<p><strong>Pin到堆内存的Demo</strong></p>
<pre><code>#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
}

impl Test {
    fn new(txt: &amp;str) -&gt; Box&lt;Self&gt; {
        Box::new(Test {
            a: String::from(txt),
            b: std::ptr::null(),
        })
    }

    fn init(self: &amp;mut Self) {
        let self_ptr: *const String = &amp;self.a;
        self.b = self_ptr;
    }

    fn a(self: &amp;Self) -&gt; &amp;str {
        &amp;self.a
    }

    fn b(self: &amp;Self) -&gt; &amp;String {
        unsafe { &amp;*self.b }
    }
}

fn main() {
    println!("Hello, world!");

    let mut test1 = Test::new("test1");
    Test::init(test1.as_mut());

    let mut test2 = Test::new("test2");
    Test::init(test2.as_mut());

    println!("test1: {}, {}", test1.a(), test1.b());
    println!("test2: {}, {}", test2.a(), test2.b());

    std::mem::swap(&amp;mut test1, &amp;mut test2);
    println!("test1: {}, {}", test1.a(), test1.b());
    println!("test2: {}, {}", test2.a(), test2.b());
}
</code></pre>
<p>Demo 2    </p>
<pre><code>use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}

impl Test {
    fn new(txt: &amp;str) -&gt; Pin&lt;Box&lt;Self&gt;&gt; {
        let t = Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned,
        };
        let mut boxed = Box::pin(t);
        let self_ptr: *const String = &amp;boxed.a;
        unsafe { boxed.as_mut().get_unchecked_mut().b = self_ptr };

        boxed
    }

    fn a(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;str {
        &amp;self.get_ref().a
    }

    fn b(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;String {
        unsafe { &amp;*(self.b) }
    }
}

pub fn main() {
    let test1 = Test::new("test1");
    let test2 = Test::new("test2");

    println!("a: {}, b: {}",test1.as_ref().a(), test1.as_ref().b());
    println!("a: {}, b: {}",test2.as_ref().a(), test2.as_ref().b());
}
</code></pre>
<p><strong>总结</strong></p>
<ol>
<li><p>如果<code>T: Unpin</code>（默认会实现），那么<code>Pin&lt;'a, T&gt;</code>完全等价于<code>&amp;'a mut T</code>。换言之：<code>Unpin</code>意味着这个类型被移走也没关系，就算已经被固定了，所以<code>Pin</code>对这样的类型毫无影响。</p>
</li>
<li><p>如果<code>T: !Unpin</code>， 获取已经被固定的 T 类型示例的<code>&amp;mut T</code>需要 unsafe。</p>
</li>
<li><p>标准库中的大部分类型实现<code>Unpin</code>，在<code>Rust</code>中遇到的多数“平常”的类型也是一样。但是，<code>async/await</code>生成的<code>Future</code>是个例外。</p>
</li>
<li><p>你可以在<code>nightly</code>通过特性标记来给类型添加<code>!Unpin</code>约束，或者在<code>stable</code>给你的类型加<code>std::marker::PhatomPinned</code>字段。</p>
</li>
<li><p>你可以将数据固定到栈上或堆上</p>
</li>
<li><p>固定<code>!Unpin</code>对象到栈上需要<code>unsafe</code></p>
</li>
<li><p>固定<code>!Unpin</code>对象到堆上不需要<code>unsafe</code>。<code>Box::pin</code>可以快速完成这种固定。</p>
</li>
<li><p>针对已经<code>Pin</code>的数据，如果它是<code>T:!Unpin</code>的，则需要保证它从被<code>Pin</code>后，内存一直有效且不会调整其用途，直到<code>dorp</code>被调用，这是 <em>Pin 协约</em> 中的重要部分。</p>
</li>
</ol>
<h1 id="五、Streams"><a href="#五、Streams" class="headerlink" title="五、Streams"></a>五、Streams</h1><p><code>Stream trait</code>与<code>Future</code>类似，但能在完成前返还（<code>yield</code>）多个值，与标准库中的<code>Iterator</code>类似：</p>
<pre><code>trait Stream {
    /// 由`stream`产生的值的类型.
    type Item;

    /// 尝试解析`stream`中的下一项.
    /// 如果已经准备好，就重新运行`Poll::Pending`, 如果已经完成，就重新
    /// 运行`Poll::Ready(Some(x))`，如果已经完成，就重新运行`Poll::Ready(None)`.
    fn poll_next(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;)
        -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
}
</code></pre>
<p>一个常见的使用<code>Stream</code>的例子是<code>futures</code>库中通道的<code>Receiver</code>。每次<code>Sender</code>端发送一个值时，它就会返回一个<code>Some(val)</code>，并且会在<code>Sender</code>关闭且所有消息都接收后返还<code>None</code>:</p>
<pre><code>async fn send_recv() {
    const BUFFER_SIZE: usize = 10;
    let (mut tx, mut rx) = mpsc::channel::&lt;i32&gt;(BUFFER_SIZE);

    tx.send(1).await.unwrap();
    tx.send(2).await.unwrap();
    drop(tx);

    //`StreamExt::next`类似于`Iterator::next`, 但会返回一个实现
    // 了`Future&lt;Output = Option&lt;T&gt;&gt;`的类型.
    assert_eq!(Some(1), rx.next().await);
    assert_eq!(Some(2), rx.next().await);
    assert_eq!(None, rx.next().await);
}

async fn sum_with_next(mut stream: Pin&lt;&amp;mut dyn Stream&lt;Item = i32&gt;&gt;) -&gt; i32 {
    use futures::stream::StreamExt; // 对于`next`
    let mut sum = 0;
    while let Some(item) = stream.next().await {
        sum += item;
    }
    sum
}

async fn sum_with_try_next(
    mut stream: Pin&lt;&amp;mut dyn Stream&lt;Item = Result&lt;i32, io::Error&gt;&gt;&gt;,
) -&gt; Result&lt;i32, io::Error&gt; {
    use futures::stream::TryStreamExt; // 对于`try_next`
    let mut sum = 0;
    while let Some(item) = stream.try_next().await? {
        sum += item;
    }
    Ok(sum)
}


async fn jump_around(
    mut stream: Pin&lt;&amp;mut dyn Stream&lt;Item = Result&lt;u8, io::Error&gt;&gt;&gt;,
) -&gt; Result&lt;(), io::Error&gt; {
    use futures::stream::TryStreamExt; // 对于`try_for_each_concurrent`
    const MAX_CONCURRENT_JUMPERS: usize = 100;

    stream.try_for_each_concurrent(MAX_CONCURRENT_JUMPERS, |num| async move {
        jump_n_times(num).await?;
        report_n_jumps(num).await?;
        Ok(())
    }).await?;

    Ok(())
}
</code></pre>
<h1 id="六、同时执行多个-Future"><a href="#六、同时执行多个-Future" class="headerlink" title="六、同时执行多个 Future"></a>六、同时执行多个 Future</h1><p>可以同时执行多个异步操作的方式：</p>
<ul>
<li><code>join!</code>，等待所有的<code>future</code>完成    </li>
<li><code>select!</code>，等待所有的<code>future</code>中的一个完成    </li>
<li><code>Spawning</code>，创建一个顶级任务，他会运行一个<code>future</code>直至完成</li>
<li><code>FuturesUnoredered</code>，一组<code>Future</code>，他们会产生每个子<code>Future</code>的结果</li>
</ul>
<p><strong>join!</strong></p>
<pre><code>use futures::join;

async fn get_book_and_music() -&gt; (Book, Music) {
    let book_fut = get_book();
    let music_fut = get_music();
    join!(book_fut, music_fut)
}
</code></pre>
<p><strong>try_join!</strong></p>
<p>对于那些返回<code>Result</code>的<code>future</code>，考虑使用<code>try_join!</code>而非<code>join</code>。因为<code>join</code>只会在所有子<code>future</code>都完成后才会完成，它甚至会在子<code>future</code>返回<code>Err</code>之后继续处理。</p>
<pre><code>use futures::try_join;

async fn get_book() -&gt; Result&lt;Book, String&gt; { /* ... */ Ok(Book) }
async fn get_music() -&gt; Result&lt;Music, String&gt; { /* ... */ Ok(Music) }

async fn get_book_and_music() -&gt; Result&lt;(Book, Music), String&gt; {
    let book_fut = get_book();
    let music_fut = get_music();
    try_join!(book_fut, music_fut)
}

use futures::{
    future::TryFutureExt,
    try_join,
};

// 注意，传进 try_join! 的 future 必须要用相同的错误类型。考虑使用 futures::future::TryFutureExt 库的 .map_err(|e| ...) 或 err_into() 函数来统一错误类型：
async fn get_book() -&gt; Result&lt;Book, ()&gt; { /* ... */ Ok(Book) }
async fn get_music() -&gt; Result&lt;Music, String&gt; { /* ... */ Ok(Music) }

async fn get_book_and_music() -&gt; Result&lt;(Book, Music), String&gt; {
    let book_fut = get_book().map_err(|()| "Unable to get book".to_string());
    let music_fut = get_music();
    try_join!(book_fut, music_fut)
}
</code></pre>
<p><strong>select!</strong></p>
<pre><code>use futures::{
    future::FutureExt, // 为了`.fuse()`
    pin_mut,
    select,
};

async fn task_one() { /* ... */ }
async fn task_two() { /* ... */ }

async fn race_tasks() {
    let t1 = task_one().fuse();
    let t2 = task_two().fuse();

    pin_mut!(t1, t2);

    select! {
        () = t1 =&gt; println!("task one completed first"),
        () = t2 =&gt; println!("task two completed first"),
    }
}

// select 也支持 default 和 complete 分支。
// default : 如果选择的 future 尚未完成，就会允许 default 分之, 拥有 default 的 select 总是会立即返回
// complete：它用于所有选择的 future 都已经完成的情况
use futures::{future, select};

async fn count() {
    let mut a_fut = future::ready(4);
    let mut b_fut = future::ready(6);
    let mut total = 0;

    loop {
        select! {
            a = a_fut =&gt; total += a,
            b = b_fut =&gt; total += b,
            complete =&gt; break,
            default =&gt; unreachable!(), // 永远不会被执行(futures都准备好了,然后complete分支被执行)
        };
    }
    assert_eq!(total, 10);
}
</code></pre>
<p><strong>与 Unpin 和 FusedFuture 交互</strong></p>
<ul>
<li>前面的例子中，需要在返回的<code>future</code>上调用<code>.fuse()</code>，也调用了<code>pin_mut</code>。<ul>
<li>因为<code>select</code>里面的<code>future</code>必须实现<code>Unpin</code>和<code>FusedFuture</code>这两个<code>trait</code>。</li>
</ul>
</li>
<li>必须<code>Unpin:select</code>使用的<code>future</code>不是按值的，而是按可变引用。<ul>
<li>未完成的<code>future</code>在调用<code>select</code>后仍可使用</li>
</ul>
</li>
<li>必须<code>FusedFuture:</code>在<code>future</code>完成后，<code>select</code>不可以对它进行<code>poll</code><ul>
<li>实现<code>FusedFuture</code>的<code>future</code>会追踪其完成状态，这样在<code>select</code>循环里，就只会<code>poll</code>没有完成的<code>future</code></li>
</ul>
</li>
</ul>
<p>Demo1</p>
<pre><code>use futures::{
    stream::{Stream, StreamExt, FusedStream},
    select,
};

async fn add_two_streams(
    mut s1: impl Stream&lt;Item = u8&gt; + FusedStream + Unpin,
    mut s2: impl Stream&lt;Item = u8&gt; + FusedStream + Unpin,
) -&gt; u8 {
    let mut total = 0;

    loop {
        let item = select! {
            x = s1.next() =&gt; x,
            x = s2.next() =&gt; x,
            complete =&gt; break,
        };
        if let Some(next_num) = item {
            total += next_num;
        }
    }

    total
}
</code></pre>
<p><strong>带有 Fuse 和 FuturesUnordered 的 select 循环中的并发任务</strong></p>
<p>有个不太好找但是很趁手的函数叫<code>Fuse::terminated()</code>。这个函数允许构造已经被终止的空<code>future</code>，并且能够在之后填进需要运行的<code>future</code>。</p>
<pre><code>use futures::{
    future::{Fuse, FusedFuture, FutureExt},
    stream::{FusedStream, Stream, StreamExt},
    pin_mut,
    select,
};

async fn get_new_num() -&gt; u8 { /* ... */ 5 }

async fn run_on_new_num(_: u8) { /* ... */ }

async fn run_loop(
    mut interval_timer: impl Stream&lt;Item = ()&gt; + FusedStream + Unpin,
    starting_num: u8,
) {
    let run_on_new_num_fut = run_on_new_num(starting_num).fuse();
    let get_new_num_fut = Fuse::terminated();
    pin_mut!(run_on_new_num_fut, get_new_num_fut);
    loop {
        select! {
            () = interval_timer.select_next_some() =&gt; {
                // 计时器已经完成了.
                // 如果没有`get_new_num_fut`正在执行的话,就启动一个新的.
                if get_new_num_fut.is_terminated() {
                    get_new_num_fut.set(get_new_num().fuse());
                }
            },
            new_num = get_new_num_fut =&gt; {
                // 一个新的数字到达了
                // 启动一个新的`run_on_new_num_fut`并且扔掉旧的.
                run_on_new_num_fut.set(run_on_new_num(new_num).fuse());
            },
            // 执行`run_on_new_num_fut`
            () = run_on_new_num_fut =&gt; {},
            // 当所有都完成时panic,
            // 因为理论上`interval_timer`会不断地产生值.
            complete =&gt; panic!("`interval_timer`completed unexpectedly"),
        }
    }
}
</code></pre>
<p>当有很多份相同<code>future</code>的拷贝同时执行时，使用<code>FutureUnordered</code>类型。下面的例子和上面的例子很类似，但会运行<code>run_on_new_num_fut</code>的所有拷贝都到完成状态，而不是当一个新拷贝创建时就中断他们。它也会打印<code>run_on_new_num_fut</code>的返回值：</p>
<pre><code>use futures::{
    future::{Fuse, FusedFuture, FutureExt},
    stream::{FusedStream, FuturesUnordered, Stream, StreamExt},
    pin_mut,
    select,
};

async fn get_new_num() -&gt; u8 { /* ... */ 5 }

async fn run_on_new_num(_: u8) -&gt; u8 { /* ... */ 5 }

// 用从`get_new_num`获取的最新的数字运行`run_on_new_num`.
//
// 每当定时器到期后,都会重新执行`get_new_num`,
// 并立即取消正在执行的`run_on_new_num`,随后用新返回值替换`run_on_new_num`.
async fn run_loop(
    mut interval_timer: impl Stream&lt;Item = ()&gt; + FusedStream + Unpin,
    starting_num: u8,
) {
    let mut run_on_new_num_futs = FuturesUnordered::new();
    run_on_new_num_futs.push(run_on_new_num(starting_num));
    let get_new_num_fut = Fuse::terminated();
    pin_mut!(get_new_num_fut);
    loop {
        select! {
            () = interval_timer.select_next_some() =&gt; {
                // 计时器已经完成了.
                // 如果没有`get_new_num_fut`正在执行的话,就启动一个新的.
                if get_new_num_fut.is_terminated() {
                    get_new_num_fut.set(get_new_num().fuse());
                }
            },
            new_num = get_new_num_fut =&gt; {
                // 一个新的数字到达了,启动一个新的`run_on_new_num_fut`.
                run_on_new_num_futs.push(run_on_new_num(new_num));
            },
            // 执行`run_on_new_num_futs`并检查有没有完成的.
            res = run_on_new_num_futs.select_next_some() =&gt; {
                println!("run_on_new_num_fut returned {:?}", res);
            },
            // 当所有都完成时panic,
            // 因为理论上`interval_timer`会不断地产生值.
            complete =&gt; panic!("`interval_timer`completed unexpectedly"),
        }
    }
}
</code></pre>
<h1 id="七、掌握并喜爱的解决方法"><a href="#七、掌握并喜爱的解决方法" class="headerlink" title="七、掌握并喜爱的解决方法"></a>七、掌握并喜爱的解决方法</h1><pre><code>// ? in async Blocks

fn main() -&gt; std::io::Result&lt;()&gt; {
    struct MyError;
    async fn foo() -&gt; Result&lt;(), MyError&gt; {
        Ok(())
    }
    async fn bar() -&gt; Result&lt;(), MyError&gt; {
        Ok(())
    }

    let fut = async {
        foo().await?;
        bar().await?;
        Ok(()) // 报错，cannot infer type of the type parameter`E`declared on the enum`Result`
        // Ok::&lt;(), MyError&gt;(()) // &lt;- note the explicit type annotation here
    };


    Ok(())
}

// Send 模拟

#[derive(Default)]
struct NotSend(Rc&lt;()&gt;);

async fn bar() {}
async fn foo() {
    // let x = NotSend::default(); // 报错，has type`NotSend`which is not`Send`
    {
        let x = NotSend::default();
    }
    bar().await;
}

fn require_send(_: impl Send) {}

fn main() {
    require_send(foo());
}
    
// 递归
async fn recursive() {
    recursive().await; // 报错 recursion in an`async fn`requires boxing
    recursive().await;
}

// 解决方法
use futures::future::{BoxFuture, FutureExt};

fn recursive() -&gt; BoxFuture&lt;'static, ()&gt; {
    async move {
        recursive().await;
        recursive().await;
    }.boxed()
}
</code></pre>
<p><strong>trait 中的 async</strong></p>
<p>目前，<code>async fn</code>不能在<code>trait</code>中使用。原因一些复杂，但是有计划在未来移除这个限制。</p>
<p>这个问题可以用 <a target="_blank" rel="noopener" href="https://github.com/dtolnay/async-trait">async-trait</a> 库来避免</p>
<h1 id="八、Async-生态系统"><a href="#八、Async-生态系统" class="headerlink" title="八、Async 生态系统"></a>八、Async 生态系统</h1><p><strong>Rust 没提供什么</strong></p>
<ul>
<li><code>Rust</code>目前只提供编写<code>async</code>代码的基本要素，标准库中尚未提供执行器、任务、反应器、组合器以及低级<code>I/O future</code>和<code>trait</code></li>
<li>社区提供的<code>async</code>生态系统填补了这些空白</li>
</ul>
<p><strong>Async 运行时</strong></p>
<ul>
<li><code>Async</code>运行时是用于执行<code>async</code>应用程序的库</li>
<li>运行时通常将一个反应器与一个或多个执行器捆绑在一起</li>
<li>反应器为异步<code>I/O</code>、进程间通信和计时器等外部事件提供订阅机制</li>
<li>在<code>async</code>运行时中，订阅者通常是代表低级别<code>I/O</code>操作的<code>future</code>。</li>
<li>执行者负责安排和执行任务。<ul>
<li>它们跟踪正在运行和暂停的任务，对<code>future</code>进行<code>poll</code>直到完成，并在任务能够取得进展时唤醒任务</li>
<li>“<code>执行者</code>”一词经常与“<code>运行时</code>”互换使用。</li>
</ul>
</li>
<li>我们使用“<code>生态系统</code>”一词来描述一个与兼容<code>trait</code>和特性捆绑在一起的运行时。</li>
</ul>
<p><strong>社区提供的 async crates</strong></p>
<ul>
<li><code>futures crate</code>，提供了<code>Stream</code>、<code>Sink</code>、<code>AsyncRead</code>、<code>AsyncWrite</code>等<code>trait</code>，以及组合器等工具。这些可能最终会成为标准库的一部分</li>
<li><code>futures</code>有自己的执行器，但没有自己的反应器，因此它不支持<code>async I/O</code>或计时器<code>future</code>的执行。</li>
<li>因此，它不被认为是完整的运行时。</li>
<li>常见的选择是:与另一个<code>crate</code>中的执行器一起使用来自<code>futures</code>提供的工具</li>
</ul>
<p><strong>流行的运行时</strong></p>
<ul>
<li><code>Tokio</code>:一个流行的<code>async</code>生态系统，包含<code>HTTP</code>、<code>gRPC</code>和跟踪框架</li>
<li><code>async-std</code>:提供标准库的<code>async</code>副本</li>
<li><code>smol</code>:小型、简化的<code>async</code>运行时。提供可用于包装<code>UnixStream</code>或<code>TcpListener</code>等结构的<code>async trait</code></li>
<li><code>fuchsia-async</code>: 用于<code>Fuchsia OS</code>的执行器</li>
</ul>
<p><strong>确定生态兼容性</strong></p>
<ul>
<li>与<code>async I/O</code>、计时器、进程间通信或任务交互的<code>async</code>代码通常取决于特定的异步执行器或反应器</li>
<li>所有其他<code>async</code>代码，如异步表达式、组合器、同步类型和流，通常与生态系统无关，前提是任何嵌套的<code>future</code>也与生态系统无关</li>
<li>在开始一个项目之前，建议研究相关的<code>async</code>框架和库，以确保与您选择的运行时以及彼此之间的兼容性。</li>
</ul>
<h1 id="九、并发-Web-服务器"><a href="#九、并发-Web-服务器" class="headerlink" title="九、并发 Web 服务器"></a>九、并发 Web 服务器</h1><p>非并发<code>Demo</code></p>
<pre><code>use std::fs;
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;

fn main() {
    // 在端口7878侦听传入链接
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    // 一直阻塞,处理到达这个IP地址的每一个请求
    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    // 从流中读取前1024字节的数据
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).unwrap();

    let get = b"GET / HTTP/1.1\r\n";

    // 根据请求的数据决定响应问候还是404.
    let (status_line, filename) = if buffer.starts_with(get) {
        ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND\r\n\r\n", "404.html")
    };
    let contents = fs::read_to_string(filename).unwrap();

    // 将响应写回流并刷新(flush)以确保响应被发送回客户端.
    let response = format!("{}{}", status_line, contents);
    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
</code></pre>
<p>异步<code>Demo</code></p>
<pre><code>[dependencies]
futures = "0.3"

[dependencies.async-std]
version = "1.6"
features = ["attributes"]
</code></pre>
<p><code>src/main.rs</code></p>
<pre><code>use async_std;
use async_std::io::ReadExt;
use async_std::net::{TcpListener };
use async_std::task::spawn;
use async_web_server::*;
use futures::{AsyncWriteExt, StreamExt};
use std::fs;
use std::time::Duration;
use async_std::io::Read;
use async_std::io::Write;

#[async_std::main]
async fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").await.unwrap();

    listener
        .incoming()
        .for_each_concurrent(None, |tcp_stream| async move {
            let stream = tcp_stream.unwrap();
            spawn(handle_connection(stream));
        })
        .await;

    print!("Shutting down");
}

async fn handle_connection(mut stream: impl Read + Write + Unpin) {
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).await.unwrap();

    let mut file_type = HtmlFile::NotFound;

    if buffer.starts_with(GET) {
        file_type = HtmlFile::OK
    } else if buffer.starts_with(SLEEP) {
        async_std::task::sleep(Duration::from_secs(5)).await;
        file_type = HtmlFile::SLEEP
    }

    build_content(file_type, stream).await;
}

async fn build_content(file: HtmlFile, mut stream: impl Read + Write + Unpin) {
    let (path, status_line) = match file {
        HtmlFile::OK =&gt; ("hello.html", "HTTP/1.1 200 OK"),
        HtmlFile::SLEEP =&gt; ("hello.html", "HTTP/1.1 200 OK"),
        _ =&gt; ("404.html", "HTTP/1.1 404 NOT FOUND"),
    };

    let contents = fs::read_to_string(path).unwrap();
    let response = format!(
        "{}\r\nContent-Length: {}\r\n\r\n{}",
        status_line,
        contents.len(),
        contents
    );
    stream.write(response.as_bytes()).await.unwrap();
    stream.flush().await.unwrap();
}

#[async_std::test]
async fn test_handle_connection() {
    let input_bytes = b"GET / HTTP/1.1\r\n";
    let mut contents = vec![0u8; 1024];
    contents[..input_bytes.len()].clone_from_slice(input_bytes);
    let mut stream = MockTcpStream {
        read_data: contents,
        write_data: Vec::new(),
    };

    handle_connection(&amp;mut stream).await;
    let mut buf = [0u8; 1024];
    stream.read(&amp;mut buf).await.unwrap();

    let expected_contents = fs::read_to_string("hello.html").unwrap();
    let expected_response = format!("HTTP/1.1 200 OK\r\n\r\n{}", expected_contents);
    assert!(stream.write_data.starts_with(expected_response.as_bytes()));
}
</code></pre>
<p>文件<code>src/lib.rs</code></p>
<pre><code>use async_std::io::{Read, Write};
use futures::task::{Context, Poll};

use std::cmp::min;
use std::pin::Pin;

pub const GET: &amp;[u8] = b"GET / HTTP/1.1\r\n";
pub const SLEEP: &amp;[u8] = b"GET /sleep HTTP/1.1\r\n";

pub enum HtmlFile {
    OK,
    SLEEP,
    NotFound,
}

pub struct MockTcpStream {
    pub read_data: Vec&lt;u8&gt;,
    pub write_data: Vec&lt;u8&gt;,
}

impl Read for MockTcpStream {
    fn poll_read(
        self: Pin&lt;&amp;mut Self&gt;,
        _: &amp;mut Context&lt;'_&gt;,
        buf: &amp;mut [u8],
    ) -&gt; Poll&lt;std::io::Result&lt;usize&gt;&gt; {
        let size: usize = min(self.read_data.len(), buf.len());
        buf[..size].copy_from_slice(&amp;self.read_data[..size]);
        Poll::Ready(Ok(size))
    }
}

impl Write for MockTcpStream {
    fn poll_write(
        mut self: Pin&lt;&amp;mut Self&gt;,
        _: &amp;mut Context&lt;'_&gt;,
        buf: &amp;[u8],
    ) -&gt; Poll&lt;std::io::Result&lt;usize&gt;&gt; {
        self.write_data = Vec::from(buf);
        Poll::Ready(Ok(buf.len()))
    }

    fn poll_flush(self: Pin&lt;&amp;mut Self&gt;, _: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;std::io::Result&lt;()&gt;&gt; {
        Poll::Ready(Ok(()))
    }

    fn poll_close(self: Pin&lt;&amp;mut Self&gt;, _: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;std::io::Result&lt;()&gt;&gt; {
        Poll::Ready(Ok(()))
    }
}

impl Unpin for MockTcpStream {}
</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023/02/25/hello-regular-expr/" title="《正则表达式必知必会》"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 《正则表达式必知必会》</span></a><a class="button is-default" href="/2023/02/18/hello-rust/" title="《Hello Rust》"><span class="has-text-weight-semibold">下一页: 《Hello Rust》</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="fanlv/blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/fanlv"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com/fanlvlgh"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Ryo 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p class="is-flex is-justify-content-center"><a title="备案号：鄂ICP备2022016224号-2" target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn/">备案号：鄂ICP备2022016224号-2 &nbsp;</a></p></div><div><span>博学之，审问之，慎思之，明辨之，笃行之</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>