<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>《Rust 编程第一课》</title><meta name="description" content="行万里路，读万卷书"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "https://hm.baidu.com/hm.js?" + '2c076421eb9f21a0a143f8ee9c4ab171';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><meta name="referrer" content="no-referrer"><link rel="icon" href="/null"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="《陈天 · Rust 编程第一课》
一、所有权


脑图链接
所有权和生命周期是Rust和其它编程语言的主要区别，也是Rust其它知识点的基础。
1.1、变量在函数调用时发生了什么fn main() {
    // vec 动态数组因为大小在编译期无法确定，所以放在堆上，
    // 并且在栈上有一个包含了长度和容量的胖指针指向堆上的内存。
    let data = vec![10, 42, 9, 8];
    let v = 42;
    if let Some(pos) = find_pos(data, v) {
        println!(&quot;Found {} at {}&quot;, v, pos);
    }
}

fn find_pos(data: Vec&amp;lt;u32&amp;gt;, v: .."><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Ryo's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">《Rust 编程第一课》</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-text">一、所有权</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E3%80%81%E5%8F%98%E9%87%8F%E5%9C%A8%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">1.1、变量在函数调用时发生了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E3%80%81%E6%89%80%E6%9C%89%E6%9D%83%E5%92%8C-Move-%E8%AF%AD%E4%B9%89"><span class="toc-text">1.2、所有权和 Move 语义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3%E3%80%81Copy-%E8%AF%AD%E4%B9%89"><span class="toc-text">1.3、Copy 语义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4%E3%80%81Borrow-%E8%AF%AD%E4%B9%89"><span class="toc-text">1.4、Borrow 语义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5%E3%80%81Rc"><span class="toc-text">1.5、Rc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6%E3%80%81RefCell-%E5%92%8C%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-text">1.6、RefCell 和内部可变性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7%E3%80%81Arc-%E5%92%8C-Mutex-RwLock"><span class="toc-text">1.7、Arc 和 Mutex&#x2F;RwLock</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">二、生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81%E5%80%BC%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">2.1、值的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8"><span class="toc-text">2.2、生命周期标注</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">三、内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81%E5%80%BC%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">3.1、值的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E3%80%81%E5%80%BC%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">3.2、值的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E3%80%81%E5%80%BC%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-text">3.3、值的销毁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="toc-text">四、类型系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E3%80%81%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="toc-text">4.1、类型系统基本概念与分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E3%80%81Rust-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="toc-text">4.2、Rust 类型系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="toc-text">4.3、泛型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81trait"><span class="toc-text">五、trait</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFtrait"><span class="toc-text">5.1、什么是trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E3%80%81%E5%B8%A6%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B%E7%9A%84-trait"><span class="toc-text">5.2、带关联类型的 trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E3%80%81%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B%E7%9A%84-trait"><span class="toc-text">5.3、支持泛型的 trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4%E3%80%81trait-%E7%9A%84%E2%80%9C%E7%BB%A7%E6%89%BF%E2%80%9D"><span class="toc-text">5.4、trait 的“继承”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5%E3%80%81%E5%AD%90%E7%B1%BB%E5%9E%8B%E5%A4%9A%E6%80%81"><span class="toc-text">5.5、子类型多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6%E3%80%81Trait-Object-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E7%90%86"><span class="toc-text">5.6、Trait Object 的实现机理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84trait"><span class="toc-text">六、常见的trait</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E3%80%81Clone-Copy-Drop"><span class="toc-text">6.1、Clone&#x2F;Copy&#x2F;Drop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E3%80%81Sized-Send-Sync-Unpin"><span class="toc-text">6.2、Sized&#x2F;Send&#x2F;Sync&#x2F;Unpin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3%E3%80%81From-Into-AsRef-AsMut"><span class="toc-text">6.3、From&#x2F;Into&#x2F;AsRef&#x2F;AsMut</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4%E3%80%81Deref-DerefMut"><span class="toc-text">6.4、Deref&#x2F;DerefMut</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5%E3%80%81Debug-Display-Default"><span class="toc-text">6.5、Debug&#x2F;Display&#x2F;Default</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">七、智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1%E3%80%81String"><span class="toc-text">7.1、String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2%E3%80%81Box-lt-T-gt"><span class="toc-text">7.2、Box&lt;T&gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3%E3%80%81PhantomData"><span class="toc-text">7.3、PhantomData</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4%E3%80%81Cow-lt-%E2%80%99a-B-gt"><span class="toc-text">7.4、Cow&lt;’a, B&gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5%E3%80%81MutexGuard"><span class="toc-text">7.5、MutexGuard</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6%E3%80%81%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">7.6、实现自己的智能指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8"><span class="toc-text">八、集合容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1%E3%80%81%E5%88%87%E7%89%87"><span class="toc-text">8.1、切片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator"><span class="toc-text">8.2、迭代器 Iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3%E3%80%81-amp-str%E3%80%81String%E3%80%81-amp-String"><span class="toc-text">8.3、&amp;str、String、&amp;String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4%E3%80%81Vet-lt-T-gt-%E3%80%81Box-lt-T-gt-%E3%80%81-amp-T%E3%80%81-amp-mut-T"><span class="toc-text">8.4、Vet&lt;T&gt;、Box&lt;[T]&gt;、&amp;T、&amp;mut T</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">九、哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1%E3%80%81HashMap-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">9.1、HashMap 的数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2%E3%80%81HashMap-%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-text">9.2、HashMap 的内存布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3%E3%80%81%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%80%BC"><span class="toc-text">9.3、删除一个值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89-Hash-key"><span class="toc-text">9.4、自定义 Hash key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5%E3%80%81HashSet-BTreeMap-BTreeSet"><span class="toc-text">9.5、HashSet&#x2F;BTreeMap&#x2F;BTreeSet</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">十、错误处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E9%97%AD%E5%8C%85%EF%BC%9AFnOnce%E3%80%81FnMut%E3%80%81Fn"><span class="toc-text">十一、闭包：FnOnce、FnMut、Fn</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1%E3%80%81%E9%97%AD%E5%8C%85%E6%9C%AC%E8%B4%A8%E4%B8%8A%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">11.1、闭包本质上是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2%E3%80%81FnOnce"><span class="toc-text">11.2、FnOnce</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3%E3%80%81FnMut"><span class="toc-text">11.3、FnMut</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4%E3%80%81Fn"><span class="toc-text">11.4、Fn</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-5%E3%80%81%E9%97%AD%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">11.5、闭包的使用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81unsafe"><span class="toc-text">十二、unsafe</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-unsafe-trait"><span class="toc-text">12.1 unsafe trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2%E3%80%81unsafe-%E5%87%BD%E6%95%B0"><span class="toc-text">12.2、unsafe 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-%E5%AF%B9%E8%A3%B8%E6%8C%87%E9%92%88%E8%A7%A3%E5%BC%95%E7%94%A8"><span class="toc-text">12.3 对裸指针解引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-4-FFI"><span class="toc-text">12.4 FFI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-5-%E4%B8%8D%E6%8E%A8%E8%8D%90-unsafe-%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">12.5 不推荐 unsafe 的场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Rust-%E7%89%B9%E7%82%B9"><span class="toc-text">1、Rust 特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">2、基本语法和基础数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="toc-text">3、控制流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-text">4、模式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Rust-%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-text">5、Rust 项目的组织</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-text">6、常见问题</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Book"><i class="tag post-item-tag">Book</i></a><a href="/tags/Rust"><i class="tag post-item-tag">Rust</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">《Rust 编程第一课》</h1><time class="has-text-grey" datetime="2023-05-08T07:43:28.000Z">2023-05-08</time><article class="mt-2 post-content"><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100085301">《陈天 · Rust 编程第一课》</a></p>
<h1 id="一、所有权"><a href="#一、所有权" class="headerlink" title="一、所有权"></a>一、所有权</h1><p><img src="https://upload-images.jianshu.io/upload_images/12321605-2a66ecf34128d7fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ownership.png"></p>
<!--[原图链接点我](./ownership.png)-->

<p><a target="_blank" rel="noopener" href="https://eq2dxlycqpe.feishu.cn/mindnotes/Tzt0btjwlmctNinoYmIcX2ppnnb#mindmap">脑图链接</a></p>
<p>所有权和生命周期是<code>Rust</code>和其它编程语言的主要区别，也是<code>Rust</code>其它知识点的基础。</p>
<h2 id="1-1、变量在函数调用时发生了什么"><a href="#1-1、变量在函数调用时发生了什么" class="headerlink" title="1.1、变量在函数调用时发生了什么"></a>1.1、变量在函数调用时发生了什么</h2><pre><code>fn main() {
    // vec 动态数组因为大小在编译期无法确定，所以放在堆上，
    // 并且在栈上有一个包含了长度和容量的胖指针指向堆上的内存。
    let data = vec![10, 42, 9, 8];
    let v = 42;
    if let Some(pos) = find_pos(data, v) {
        println!("Found {} at {}", v, pos);
    }
}

fn find_pos(data: Vec&lt;u32&gt;, v: u32) -&gt; Option&lt;usize&gt; {
    for (pos, item) in data.iter().enumerate() {
        if *item == v {
            return Some(pos);
        }
    }
    
    None
}
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-f8dcb08f7834df9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>按照大多数编程语言的做法，我们每把<code>data</code>作为参数传递一次，<strong>堆上的内存就会多一次引用</strong>。</p>
<p><strong>堆内存多次被引用的问题：</strong></p>
<ul>
<li>这些引用究竟会做什么操作，我们不得而知，也无从限制；</li>
<li>而且堆上的内存究竟什么时候能释放，尤其在多个调用栈引用时，很难厘清，取决于最后一个引用什么时候结束</li>
</ul>
<p><strong>我们先来看大多数语言的方案：</strong></p>
<ul>
<li><code>C/C++</code>要求开发者手工处理，非常不便。这需要我们在写代码时高度自律，按照前人总结的最佳实践来操作。但人必然会犯错，一个不慎就会导致内存安全问题，要么内存泄露，要么使用已释放内存，导致程序崩溃。</li>
<li><code>Java</code>等语言使用追踪式<code>GC</code>，通过定期扫描堆上数据还有没有人引用，来替开发者管理堆内存，不失为一种解决之道，但 GC 带来的 STW 问题让语言的使用场景受限，性能损耗也不小。</li>
<li><code>ObjC/Swift</code> 使用自动引用计数（<code>ARC</code>），在编译时自动添加维护引用计数的代码，减轻开发者维护堆内存的负担。但同样地，它也会有不小的运行时性能损耗。</li>
</ul>
<p><strong>Rust 的解决思路</strong></p>
<p>在<code>Rust</code>以前，引用是一种随意的、可以隐式产生的、对权限没有界定的行为，比如<code>C</code>里到处乱飞的指针、<code>Java</code>中随处可见的按引用传参，它们可读可写，权限极大。<strong>而 Rust 决定限制开发者随意引用的行为</strong>。</p>
<h2 id="1-2、所有权和-Move-语义"><a href="#1-2、所有权和-Move-语义" class="headerlink" title="1.2、所有权和 Move 语义"></a>1.2、所有权和 Move 语义</h2><p><code>Rust</code>给出了如下规则：</p>
<ul>
<li>一个值只能被一个变量所拥有，这个变量被称为所有者（<code>Each value in Rust has a variable that’s called its owner</code>）。</li>
<li>一个值同一时刻只能有一个所有者（<code>There can only be one owner at a time</code>），也就是说不能有两个变量拥有相同的值。所以对应刚才说的变量赋值、参数传递、函数返回等行为，旧的所有者会把值的所有权转移给新的所有者，以便保证单一所有者的约束。</li>
<li>当所有者离开作用域，其拥有的值被丢弃（<code>When the owner goes out of scope, the value will be dropped</code>），内存得到释放。</li>
</ul>
<p>上面代码在<code>Rust</code>会变成下图这样：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-ab6c70e615078a2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>所有权规则，解决了谁真正拥有数据的生杀大权问题，让堆上数据的多重引用不复存在，这是它最大的优势。</strong></p>
<pre><code>fn main() {
    let data = vec![1, 2, 3, 4];
    let data1 = data;
    println!("sum of data1: {}", sum(data1));
    println!("data1: {:?}", data1); // error1  data1 所有权已经转移到 sum 中去了，不能在用了。
    println!("sum of data: {}", sum(data)); // error2  data 转移给 data1。
}

fn sum(data: Vec&lt;u32&gt;) -&gt; u32 {
    data.iter().fold(0, |acc, x| acc + x)
}
</code></pre>
<p>像上面代码这种情况，<strong>如何要避免所有权转移之后不能访问的情况</strong>？ </p>
<ol>
<li><p><code>Copy</code>，如果你不希望值的所有权被转移，在<code>Move</code>语义外，<code>Rust</code>提供了<code>Copy</code>语义。如果一个数据结构实现了 <code>Copy trait</code>，那么它就会使用<code>Copy</code>语义。这样，在你赋值或者传参时，值会自动按位拷贝（浅拷贝）</p>
<pre><code> let a = 100;
 let b = a; // copy
 println!("a = {}, b = {} ",a,b) // a = 100, b = 100 
</code></pre>
</li>
<li><p><code>Borrow</code>，如果你不希望值的所有权被转移，又无法使用 Copy 语义，那你可以“借用”数据，我们下一讲会详细讨论“借用”。</p>
</li>
</ol>
<h2 id="1-3、Copy-语义"><a href="#1-3、Copy-语义" class="headerlink" title="1.3、Copy 语义"></a>1.3、Copy 语义</h2><p><code>Copy</code>总结：</p>
<ul>
<li>原生类型，包括函数、不可变引用和裸指针实现了<code>Copy</code>；</li>
<li>数组和元组，如果其内部的数据结构实现了<code>Copy</code>，那么它们也实现了<code>Copy</code>；</li>
<li>可变引用没有实现<code>Copy</code>；</li>
<li>非固定大小的数据结构，没有实现<code>Copy</code>。 比如<code>Vec</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/marker/trait.Copy.html">Trait std::marker::Copy</a></p>
<p>有些类型在<code>Rust</code>中没有实现<code>Copy trait</code>。这些类型在赋值时涉及资源管理、堆内存分配或可变借用等问题。以下是一些没有实现<code>Copy trait</code>的类型：</p>
<ol>
<li><p><code>String</code>：<code>String</code>类型分配堆内存以存储字符串数据，所以它不实现<code>Copy trait</code>。当从一个<code>String</code>变量赋值给另一个变量时，会发生所有权的转移（称为<code>move</code>）。</p>
</li>
<li><p><code>Vec</code>：<code>Vec</code> (向量) 类型分配堆内存以存储一个元素的动态列表。类似于<code>String</code>，<code>Vec</code>类型也不实现<code>Copy trait</code>，因为它涉及内存管理。将一个<code>Vec</code>变量赋给另一个时，同样会发生所有权转移。</p>
</li>
<li><p><code>Box</code>：<code>Box</code>是一个智能指针，它在堆上分配内存并保存一个值。<code>Box</code>类型没有<code>Copy trait</code>，因为它在堆上拥有内存。 将<code>Box</code>变量赋给另一个时，进行所有权转移。</p>
</li>
<li><p><code>HashMap</code>和<code>HashSet</code>：这些集合类型在堆上分配内存以存储元素。它们管理资源并涉及内存分配，所以没有实现<code>Copy trait</code>。</p>
</li>
<li><p><code>Rc</code>和<code>Arc</code>：<code>Rc</code>（引用计数智能指针）和<code>Arc</code>（跨线程原子引用计数智能指针）都实现了共享所有权的概念。由于资源共享和引用计数，它们不实现<code>Copy trait</code>。</p>
</li>
<li><p>自定义类型：对于用户定义的结构体和枚举类型，如果其成员中至少有一个类型没有实现<code>Copy trait</code>，那么这个自定义类型也不会自动实现<code>Copy trait</code>。你可以通过明确地要求实现<code>Copy</code>和<code>Clone trait</code>来实现。</p>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-d2dc72b0599c29f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>在 Rust 下，分配在堆上的数据结构可以引用栈上的数据么？为什么？</strong></p>
<p>可以，只要栈上的数据生命周期大于堆上数据的生命周期就可以，简单来说就是在堆上数据被回收之前栈上的数据一定会存在的情况下，是可以的。</p>
<pre><code>let x = 1;
let y = 2;
let v = vec![&amp;x, &amp;y];
println!("{:?}", v);
</code></pre>
<h2 id="1-4、Borrow-语义"><a href="#1-4、Borrow-语义" class="headerlink" title="1.4、Borrow 语义"></a>1.4、Borrow 语义</h2><p><code>Borrow</code>语义允许一个值的所有权，在不发生转移的情况下，被其它上下文使用。</p>
<p>其实，在 Rust 中，<code>借用</code>和<code>引用</code>是一个概念，只不过在其他语言中引用的意义和<code>Rust</code>不同，所以<code>Rust</code>提出了新概念<code>借用</code>，便于区分。</p>
<p><strong>在其他语言中，引用是一种别名</strong>，你可以简单理解成鲁迅之于周树人，多个引用拥有对值的无差别的访问权限，本质上是共享了所有权；而在<code>Rust</code>下，所有的引用都只是借用了“临时使用权”，它并不破坏值的单一所有权约束。</p>
<p><strong>1.4.1、只读借用/引用</strong></p>
<p>以<code>Java</code>为例，给函数传一个整数，这是传值，和<code>Rust</code>里的<code>Copy</code>语义一致；而给函数传一个对象，或者任何堆上的数据结构，<code>Java</code>都会自动隐式地传引用。刚才说过，<code>Java</code>的引用是对象的别名，这也导致随着程序的执行，同一块内存的引用到处都是，不得不依赖<code>GC</code>进行内存回收。</p>
<p>但<code>Rust</code>没有传引用的概念，<strong>Rust 所有的参数传递都是传值，</strong>不管是<code>Copy</code>还是<code>Move</code>（<code>类似Go</code>）。所以在<code>Rust</code>中，你必须显式地把某个数据的引用，传给另一个函数。</p>
<p><strong>Rust 的引用实现了 Copy trait，所以按照 Copy 语义</strong>，这个引用会被复制一份交给要调用的函数。对这个函数来说，它并不拥有数据本身，数据只是临时借给它使用，所有权还在原来的拥有者那里。</p>
<pre><code>fn main() {
    let data = vec![1, 2, 3, 4];
    let data1 = &amp;data;

    println!("data = {:?}",data); // data = [1, 2, 3, 4]
    // 值的地址是什么？引用的地址又是什么？
    println!(
        "addr of value: {:p}({:p}), addr of data {:p}, data1: {:p}",
        &amp;data, data1, &amp;&amp;data, &amp;data1
    ); // addr of value: 0x16f3a25f8(0x16f3a25f8), addr of data 0x16f3a26d8, data1: 0x16f3a2610

     // 只读引用实现了 Copy trait，也就意味着引用的赋值、传参都会产生新的浅拷贝。
    println!("sum of data1: {}", sum(data1)); 
    // addr of value: 0x16f3a25f8, addr of ref: 0x16f3a24b0

    // 堆上数据的地址是什么？
    println!(
        "addr of items: [{:p}, {:p}, {:p}, {:p}]",
        &amp;data[0], &amp;data[1], &amp;data[2], &amp;data[3]
    ); // addr of items: [0x600000608050, 0x600000608054, 0x600000608058, 0x60000060805c]
}


fn sum(data: &amp;Vec&lt;u32&gt;) -&gt; u32 {
    // 值的地址会改变么？引用的地址会改变么？
    println!("addr of value: {:p}, addr of ref: {:p}", data, &amp;data);
    data.iter().fold(0, |acc, x| acc + x)
}
    
</code></pre>
<p><strong>只读引用实现了 Copy trait，也就意味着引用的赋值、传参都会产生新的浅拷贝。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-494b34d2e501f67b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<br>

<p><strong>1.4.2、借用的生命周期及其约束</strong></p>
<p>代码一：</p>
<pre><code>// 这段代码会报错了，因为 a 的生命周期 小于 r ，所以不能把 a 的引用给 r
fn main() {
    let r = local_ref();
    println!("r: {:p}", r);
}

fn local_ref&lt;'a&gt;() -&gt; &amp;'a i32 {
    let a = 42;
    &amp;a
}
</code></pre>
<p>代码二：</p>
<pre><code>// 这段代码正常，因为 42 虽然在栈上，data在堆上。但是42 和 data的生命周期是一样的，所以可以引用
fn main() {
    let mut data: Vec&lt;&amp;u32&gt; = Vec::new();
    let v = 42;
    data.push(&amp;v);
    println!("data: {:?}", data);
}
</code></pre>
<p>代码三：</p>
<pre><code>// push_local_ref 中 42的生命周期小于 data 生命周期，所以代码报错。
fn main() {
    let mut data: Vec&lt;&amp;u32&gt; = Vec::new();
    push_local_ref(&amp;mut data);
    println!("data: {:?}", data);
}

fn push_local_ref(data: &amp;mut Vec&lt;&amp;u32&gt;) {
    let v = 42;
    data.push(&amp;v);
}
</code></pre>
<p>抓住了一个核心要素“<strong>在一个作用域下，同一时刻，一个值只能有一个所有者</strong>”。</p>
<p>堆变量的生命周期不具备任意长短的灵活性，因为堆上内存的生死存亡，跟栈上的所有者牢牢绑定。而栈上内存的生命周期，又跟栈的生命周期相关，<strong>所以我们核心只需要关心调用栈的生命周期</strong>。</p>
<p><strong>1.4.3、可变借用/引用</strong></p>
<p>多个可变引用共存报错的例子：</p>
<pre><code>fn main() {
    let mut data = vec![1, 2, 3];

    for item in data.iter_mut() {
        data.push(*item + 1); // 报错 cannot borrow `data` as mutable more than 
         // once at a time [E0499] second mutable borrow occurs here
    }
}
</code></pre>
<p>那如果同时有一个可变引用和若干个只读引用</p>
<pre><code>fn main() {
    let mut data = vec![1, 2, 3];
    let data1 = vec![&amp;data[0]];
    println!("data[0]: {:p}", &amp;data[0]);

    for i in 0..100 {
        data.push(i); // cannot borrow `data` as mutable because it is 
        //also borrowed as immutable [E0502] mutable borrow occurs here
    }

    println!("data[0]: {:p}", &amp;data[0]);
    println!("boxed: {:p}", &amp;data1);

    // 如果你仔细推敲，就会发现这里有内存不安全的潜在操作：如果继续添加元素，
    // 堆上的数据预留的空间不够了，就会重新分配一片足够大的内存，把之前的值拷过来，
    // 然后释放旧的内存。这样就会让 data1 中保存的 &amp;data[0] 引用失效，导致内存安全问题。
}
</code></pre>
<p><strong>Rust 引用的限制</strong>，所以为了保证内存安全，<code>Rust</code>对可变引用的使用也做了严格的约束：</p>
<ul>
<li>在一个作用域内，<strong>仅允许一个活跃的可变引用</strong>。所谓活跃，就是真正被使用来修改数据的可变引用，如果只是定义了，却没有使用或者当作只读引用使用，不算活跃。</li>
<li>在一个作用域内，活跃的<strong>可变引用</strong>（写）和<strong>只读引用</strong>（读）是互斥的，<strong>不能同时存在</strong>。</li>
</ul>
<p>从可变引用的约束我们也可以看到，<strong>Rust 不光解决了 GC 可以解决的内存安全问题</strong>，还解决了<code>GC</code>无法解决的问题。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-4a7d2b50ff883955.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>1.4.4、小结</strong></p>
<ol>
<li>一个值在同一时刻只有一个所有者。当所有者离开作用域，其拥有的值会被丢弃。赋值或者传参会导致值 Move，所有权被转移，一旦所有权转移，之前的变量就不能访问。</li>
<li>如果值实现了 Copy trait，那么赋值或传参会使用 Copy 语义，相应的值会被按位拷贝，产生新的值。</li>
<li>一个值可以有多个只读引用。</li>
<li>一个值可以有唯一一个活跃的可变引用。可变引用（写）和只读引用（读）是互斥的关系，就像并发下数据的读写互斥那样。</li>
<li>引用的生命周期不能超出值的生命周期。</li>
</ol>
<p><strong>1.4.5、可变引用是如何导致堆内存重新分配的</strong></p>
<pre><code>use std::mem;

fn main() {
    // capacity 是 1, len 是 0
    let mut v = vec![1];
    // capacity 是 8, len 是 0
    let v1: Vec&lt;i32&gt; = Vec::with_capacity(8);

    print_vec("v1", v1);

    // 我们先打印 heap 地址，然后看看添加内容是否会导致堆重分配
    println!("heap start: {:p}", &amp;v[0] as *const i32);

    extend_vec(&amp;mut v);

    // heap 地址改变了！这就是为什么可变引用和不可变引用不能共存的原因
    println!("new heap start: {:p}", &amp;v[0] as *const i32);

    print_vec("v", v);
}

fn extend_vec(v: &amp;mut Vec&lt;i32&gt;) {
    // Vec&lt;T&gt; 堆内存里 T 的个数是指数增长的，我们让它恰好 push 33 个元素
    // capacity 会变成 64
    (2..34).into_iter().for_each(|i| v.push(i));
}

fn print_vec&lt;T&gt;(name: &amp;str, data: Vec&lt;T&gt;) {
    let p: [usize; 3] = unsafe { mem::transmute(data) };
    // 打印 Vec&lt;T&gt; 的堆地址，capacity，len
    // 注意这个不同系统/CPU 内存的排序不一样。
    println!("{}: cap = {}, data = 0x{:x}, len = {}", name, p[0], p[1], p[2]);
}
</code></pre>
<h2 id="1-5、Rc"><a href="#1-5、Rc" class="headerlink" title="1.5、Rc"></a>1.5、Rc</h2><p>抛出问题：</p>
<ul>
<li>一个有向无环图（<code>DAG</code>）中，某个节点可能有两个以上的节点指向它，这个按照所有权模型怎么表述？ 比如 双向链表节点。</li>
<li>多个线程要访问同一块共享内存，怎么办？</li>
</ul>
<p>我们知道，这些问题在程序运行过程中才会遇到，在编译期，<strong>所有权的静态检查无法处理它们</strong>，所以为了更好的灵活性，<code>Rust</code>提供了运行时的动态检查，来满足特殊场景下的需求。</p>
<p>那具体如何在运行时做动态检查呢？运行时的动态检查又如何与编译时的静态检查自洽呢？</p>
<p><code>Rust</code>的答案是使用引用计数的智能指针：<code>Rc（Reference counter）</code> 和 <code>Arc（Atomic reference counter）</code>。这里要特别说明一下，<code>Arc</code> 和 <code>ObjC/Swift</code> 里的 <code>ARC（Automatic Reference Counting）</code>不是一个意思，不过它们解决问题的手段类似，都是通过引用计数完成的。</p>
<p><strong>1.5.1、Rc</strong></p>
<p>我们先看<code>Rc</code>。对某个数据结构<code>T</code>，我们可以创建引用计数<code>Rc</code>，使其有多个所有者。<code>Rc</code>会把对应的数据结构创建在堆上，堆是唯一可以让动态创建的数据被到处使用的内存。</p>
<pre><code>use std::rc::Rc;
fn main() {    
  let a = Rc::new(1);
}
</code></pre>
<p><strong>对一个 Rc 结构进行 clone()，不会将其内部的数据复制，只会增加引用计数</strong>。而当一个<code>Rc</code>结构离开作用域被 <code>drop()</code>时，也只会减少其引用计数，直到引用计数为零，才会真正清除对应的内存。</p>
<pre><code>use std::rc::Rc;
fn main() {
    let a = Rc::new(1);
    let b = a.clone();
    let c = a.clone();
}
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-70b19f1f4d38167f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<pre><code>fn clone(&amp;self) -&gt; Rc&lt;T&gt; {
    // 增加引用计数
    self.inner().inc_strong();
    // 通过 self.ptr 生成一个新的 Rc 结构
    Self::from_inner(self.ptr)
}
</code></pre>
<p><strong>1.5.2、Box::leak() 机制</strong></p>
<p><code>Rust</code>必须提供一种机制，让代码可以像<code>C/C++</code>那样，<strong>创建不受栈内存控制的堆内存</strong>，从而绕过编译时的所有权规则。<code>Rust</code>提供的方式是<code>Box::leak()</code>。</p>
<p><code>Box</code>是<code>Rust</code>下的智能指针，它可以强制把任何数据结构创建在堆上，然后在栈上放一个指针指向这个数据结构，但此时堆内存的生命周期仍然是受控的，跟栈上的指针一致。</p>
<p><code>Box::leak()</code>，顾名思义，它创建的对象，从堆内存上泄漏出去，不受栈内存控制，是一个自由的、生命周期可以大到和整个进程的生命周期一致的对象。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-e82d793fe8af261e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>有了 <code>Box::leak()</code>，我们就可以跳出<code>Rust</code>编译器的静态检查，<strong>保证 Rc 指向的堆内存，有最大的生命周期，然后我们再通过引用计数，在合适的时机，结束这段内存的生命周期</strong>。如果你对此感兴趣，<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/src/alloc/rc.rs.html">可以看 Rc::new() 的源码</a>。</p>
<p>搞明白了<code>Rc</code>，我们就进一步理解 <code>Rust</code>是如何进行所有权的静态检查和动态检查了：</p>
<ul>
<li>静态检查，靠编译器保证代码符合所有权规则；</li>
<li>动态检查，通过<code>Box::leak</code>让堆内存拥有不受限的生命周期，然后在运行过程中，通过对引用计数的检查，保证这样的堆内存最终会得到释放。</li>
</ul>
<p><strong>1.5.3、实现 DAG</strong></p>
<pre><code>use std::rc::Rc;

#[derive(Debug)]
struct Node {
    id: usize,
    downstream: Option&lt;Rc&lt;Node&gt;&gt;,
}

impl Node {
    pub fn new(id: usize) -&gt; Self {
        Self {
            id,
            downstream: None,
        }
    }

    pub fn update_downstream(&amp;mut self, downstream: Rc&lt;Node&gt;) {
        self.downstream = Some(downstream);
    }

    pub fn get_downstream(&amp;self) -&gt; Option&lt;Rc&lt;Node&gt;&gt; {
        self.downstream.as_ref().map(|v| v.clone())
    }
}

fn main() {
    let mut node1 = Node::new(1);
    let mut node2 = Node::new(2);
    let mut node3 = Node::new(3);
    let node4 = Node::new(4);
    node3.update_downstream(Rc::new(node4));

    node1.update_downstream(Rc::new(node3));
    node2.update_downstream(node1.get_downstream().unwrap());
    println!("node1: {:?}, node2: {:?}", node1, node2);
}
</code></pre>
<h2 id="1-6、RefCell-和内部可变性"><a href="#1-6、RefCell-和内部可变性" class="headerlink" title="1.6、RefCell 和内部可变性"></a>1.6、RefCell 和内部可变性</h2><p>在运行上述代码时，细心的你也许会疑惑：整个<code>DAG</code>在创建完成后还能修改么？</p>
<pre><code>let node5 = Node::new(5);
let node3 = node1.get_downstream().unwrap();
node3.update_downstream(Rc::new(node5)); // cannot borrow data in an `Rc` as mutable

println!("node1: {:?}, node2: {:?}", node1, node2);    
</code></pre>
<p><strong>这是因为 Rc 是一个只读的引用计数器</strong>，你无法拿到<code>Rc</code>结构内部数据的可变引用，来修改这个数据。这可怎么办？</p>
<p>这个就引出了<code>内部可变性</code>和<code>外部可变性</code>的概念：</p>
<ul>
<li>外部可变性（<code>exterior mutability</code>），用<code>let mut</code>显式地声明一个可变的值，或者用<code>&amp;mut</code>声明一个可变引用时，编译器可以在编译时进行严格地检查，保证只有可变的值或者可变的引用，才能修改值内部的数据，这被称作外部可变。</li>
<li>内部可变性（<code>internal mutability</code>），有时候我们希望能够绕开这个编译时的检查，对并未声明成<code>mut</code>的值或者引用，也想进行修改。在编译器的眼里，<strong>值是只读的，但是在运行时，这个值可以得到可变借用，从而修改内部的数据</strong></li>
</ul>
<p>我们可以用内部可变性<code>RefCell</code>，解决上面的问题：</p>
<pre><code>use std::cell::RefCell;

fn main() {
    let data = RefCell::new(1); // let 申明是不可变变量
    {
        // 获得 RefCell 内部数据的可变借用
        let mut v = data.borrow_mut();
        *v += 1;
    }
    println!("data: {:?}", data.borrow());
}
</code></pre>
<p>因为根据所有权规则，<strong>在同一个作用域下，我们不能同时有活跃的可变借用和不可变借用</strong>。通过这对花括号，我们明确地缩小了可变借用的生命周期，不至于和后续的不可变借用冲突。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-aad96d1fb9194836.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>1.6.1、实现可修改 DAG</strong></p>
<pre><code>use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    id: usize,
    // 使用 Rc&lt;RefCell&lt;T&gt;&gt; 让节点可以被修改
    downstream: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,
}

impl Node {
    pub fn new(id: usize) -&gt; Self {
        Self {
            id,
            downstream: None,
        }
    }

    pub fn update_downstream(&amp;mut self, downstream: Rc&lt;RefCell&lt;Node&gt;&gt;) {
        self.downstream = Some(downstream);
    }

    pub fn get_downstream(&amp;self) -&gt; Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt; {
        self.downstream.as_ref().map(|v| v.clone())
    }
}

fn main() {
    let mut node1 = Node::new(1);
    let mut node2 = Node::new(2);
    let mut node3 = Node::new(3);
    let node4 = Node::new(4);

    node3.update_downstream(Rc::new(RefCell::new(node4)));
    node1.update_downstream(Rc::new(RefCell::new(node3)));
    node2.update_downstream(node1.get_downstream().unwrap());
    println!("node1: {:?}, node2: {:?}", node1, node2);

    let node5 = Node::new(5);
    let node3 = node1.get_downstream().unwrap(); // 不可变变量
    // 获得可变引用，来修改 downstream
    node3.borrow_mut().downstream = Some(Rc::new(RefCell::new(node5)));

    println!("node1: {:?}, node2: {:?}", node1, node2);
}
</code></pre>
<h2 id="1-7、Arc-和-Mutex-RwLock"><a href="#1-7、Arc-和-Mutex-RwLock" class="headerlink" title="1.7、Arc 和 Mutex/RwLock"></a>1.7、Arc 和 Mutex/RwLock</h2><p><code>Arc</code>内部的引用计数使用了<code>Atomic Usize</code> ，而非普通的<code>usize</code>。从名称上也可以感觉出来，<code>Atomic Usize</code>是 <code>usize</code>的原子类型，它使用了<code>CPU</code>的特殊指令，来保证多线程下的安全。如果你对原子类型感兴趣，可以看 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/sync/atomic/index.html">std::sync::atomic</a>的文档。</p>
<p><code>Rust</code>实现两套不同的引用计数数据结构，完全是为了性能考虑，从这里我们也可以感受到<code>Rust</code>对性能的极致渴求。<strong>如果不用跨线程访问，可以用效率非常高的 Rc；如果要跨线程访问，那么必须用 Arc</strong>。</p>
<p>同样的，<code>RefCell</code>也不是线程安全的，如果我们要在多线程中，使用内部可变性，<code>Rust</code>提供了<code>Mutex</code>和<code>RwLock</code>。</p>
<pre><code>use std::sync::{Arc, Mutex};
use std::thread;

const NUM_THREADS: usize = 5;

fn main() {
    // 创建一个原子引用计数（Arc）的互斥量（Mutex），用来共享计数器数据
    let counter = Arc::new(Mutex::new(0));

    // 生成线程句柄集合
    let mut handles = vec![];

    for _ in 0..NUM_THREADS {
        // 克隆 Arc，使其可以在多个线程之间共享
        let counter = Arc::clone(&amp;counter);

        // 创建线程并更新计数器
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });

        // 将线程句柄添加到集合内
        handles.push(handle);
    }

    // 等待所有线程结束
    for handle in handles {
        handle.join().unwrap();
    }

    println!("Counter: {}", *counter.lock().unwrap());
}
</code></pre>
<h1 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h1><p><img src="https://upload-images.jianshu.io/upload_images/12321605-dfeb5ff7206c0f66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="lifetime.png"></p>
<!--[点我查看原图](./lifetime.png)-->
<p><a target="_blank" rel="noopener" href="https://eq2dxlycqpe.feishu.cn/mindnotes/XEzlbXpOZmUmFunRIxjcUhoxnYd#mindmap">脑图链接</a></p>
<p>而在 <code>Rust</code> 中，除非显式地做<code>Box::leak()/Box::into_raw()/ManualDrop</code>等动作，<strong>一般来说，堆内存的生命周期，会默认和其栈内存的生命周期绑定在一起。</strong></p>
<h2 id="2-1、值的生命周期"><a href="#2-1、值的生命周期" class="headerlink" title="2.1、值的生命周期"></a>2.1、值的生命周期</h2><p>如果一个值的生命周期贯穿整个进程的生命周期，那么我们就称这种生命周期为<strong>静态生命周期</strong>。</p>
<p>当值拥有静态生命周期，其引用也具有静态生命周期。我们在表述这种引用的时候，可以用<code>'static</code>来表示。比如： <code>&amp;'static str</code>代表这是一个具有静态生命周期的字符串引用。</p>
<p>一般来说，全局变量、静态变量、字符串字面量（<code>string literal</code>）等，都拥有静态生命周期。我们上文中提到的堆内存，如果使用了<code>Box::leak</code>后，也具有静态生命周期。</p>
<p>如果一个值是在某个作用域中定义的，也就是说它被创建在栈上或者堆上，<strong>那么其生命周期是动态的</strong>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-cec9222fb4f38156.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="2-2、生命周期标注"><a href="#2-2、生命周期标注" class="headerlink" title="2.2、生命周期标注"></a>2.2、生命周期标注</h2><p><img src="https://upload-images.jianshu.io/upload_images/12321605-f462ab98e756545c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<pre><code>fn main() {
    let s1 = String::from("Lindsey");
    let s2 = String::from("Rosie");

    let result = max(&amp;s1, &amp;s2);

    println!("bigger one: {}", result);
}

// 这段代码是无法编译通过的，它会报错 “missing lifetime specifier” 
// 也就是说，编译器在编译 max() 函数时，无法判断 s1、s2 和返回值的生命周期。
fn max(s1: &amp;str, s2: &amp;str) -&gt; &amp;str {
    if s1 &gt; s2 {
        s1
    } else {
        s2
    }
}
</code></pre>
<p>此时，就需要我们在函数签名中提供生命周期的信息，也就是生命周期标注（<code>lifetime specifier</code>）。在生命周期标注时，使用的参数叫生命周期参数（<code>lifetime parameter</code>）。通过生命周期标注，我们告诉编译器这些引用间生命周期的约束。</p>
<pre><code>fn max&lt;'a&gt;(s1: &amp;'a str, s2: &amp;'a str) -&gt; &amp;'a str {
    if s1 &gt; s2 {
        s1
    } else {
        s2
    }
}

fn main() {
    let string1 = String::from("xyz1");
    let result;
    {
        let string2 = String::from("xyz");
        result = max(&amp;string1, &amp;string2);
        println!("{}", result);
    }
}
</code></pre>
<p><strong>2.2.1、编译器声明周期标注规则</strong></p>
<p>虽然我们没有做任何生命周期的标注，但编译器会通过一些简单的规则为函数<strong>自动添加标注</strong>：</p>
<ul>
<li>所有引用类型的参数都有独立的生命周期 <code>'a</code> 、<code>'b</code> 等。</li>
<li>如果只有一个引用型输入，它的生命周期会赋给所有输出。</li>
<li>如果有多个引用类型的参数，其中一个是<code>self</code>，那么它的生命周期会赋给所有输出。</li>
</ul>
<p>Demo :</p>
<pre><code>//pub fn strtok&lt;'b, 'a&gt;(s: &amp;'b mut &amp;'a str, delimiter: char) -&gt; &amp;'a str 与下面等价
pub fn strtok&lt;'a&gt;(s: &amp;mut &amp;'a str, delimiter: char) -&gt; &amp;'a str {
    if let Some(i) = s.find(delimiter) {
        let prefix = &amp;s[..i];
        // 由于 delimiter 可以是 utf8，所以我们需要获得其 utf8 长度，
        // 直接使用 len 返回的是字节长度，会有问题
        let suffix = &amp;s[(i + delimiter.len_utf8())..];
        *s = suffix;
        prefix
    } else { // 如果没找到，返回整个字符串，把原字符串指针 s 指向空串
        let prefix = *s;
        *s = "";
        prefix
    }
}

fn main() {
    let s = "hello world".to_owned();
    let mut s1 = s.as_str();
    let hello = strtok(&amp;mut s1, ' ');
    println!("hello is: {}, s1: {}, s: {}", hello, s1, s);
}
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-10f7b7400ddbff95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果我们把 <code>strtok()</code> 函数的签名写成这样，会发生什么问题？为什么它会发生这个问题？你可以试着编译一下看看。</p>
<pre><code>pub fn strtok&lt;'a&gt;(s: &amp;'a mut &amp;str, delimiter: char) -&gt; &amp;'a str {...}
</code></pre>
<p>再运行,就会提示<code>s1</code>,同时存在可变和不可变引用。原来是<code>s1</code>的可变引用的周期和返回值绑定了.在<code>hello</code>使用结束前,编译器认为<code>s1</code>的可变引用一直存在.</p>
<pre><code>error[E0502]: cannot borrow `s1` as immutable because it is also borrowed as mutable
   --&gt; src/main.rs:384:52
    |
382 |     let hello = strtok(&amp;mut s1, ' ');
    |                        ------- mutable borrow occurs here
383 |     // hello is: hello, s1: world, s: hello world
384 |     println!("hello is: {}, s1: {}, s: {}", hello, s1, s);
    |     -----------------------------------------------^^----
    |     |                                              |
    |     |                                              immutable borrow occurs here
    |     mutable borrow later used here
    |
    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
</code></pre>
<p><code>Rust</code>的借用规则要求在同一时间内，不能有一个变量的可变和不可变引用同时存在。在这个代码中，<code>strtok</code>函数创建了一个<code>s1</code>的可变引用，并返回了一个这个可变引用生命周期的不可变引用<code>hello</code>。而在<code>println!</code>宏里，尝试同时使用这两个引用：<code>hello</code>（不可变引用）和<code>s1</code>的可变引用。</p>
<p>那么根据这个理解,其实这样标注也可以.只要把打印拆开就行了.</p>
<pre><code>pub fn strtok&lt;'a&gt;(s: &amp;'a mut &amp;str, delimiter: char) -&gt; &amp;'a str {
    if let Some(i) = s.find(delimiter) {
        let prefix = &amp;s[..i];
        // 由于 delimiter 可以是 utf8，所以我们需要获得其 utf8 长度，
        // 直接使用 len 返回的是字节长度，会有问题
        let suffix = &amp;s[(i + delimiter.len_utf8())..];
        *s = suffix;
        prefix
    } else { // 如果没找到，返回整个字符串，把原字符串指针 s 指向空串
        let prefix = *s;
        *s = "";
        prefix
    }
}

fn demo17() {
    let s = "hello world".to_owned();
    let mut s1 = s.as_str();
    let hello = strtok(&amp;mut s1, ' ');
    // hello is: hello, s1: world, s: hello world
    // println!("hello is: {}, s1: {}, s: {}", hello, s1, s);
    println!("hello is: {}, s: {}", hello, s);
    println!("s1: {}", s1);
}
</code></pre>
<p><strong>生命周期标注的目的是，在参数和返回值之间建立联系或者约束</strong>。调用函数时，传入的参数的生命周期需要大于等于（<code>outlive</code>）标注的生命周期。</p>
<p><strong>2.2.2、Struct的生命周期</strong></p>
<pre><code>struct Employee&lt;'a, 'b&gt; {
  name: &amp;'a str,
  title: &amp;'b str,
  age: u8,
}
</code></pre>
<p>使用数据结构时，数据结构自身的生命周期，<strong>需要小于等于其内部字段的所有引用</strong>的生命周期。</p>
<h1 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h1><p><img src="https://upload-images.jianshu.io/upload_images/12321605-9fc3089b9bcae9bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mem.png"></p>
<!--[点我查看原图](./mem.png)-->
<p><a target="_blank" rel="noopener" href="https://eq2dxlycqpe.feishu.cn/mindnotes/F5tObHO5amcC9JnB0cIchsBInuf#mindmap">脑图链接</a></p>
<p><strong>内存管理是任何编程语言的核心</strong></p>
<p>整个堆内存生命周期管理的发展史如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-92c1b872d5b81702.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>而<code>Rust</code>的创造者们，重新审视了堆内存的生命周期，<strong>发现大部分堆内存的需求在于动态大小，小部分需求是更长的生命周期</strong>。所以它默认将堆内存的生命周期和使用它的栈内存的生命周期绑在一起，并留了个小口子<code>leaked</code>机制，让堆内存在需要的时候，可以有超出帧存活期的生命周期。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-a12898a16fc47442.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="3-1、值的创建"><a href="#3-1、值的创建" class="headerlink" title="3.1、值的创建"></a>3.1、值的创建</h2><p>当我们为数据结构创建一个值，并将其赋给一个变量时，根据值的性质，它有可能被创建在栈上，也有可能被创建在堆上。</p>
<p>如果数据结构的大小无法确定，或者它的大小确定但是在使用时需要更长的生命周期，就最好放在堆上。</p>
<p><strong>3.1.1 Struct 内存布局</strong></p>
<p>内存对齐规则：</p>
<ul>
<li>首先确定每个域的长度和对齐长度，原始类型的对齐长度和类型的长度一致。</li>
<li>每个域的起始位置要和其对齐长度对齐，如果无法对齐，则添加<code>padding</code>直至对齐。</li>
<li>结构体的对齐大小和其最大域的对齐大小相同，而结构体的长度则四舍五入到其对齐的倍数。</li>
</ul>
<p>而<code>Rust</code>编译器替我们自动完成了这个优化，这就是为什么<code>Rust</code>会<strong>自动重排你定义的结构体</strong>，来达到最高效率。我们看同样的代码，在<code>Rust</code>下，<code>S1</code>和<code>S2</code>大小都是<code>4</code></p>
<pre><code>use std::mem::{align_of, size_of};

struct S1 {
    a: u8,
    b: u16,
    c: u8,
}

struct S2 {
    a: u8,
    c: u8,
    b: u16,
}

fn main() {
    println!("sizeof S1: {}, S2: {}", size_of::&lt;S1&gt;(), size_of::&lt;S2&gt;());
    println!("alignof S1: {}, S2: {}", align_of::&lt;S1&gt;(), align_of::&lt;S2&gt;());
}
</code></pre>
<p><code>Rust</code> 编译器默认为开发者优化结构体的排列，但你也可以使用<code>#[repr]</code>宏，强制让<code>Rust</code>编译器不做优化，和<code>C</code>的行为一致，这样，<code>Rust</code>代码可以方便地和<code>C</code>代码无缝交互。</p>
<p><strong>3.1.2 enum 内存布局</strong></p>
<p><code>enum</code>是一个标签联合体（<code>tagged union</code>），它的大小是标签的大小，加上最大类型的长度。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-6f344120d120e9b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<pre><code>use std::collections::HashMap;
use std::mem::size_of;

enum E {
    A(f64),
    B(HashMap&lt;String, String&gt;),
    C(Result&lt;Vec&lt;u8&gt;, String&gt;),
}

// 这是一个声明宏，它会打印各种数据结构本身的大小，在 Option 中的大小，以及在 Result 中的大小
// 对于 Option 结构而言，它的 tag 只有两种情况：0 或 1，
//  tag 为 0 时，表示 None，tag 为 1 时，表示 Some。
macro_rules! show_size {
    (header) =&gt; {
        println!(
            "{:&lt;24} {:&gt;4}    {}    {}",
            "Type", "T", "Option&lt;T&gt;", "Result&lt;T, io::Error&gt;"
        );
        println!("{}", "-".repeat(64));
    };
    ($t:ty) =&gt; {
        println!(
            "{:&lt;24} {:4} {:8} {:12}",
            stringify!($t),
            size_of::&lt;$t&gt;(),
            size_of::&lt;Option&lt;$t&gt;&gt;(),
            size_of::&lt;Result&lt;$t, std::io::Error&gt;&gt;(),
        )
    };
}

fn main() {
    show_size!(header);
    show_size!(u8);
    show_size!(f64);
    show_size!(&amp;u8);
    show_size!(Box&lt;u8&gt;);
    show_size!(&amp;[u8]);

    show_size!(String);
    show_size!(Vec&lt;u8&gt;);
    show_size!(HashMap&lt;String, String&gt;);
    show_size!(E);
}
</code></pre>
<p><strong>3.1.3 vec<t> 和 String</t></strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-307d28e9f7f9214e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>很多动态大小的数据结构，在创建时都有类似的内存布局：<strong>栈内存放的胖指针，指向堆内存分配出来的数据</strong>，我们之前介绍的<code>Rc</code>也是如此。</p>
<h2 id="3-2、值的使用"><a href="#3-2、值的使用" class="headerlink" title="3.2、值的使用"></a>3.2、值的使用</h2><p>其实<code>Copy</code>和<code>Move</code>在内部实现上，都是浅层的按位做内存复制，只不过<code>Copy</code>允许你访问之前的变量，而<code>Move</code>不允许。所以 <code>Move = Copy + Delete</code> （在栈上）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-4ca53034af37ca91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>但是，如果你要复制的只是<strong>原生类型</strong>（<code>Copy</code>）或者<strong>栈上的胖指针</strong>（<code>Move</code>），不涉及堆内存的复制也就是深拷贝（<code>deep copy</code>），那这个效率是非常高的，我们不必担心每次赋值或者每次传参带来的性能损失。</p>
<p>不过也有一个例外，要说明：对栈上的大数组传参，由于需要复制整个数组，会影响效率。所以，一般我们<strong>建议在栈上不要放大数组</strong>，如果实在需要，那么传递这个数组时，最好用传引用而不是传值。</p>
<p>以一个 <code>Vec&lt;T&gt;</code> 为例，当你使用完堆内存目前的容量后，还继续添加新的内容，就会触发堆内存的自动增长。有时候，集合类型里的数据不断进进出出，导致集合一直增长，但只使用了很小部分的容量，内存的使用效率很低，所以你要考虑使用，比如<code>shrink_to_fit</code>方法，来节约对内存的使用。</p>
<h2 id="3-3、值的销毁"><a href="#3-3、值的销毁" class="headerlink" title="3.3、值的销毁"></a>3.3、值的销毁</h2><p>这里用到了 <code>Drop trait</code>。<code>Drop trait</code>类似面向对象编程中的析构函数，当一个值要被释放，它的<code>Drop trait</code>会被调用。比如下面的代码，变量<code>greeting</code>是一个字符串，在退出作用域时，其<code>drop()</code>函数被自动调用，释放堆上包含 <code>hello world</code>的内存，然后再释放栈上的内存：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-538ee3a64f1ea1c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>3.3.1 堆内存释放</strong></p>
<p>所有权机制规定了，一个值只能有一个所有者，所以在释放堆内存的时候，整个过程简单清晰，就是单纯调用<code>Drop trait</code>，不需要有其他顾虑。<strong>这种对值安全，也没有额外负担的释放能力，是 Rust 独有的</strong>。</p>
<p>我觉得<code>Rust</code>在内存管理方面的设计特别像蚁群。在蚁群中，每个个体的行为都遵循着非常简单死板的规范，最终大量简单的个体能构造出一个高效且不出错的系统。</p>
<p>反观其它语言，每个个体或者说值，都非常灵活，<strong>引用传来传去，最终却构造出来一个很难分析的复杂系统</strong>。单靠编译器无法决定，每个值在各个作用域中究竟能不能安全地释放，导致系统，要么像<code>C/C++</code>一样将这个重担部分或者全部地交给开发者，要么像<code>Java</code>那样构建另一个系统来专门应对内存安全释放的问题。</p>
<p><strong>3.3.2 释放其他资源</strong></p>
<p><code>Rust</code>的<code>Drop trait</code>主要是为了应对堆内存释放的问题，其实它还可以释放任何资源，比如 <code>socket</code>、文件、锁等等。<code>Rust</code>对所有的资源都有很好的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII 支持</a>。</p>
<p>比如我们创建一个文件<code>file</code>，往里面写入 <code>hello world</code>，当<code>file</code>离开作用域时，不但它的内存会被释放，它占用的资源、操作系统打开的文件描述符，也会被释放，也就是文件会自动被关闭。（代码）</p>
<pre><code>use std::fs::File;
use std::io::prelude::*;
fn main() -&gt; std::io::Result&lt;()&gt; {
    let mut file = File::create("foo.txt")?;
    file.write_all(b"hello world")?;
    Ok(())
}
</code></pre>
<p>在其他语言中，无论 <code>Java</code>、<code>Python</code> 还是<code>Golang</code>，你都需要显式地关闭文件，避免资源的泄露。这是因为，即便 <code>GC</code>能够帮助开发者最终释放不再引用的内存，它并不能释放除内存外的其它资源。</p>
<h1 id="四、类型系统"><a href="#四、类型系统" class="headerlink" title="四、类型系统"></a>四、类型系统</h1><p><img src="https://upload-images.jianshu.io/upload_images/12321605-dff6c512cc4cb8f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="types.png"></p>
<!--[点我查看原图](./types.png)-->

<p><a target="_blank" rel="noopener" href="https://eq2dxlycqpe.feishu.cn/mindnotes/Q7mAbo5MCmaO2FnIFYsc04zRnmY#mindmap">脑图链接</a></p>
<h2 id="4-1、类型系统基本概念与分类"><a href="#4-1、类型系统基本概念与分类" class="headerlink" title="4.1、类型系统基本概念与分类"></a>4.1、类型系统基本概念与分类</h2><p><strong>类型系统完全是一种工具</strong>，编译器在编译时对数据做静态检查，或者语言在运行时对数据做动态检查的时候，来保证某个操作处理的数据是开发者期望的数据类型。</p>
<p><strong>类型系统其实就是，对类型进行定义、检查和处理的系统</strong>。所以，按对类型的操作阶段不同，就有了不同的划分标准，也对应有不同分类。</p>
<p><strong>按定义后类型是否可以隐式转换，可以分为强类型和弱类型</strong>。<code>Rust</code>不同类型间不能自动转换，所以是强类型语言，而 <code>C/C++/JavaScript</code>会自动转换，是弱类型语言。</p>
<p><strong>按类型检查的时机，在编译时检查还是运行时检查，可以分为静态类型系统和动态类型系统</strong>。对于静态类型系统，还可以进一步分为显式静态和隐式静态，<code>Rust/Java/Swift</code> 等语言都是显式静态语言，而<code>Haskell</code>是隐式静态语言。</p>
<p>在类型系统中，多态是一个非常重要的思想，它是指在使用相同的接口时，不同类型的对象，会采用不同的实现。</p>
<p>对于动态类型系统，多态通过鸭子类型（<code>duck typing</code>）实现；而对于静态类型系统，多态可以通过参数多态（<code>parametric polymorphism</code>）、特设多态（<code>adhoc polymorphism</code>）和子类型多态（<code>subtype polymorphism</code>）实现。</p>
<ul>
<li>参数多态是指，代码操作的类型是一个满足某些约束的参数，而非具体的类型。</li>
<li>特设多态是指同一种行为有多个不同实现的多态。比如加法，可以<code>1+1</code>，也可以是 <code>abc+cde</code>、<code>matrix1+matrix2</code>、甚至<code>matrix1 + vector1</code>。在面向对象编程语言中，特设多态一般指函数的重载。</li>
<li>子类型多态是指，在运行时，子类型可以被当成父类型使用。</li>
</ul>
<p>在<code>Rust</code>中，参数多态通过泛型来支持、特设多态通过<code>trait</code>来支持、子类型多态可以用<code>trait object</code>来支持。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-a9da2760fb465909.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="4-2、Rust-类型系统"><a href="#4-2、Rust-类型系统" class="headerlink" title="4.2、Rust 类型系统"></a>4.2、Rust 类型系统</h2><p>按刚才不同阶段的分类，在定义时， <code>Rust</code>不允许类型的隐式转换，也就是说，<code>Rust</code>是强类型语言；同时在检查时，<code>Rust</code>使用了静态类型系统，在编译期保证类型的正确。强类型加静态类型，使得<code>Rust</code>是一门类型安全的语言。</p>
<p>从内存的角度看，类型安全是指代码，<strong>只能按照被允许的方法，访问它被授权访问的内存</strong>。</p>
<p>到这里简单总结一下，我们了解到<code>Rust</code>是强类型、静态类型语言，并且在代码中，类型无处不在。</p>
<p><strong>4.2.1 数据类型</strong></p>
<p><code>Rust</code>的原生类型包括字符、整数、浮点数、布尔值、数组（<code>array</code>）、元组（<code>tuple</code>）、切片（<code>slice</code>）、指针、引用、函数等，见下表：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-d27eb533e70cc87b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>在原生类型的基础上，<code>Rust</code>标准库还支持非常丰富的组合类型，看看已经遇到的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-6f33b71d56a41d3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-20eb0a391faddd36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>4.2.2 类型推导</strong></p>
<p><code>Rust</code>编译器需要足够的上下文来进行类型推导，所以有些情况下，编译器无法推导出合适的类型，比如下面的代码尝试把一个列表中的偶数过滤出来，生成一个新的列表：</p>
<pre><code>fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let even_numbers = numbers // let even_numbers: Vec&lt;_&gt; = numbers
        .into_iter()
        .filter(|n| n % 2 == 0)
        .collect(); // .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("{:?}", even_numbers);
}
</code></pre>
<p><code>collect</code>是<code>Iterator trait</code>的方法，它把一个<code>iterator</code>转换成一个集合。因为很多集合类型，如 <code>Vec&lt;T&gt;</code>、<code>HashMap&lt;K, V&gt;</code>等都实现了<code>Iterator</code>，所以这里的<code>collect</code>究竟要返回什么类型，编译器是无法从上下文中推断的。</p>
<p>在泛型函数后使用  ::<t> 来强制使用类型 T，这种写法被称为 turbofish。我们再看一个对 IP 地址和端口转换的例子 ：</t></p>
<pre><code>use std::net::SocketAddr;

fn main() {
    let addr = "127.0.0.1:8080".parse::&lt;SocketAddr&gt;().unwrap();
    println!("addr: {:?}, port: {:?}", addr.ip(), addr.port());
}
</code></pre>
<p>有些情况下，即使上下文中含有类型的信息，也需要开发者为变量提供类型，比如常量和静态变量的定义。看一个例子（代码）：</p>
<pre><code>const PI: f64 = 3.1415926;
static E: f32 = 2.71828;

fn main() {
    const V: u32 = 10;
    static V1: &amp;str = "hello";
    println!("PI: {}, E: {}, V {}, V1: {}", PI, E, V, V1);
}
</code></pre>
<h2 id="4-3、泛型"><a href="#4-3、泛型" class="headerlink" title="4.3、泛型"></a>4.3、泛型</h2><p><strong>4.3.1 泛型数据结构</strong></p>
<p>我们从一个最简单的泛型例子 <code>Option</code> 开始回顾：</p>
<pre><code>enum Option&lt;T&gt; {
  Some(T),
  None,
}
</code></pre>
<p>函数和泛型：</p>
<ul>
<li>函数，是把重复代码中的参数抽取出来，使其更加通用，调用函数的时候，根据参数的不同，我们得到不同的结果；</li>
<li>而泛型，是把重复数据结构中的参数抽取出来，在使用泛型类型时，根据不同的参数，我们会得到不同的具体类型。</li>
</ul>
<p>再来看一个复杂一点的泛型结构 Vec 的例子，验证一下这个想法：</p>
<pre><code>pub struct Vec&lt;T, A: Allocator = Global&gt; {
    buf: RawVec&lt;T, A&gt;,
    len: usize,
}

pub struct RawVec&lt;T, A: Allocator = Global&gt; {
    ptr: Unique&lt;T&gt;,
    cap: usize,
    alloc: A,
}
</code></pre>
<p><code>Vec</code>有两个参数，一个是 <code>T</code>，是列表里的每个数据的类型，另一个是 <code>A</code>，它有进一步的限制  <code>A: Allocator</code> ，也就是说<code>A</code>需要满足 <code>Allocator trait</code>。</p>
<p><code>A</code>这个参数有默认值 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/alloc/struct.Global.html">Global</a>，<a target="_blank" rel="noopener" href="https://github.com/gnzlbg/jemallocator">它是 Rust 默认的全局分配器 - jemallocator</a>，这也是为什么<code>Vec&lt;T&gt;</code>虽然有两个参数，使用时都只需要用 <code>T</code>。</p>
<p>在讲生命周期标注的时候，我们讲过，数据类型内部如果有借用的数据，需要显式地标注生命周期。其实在 <code>Rust</code> 里，<strong>生命周期标注也是泛型的一部分</strong>，一个生命周期<code>'a</code>代表任意的生命周期，和<code>T</code>代表任意类型是一样的。</p>
<p>来看一个枚举类型<code>Cow</code>的例子：</p>
<pre><code>pub enum Cow&lt;'a, B: ?Sized + 'a&gt; where B: ToOwned,
{
    // 借用的数据
    Borrowed(&amp;'a B),
    // 拥有的数据
    Owned(&lt;B as ToOwned&gt;::Owned),
}
</code></pre>
<p><code>Cow（Clone-on-Write）</code>是<code>Rust</code>中一个很有意思且很重要的数据结构。它就像<code>Option</code>一样，在返回数据的时候，提供了一种可能：<strong>要么返回一个借用的数据（只读），要么返回一个拥有所有权的数据（可写）</strong>。</p>
<p>对于拥有所有权的数据<code>B</code> ，第一个是生命周期约束。这里<code>B</code>的生命周期是<code>'a</code>，所以<code>B</code>需要满足<code>'a</code>，这里和泛型约束一样，也是用 <code>B: 'a</code>来表示。当<code>Cow</code>内部的类型<code>B</code>生命周期为<code>'a</code> 时，<code>Cow</code>自己的生命周期也是<code>'a</code>。</p>
<p><code>B</code>还有两个约束：<code>?Sized</code> 和 <code>where B: ToOwned</code>。</p>
<p><code>?Sized</code>是一种特殊的约束写法，<code>?</code>代表可以放松问号之后的约束。由于<code>Rust</code>默认的泛型参数都需要是<code>Sized</code>，也就是固定大小的类型，所以这里<code>?Sized</code>代表用可变大小的类型。</p>
<p><code>ToOwned</code>是一个<code>trait</code>，它可以把借用的数据克隆出一个拥有所有权的数据。</p>
<p>所以这里对<code>B</code>的三个约束分别是：</p>
<ul>
<li>生命周期<code>'a</code></li>
<li>长度可变<code>?Sized</code></li>
<li>符合<code>ToOwned trait</code></li>
</ul>
<p>最后我解释一下<code>Cow</code>这个<code>enum</code>里  <code>&lt;B as ToOwned&gt;::Owned</code> 的含义：它对<code>B</code>做了一个强制类型转换，转成 <code>ToOwned trait</code>，然后访问 <code>ToOwned trait</code> 内部的 <code>Owned</code> 类型。</p>
<p>因为在<code>Rust</code>里，子类型可以强制转换成父类型，<code>B</code>可以用<code>ToOwned</code>约束，所以它是<code>ToOwned trait</code>的子类型，因而<code>B</code>可以安全地强制转换成<code>ToOwned</code>。这里<code>B as ToOwned</code>是成立的。</p>
<p>Demo：</p>
<pre><code>use std::borrow::Cow;

use url::Url;
fn main() {
    let url = Url::parse("https://tyr.com/rust?page=1024&amp;sort=desc&amp;extra=hello%20world").unwrap();
    let mut pairs = url.query_pairs();

    assert_eq!(pairs.count(), 3);

    let (mut k, v) = pairs.next().unwrap();
    // 因为 k, v 都是 Cow&lt;str&gt; 他们用起来感觉和 &amp;str 或者 String 一样
    // 此刻，他们都是 Borrowed
    println!("key: {}, v: {}", k, v);
    // 当修改发生时，k 变成 Owned
    k.to_mut().push_str("_lala");

    print_pairs((k, v));

    print_pairs(pairs.next().unwrap());
    // 在处理 extra=hello%20world 时，value 被处理成 "hello world"
    // 所以这里 value 是 Owned
    print_pairs(pairs.next().unwrap());
}

fn print_pairs(pair: (Cow&lt;str&gt;, Cow&lt;str&gt;)) {
    println!("key: {}, value: {}", show_cow(pair.0), show_cow(pair.1));
}

fn show_cow(cow: Cow&lt;str&gt;) -&gt; String {
    match cow {
        Cow::Borrowed(v) =&gt; format!("Borrowed {}", v),
        Cow::Owned(v) =&gt; format!("Owned {}", v),
    }
}
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-1aeb8f237a9963cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>按类型定义、检查以及检查时能否被推导出来，<strong>Rust 是强类型 + 静态类型 + 显式类型</strong>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-bf98d770cefcfb1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="五、trait"><a href="#五、trait" class="headerlink" title="五、trait"></a>五、trait</h1><p><img src="https://upload-images.jianshu.io/upload_images/12321605-b8a674a4ca071b1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="trait.png"></p>
<!--[点我查看原图](./trait.png)-->

<p><a target="_blank" rel="noopener" href="https://eq2dxlycqpe.feishu.cn/mindnotes/Q3TIbjIJYmFHOYnH2C3ctdm6nno#mindmap">脑图链接</a></p>
<h2 id="5-1、什么是trait"><a href="#5-1、什么是trait" class="headerlink" title="5.1、什么是trait"></a>5.1、什么是trait</h2><p><code>trait</code>是<code>Rust</code>中的接口，它定义了类型使用这个接口的行为。你可以类比到自己熟悉的语言中理解，<code>trait</code>对于 <code>Rust</code>而言，相当于<code>interface</code>之于<code>Java</code>、<code>protocol</code>之于<code>Swift</code>、<code>type class</code>之于<code>Haskell</code>。</p>
<p>在开发复杂系统的时候，<strong>我们常常会强调接口和实现要分离</strong>。因为这是一种良好的设计习惯，它把调用者和实现者隔离开，双方只要按照接口开发，彼此就可以不受对方内部改动的影响。</p>
<p><strong>5.1.1 基本 trait</strong></p>
<p>以标准库中 <code>std::io::Write</code> 为例</p>
<pre><code>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
    fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; Result&lt;usize&gt; { ... }
    fn is_write_vectored(&amp;self) -&gt; bool { ... }
    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt; { ... }
    fn write_all_vectored(&amp;mut self, bufs: &amp;mut [IoSlice&lt;'_&gt;]) -&gt; Result&lt;()&gt; { ... }
    fn write_fmt(&amp;mut self, fmt: Arguments&lt;'_&gt;) -&gt; Result&lt;()&gt; { ... }
    fn by_ref(&amp;mut self) -&gt; &amp;mut Self where Self: Sized { ... }
}
</code></pre>
<p>这些方法也被称作关联函数（<code>associate function</code>）。在<code>trait</code>中，<strong>方法可以有缺省的实现</strong>，对于这个<code>Write trait</code>，你只需要实现<code>write</code>和<code>flush</code>两个方法，其他都有缺省实现。</p>
<p>在刚才定义方法的时候，我们频繁看到两个特殊的关键字：<code>Self</code>和<code>self</code>。</p>
<ul>
<li><code>Self</code>代表当前的类型，比如<code>File</code>类型实现了<code>Write</code>，那么实现过程中使用到的<code>Self</code>就指代<code>File</code>。</li>
<li><code>self</code>在用作方法的第一个参数时，实际上是<code>self:Self</code>的简写，所以<code>&amp;self</code>是<code>self:&amp;Self</code>, 而<code>&amp;mut self</code> 是<code>self: &amp;mut Self</code>。</li>
</ul>
<p><strong>5.1.2 基本 trait 练习</strong></p>
<pre><code>use std::str::FromStr;

use regex::Regex;
pub trait Parse {
    fn parse(s: &amp;str) -&gt; Self;
}

// 我们约束 T 必须同时实现了 FromStr 和 Default
// 这样在使用的时候我们就可以用这两个 trait 的方法了
impl&lt;T&gt; Parse for T
where
    T: FromStr + Default,
{
    fn parse(s: &amp;str) -&gt; Self {
        let re: Regex = Regex::new(r"^[0-9]+(\.[0-9]+)?").unwrap();
        // 生成一个创建缺省值的闭包，这里主要是为了简化后续代码
        // Default::default() 返回的类型根据上下文能推导出来，是 Self
        // 而我们约定了 Self，也就是 T 需要实现 Default trait
        let d = || Default::default();
        if let Some(captures) = re.captures(s) {
            captures
                .get(0)
                .map_or(d(), |s| s.as_str().parse().unwrap_or(d()))
        } else {
            d()
        }
    }
}

#[test]
fn parse_should_work() {
    assert_eq!(u32::parse("123abcd"), 123);
    assert_eq!(u32::parse("123.45abcd"), 0);
    assert_eq!(f64::parse("123.45abcd"), 123.45);
    assert_eq!(f64::parse("abcd"), 0f64);
}

fn main() {
    println!("result: {}", u8::parse("255 hello world"));
}
</code></pre>
<p>通过对带有约束的泛型参数实现 <code>trait</code>，一份代码就实现了<code>u32 / f64</code>等类型的<code>Parse trait</code>，非常精简。不过，看这段代码你有没有感觉还是有些问题？当无法正确解析字符串时，我们返回了缺省值，难道不是应该返回一个错误么？</p>
<p>是的。这里返回缺省值的话，会跟解析<code>0abcd</code>这样的情况混淆，不知道解析出的<code>0</code>，究竟是出错了，还是本该解析出<code>0</code>。</p>
<h2 id="5-2、带关联类型的-trait"><a href="#5-2、带关联类型的-trait" class="headerlink" title="5.2、带关联类型的 trait"></a>5.2、带关联类型的 trait</h2><p><code>Rust</code>允许 <code>trait</code>内部包含关联类型，实现时跟关联函数一样，它也需要实现关联类型。我们看怎么为<code>Parse trait</code> 添加关联类型：</p>
<pre><code>pub trait Parse {
    type Error;
    fn parse(s: &amp;str) -&gt; Result&lt;Self, Self::Error&gt;;
}
</code></pre>
<p>有了关联类型<code>Error</code>，<code>Parse trait</code> 就可以在出错时返回合理的错误了，看修改后的代码：</p>
<pre><code>use std::str::FromStr;

use regex::Regex;
pub trait Parse {
    type Error;
    fn parse(s: &amp;str) -&gt; Result&lt;Self, Self::Error&gt;
    where
        Self: Sized;
}

impl&lt;T&gt; Parse for T
where
    T: FromStr + Default,
{
    // 定义关联类型 Error 为 String
    type Error = String;
    fn parse(s: &amp;str) -&gt; Result&lt;Self, Self::Error&gt; {
        let re: Regex = Regex::new(r"^[0-9]+(\.[0-9]+)?").unwrap();
        if let Some(captures) = re.captures(s) {
            // 当出错时我们返回 Err(String)
            captures
                .get(0)
                .map_or(Err("failed to capture".to_string()), |s| {
                    s.as_str()
                        .parse()
                        .map_err(|_err| "failed to parse captured string".to_string())
                })
        } else {
            Err("failed to parse string".to_string())
        }
    }
}

#[test]
fn parse_should_work() {
    assert_eq!(u32::parse("123abcd"), Ok(123));
    assert_eq!(
        u32::parse("123.45abcd"),
        Err("failed to parse captured string".into())
    );
    assert_eq!(f64::parse("123.45abcd"), Ok(123.45));
    assert!(f64::parse("abcd").is_err());
}

fn main() {
    println!("result: {:?}", u8::parse("255 hello world"));
}
</code></pre>
<p>上面的代码中，我们允许用户把错误类型延迟到<code>trait</code>实现时才决定，这种带有关联类型的<code>trait</code>比普通<code>trait</code>，更加灵活，抽象度更高。</p>
<h2 id="5-3、支持泛型的-trait"><a href="#5-3、支持泛型的-trait" class="headerlink" title="5.3、支持泛型的 trait"></a>5.3、支持泛型的 trait</h2><p>来看看标准库里的操作符是如何重载的，以<code>std::ops::Add</code>这个用于提供加法运算的<code>trait</code>为例：</p>
<pre><code>pub trait Add&lt;Rhs = Self&gt; {
    type Output;
    #[must_use]
    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
</code></pre>
<p>这个<code>trait</code>有一个泛型参数<code>Rhs</code>，代表加号右边的值，它被用在<code>add</code>方法的第二个参数位。这里<code>Rhs</code>默认是 <code>Self</code>，也就是说你用<code>Add trait</code>，如果不提供泛型参数，那么加号右值和左值都要是相同的类型。</p>
<p>我们来定义一个复数类型，尝试使用下这个<code>trait</code>：</p>
<pre><code>use std::ops::Add;

#[derive(Debug)]
struct Complex {
    real: f64,
    imagine: f64,
}

impl Complex {
    pub fn new(real: f64, imagine: f64) -&gt; Self {
        Self { real, imagine }
    }
}

// 对 Complex 类型的实现
impl Add for Complex {
    type Output = Self;

    // 注意 add 第一个参数是 self，会移动所有权
    fn add(self, rhs: Self) -&gt; Self::Output {
        let real = self.real + rhs.real;
        let imagine = self.imagine + rhs.imagine;
        Self::new(real, imagine)
    }
}

// 如果不想移动所有权，可以为 &amp;Complex 实现 add，这样可以做 &amp;c1 + &amp;c2
impl Add for &amp;Complex {
    // 注意返回值不应该是 Self 了，因为此时 Self 是 &amp;Complex
    type Output = Complex;

    fn add(self, rhs: Self) -&gt; Self::Output {
        let real = self.real + rhs.real;
        let imagine = self.imagine + rhs.imagine;
        Complex::new(real, imagine)
    }
}

// 因为 Add&lt;Rhs = Self&gt; 是个泛型 trait，我们可以为 Complex 实现 Add&lt;f64&gt;
impl Add&lt;f64&gt; for &amp;Complex {
    type Output = Complex;

    // rhs 现在是 f64 了
    fn add(self, rhs: f64) -&gt; Self::Output {
        let real = self.real + rhs;
        Complex::new(real, self.imagine)
    }
}

fn main() {
    let c1 = Complex::new(1.0, 1f64);
    let c2 = Complex::new(2 as f64, 3.0);
    println!("{:?}", &amp;c1 + &amp;c2);
    println!("{:?}", &amp;c1 + 5.0);
    println!("{:?}", c1 + c2);
}
</code></pre>
<p>通过使用<code>Add</code>，为<code>Complex</code>实现了和<code>f64</code>相加的方法。所以泛型<code>trait</code>可以让我们在需要的时候，对同一种类型的同一个<code>trait</code>，有多个实现。</p>
<h2 id="5-4、trait-的“继承”"><a href="#5-4、trait-的“继承”" class="headerlink" title="5.4、trait 的“继承”"></a>5.4、trait 的“继承”</h2><p>在<code>Rust</code>中，一个<code>trait</code>可以<code>继承</code>另一个<code>trait</code>的关联类型和关联函数。比如 <code>trait B: A</code> ，是说任何类型 <code>T</code>，如果实现了<code>trait B</code>，它也必须实现<code>trait A</code>，换句话说，<strong>trait B 在定义时可以使用 trait A 中的关联类型和方法</strong>。</p>
<p>以<code>StreamExt</code>为例，由于<code>StreamExt</code>中的方法都有缺省的实现，且所有实现了<code>Stream trait</code>的类型都实现了 <code>StreamExt</code>：</p>
<pre><code>impl&lt;T: ?Sized&gt; StreamExt for T where T: Stream {}
</code></pre>
<p>所以如果你实现了<code>Stream trait</code>，就可以直接使用<code>StreamExt</code>里的方法了，非常方便。</p>
<p>好，到这里<code>trait</code>就基本讲完了，简单总结一下，<code>trait</code>作为对不同数据结构中相同行为的一种抽象。除了基本<code>trait</code> 之外，</p>
<ul>
<li>当行为和具体的数据关联时，比如字符串解析时定义的<code>Parse trait</code>，我们引入了带有关联类型的<code>trait</code>，把和行为有关的数据类型的定义，进一步延迟到<code>trait</code>实现的时候。</li>
<li>对于同一个类型的同一个<code>trait</code>行为，可以有不同的实现，比如我们之前大量使用的<code>From</code>，此时可以用泛型<code>trait</code>。</li>
</ul>
<h2 id="5-5、子类型多态"><a href="#5-5、子类型多态" class="headerlink" title="5.5、子类型多态"></a>5.5、子类型多态</h2><p>从严格意义上说，子类型多态是面向对象语言的专利。<strong>如果一个对象 A 是对象 B 的子类，那么 A 的实例可以出现在任何期望 B 的实例的上下文中</strong>，比如猫和狗都是动物，如果一个函数的接口要求传入一个动物，那么传入猫和狗都是允许的。</p>
<pre><code>pub trait Formatter {
    fn format(&amp;self, input: &amp;mut String) -&gt; bool;
}



struct MarkdownFormatter;
impl Formatter for MarkdownFormatter {
    fn format(&amp;self, input: &amp;mut String) -&gt; bool {
        input.push_str("\nformatted with Markdown formatter");
        true
    }
}

struct RustFormatter;
impl Formatter for RustFormatter {
    fn format(&amp;self, input: &amp;mut String) -&gt; bool {
        input.push_str("\nformatted with Rust formatter");
        true
    }
}

struct HtmlFormatter;
impl Formatter for HtmlFormatter {
    fn format(&amp;self, input: &amp;mut String) -&gt; bool {
        input.push_str("\nformatted with HTML formatter");
        true
    }
}

pub fn format(input: &amp;mut String, formatters: Vec&lt;&amp;dyn Formatter&gt;) {
    for formatter in formatters {
        formatter.format(input);
    }
}


fn main() {
    let mut text = "Hello world!".to_string();
    let html: &amp;dyn Formatter = &amp;HtmlFormatter;
    let rust: &amp;dyn Formatter = &amp;RustFormatter;
    let formatters = vec![html, rust];
    format(&amp;mut text, formatters);

    println!("text: {}", text);
}
</code></pre>
<p>所以我们要有一种手段，告诉编译器，此处需要并且仅需要任何实现了<code>Formatter</code>接口的数据类型。在<code>Rust</code>里，这种类型叫 <code>Trait Object</code>，表现为<code>&amp;dyn Trait</code>或者<code>Box&lt;dyn Trait&gt;</code>。</p>
<p>这样可以在运行时，构造一个 <code>Formatter</code> 的列表，传递给 <code>format</code> 函数进行文件的格式化，这就是<code>动态分派</code>（<code>dynamic dispatching</code>）。</p>
<h2 id="5-6、Trait-Object-的实现机理"><a href="#5-6、Trait-Object-的实现机理" class="headerlink" title="5.6、Trait Object 的实现机理"></a>5.6、Trait Object 的实现机理</h2><p>当需要使用<code>Formatter trait</code>做动态分派时，可以像如下例子一样，将一个具体类型的引用，赋给 <code>&amp;Formatter</code> ：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-fa73d9a958b76a3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>HtmlFormatter</code>的引用赋值给<code>Formatter</code>后，会生成一个<code>Trait Object</code>，在上图中可以看到，<strong>Trait Object 的底层逻辑就是胖指针</strong>。其中，一个指针指向数据本身，另一个则指向<strong>虚函数表（vtable）</strong>。</p>
<p><code>vtable</code>是一张静态的表，<code>Rust</code>在编译时会为使用了<code>trait object</code>的类型的<code>trait</code>实现生成一张表，放在可执行文件中（一般在<code>TEXT</code>或<code>RODATA</code>段）。看下图，可以帮助你理解：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-e4370381a0e92012.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>在这张表里，包含具体类型的一些信息，如<code>size</code>、<code>aligment</code>以及一系列函数指针：</p>
<ul>
<li>这个接口支持的所有的方法，比如 <code>format()</code>；</li>
<li>具体类型的<code>drop trait</code>，当<code>Trait object</code>被释放，它用来释放其使用的所有资源。</li>
</ul>
<p>这样，当在运行时执行 <code>formatter.format()</code>时，<code>formatter</code>就可以从<code>vtable</code>里找到对应的函数指针，执行具体的操作。</p>
<p>所以，<code>Rust</code>里的<code>Trait Object</code>没什么神秘的，它不过是我们熟知的<code>C++/Java</code>中<code>vtable</code>的一个变体而已。</p>
<p>这里说句题外话，<code>C++/Java</code>指向<code>vtable</code>的指针，在编译时放在类结构里，而<code>Rust</code>放在<code>Trait object</code>中。这也是为什么<code>Rust</code>很容易对原生类型做动态分派，而<code>C++/Java</code>不行。</p>
<p>事实上，<code>Rust</code>也并不区分原生类型和组合类型，对<code>Rust</code>来说，所有类型的地位都是一致的。</p>
<p><strong>5.6.1 trait object safety</strong></p>
<p>你使用<code>trait object</code>的时候，要注意对象安全（<code>object safety</code>）。只有满足对象安全的<code>trait</code>才能使用 <code>trait object</code>，在官方文档中有详细讨论。</p>
<p>那什么样的<code>trait</code>不是对象安全的呢？</p>
<p><strong>如果 trait 所有的方法，返回值是 Self 或者携带泛型参数，那么这个 trait 就不能产生 trait object。</strong></p>
<p>不允许返回<code>Self</code>，是因为<code>trait object</code>在产生时，原来的类型会被抹去，<strong>所以 Self 究竟是谁不知道</strong>。比如 <code>Clone trait</code>只有一个方法<code>clone()</code>，返回<code>Self</code>，所以它就不能产生 <code>trait object</code>。</p>
<p>不允许携带泛型参数，是因为 <code>Rust</code> 里带泛型的类型在编译时会做单态化，而 <code>trait object</code> 是运行时的产物，两者不能兼容。</p>
<p>比如 <code>From trait</code>，因为整个<code>trait</code>带了泛型，每个方法也自然包含泛型，就不能产生<code>trait object</code>。如果一个 <code>trait</code>只有部分方法返回<code>Self</code>或者使用了泛型参数，那么这部分方法在<code>trait object</code>中不能调用。</p>
<pre><code>//如果 trait 所有的方法，返回值是 Self 或者携带泛型参数，那么这个 trait 就不能产生 trait object。
pub trait UnSafeTrait {
    fn format(&amp;self, input: &amp;mut String) -&gt; Self;
}

struct MarkdownFormatter2;
impl UnSafeTrait for MarkdownFormatter2 {
    fn format(&amp;self, input: &amp;mut String) -&gt; Self {
        input.push_str("\nformatted with Markdown formatter");
        MarkdownFormatter2
    }
}

fn main() {
    let md2: &amp;dyn UnSafeTrait = &amp;MarkdownFormatter2; // 报错 the trait `UnSafeTrait` cannot be made into an object

}
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-f8339d206de09d4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>5.6.2 使用 trait 有两个注意事项：</strong></p>
<ul>
<li>第一，在定义和使用 <code>trait</code> 时，我们需要遵循孤儿规则（<code>Orphan Rule</code>）。<ul>
<li><code>trait</code> 和实现 <code>trait</code> 的数据类型，至少有一个是在当前 <code>crate</code> 中定义的，也就是说，你不能为第三方的类型实现第三方的 <code>trait</code>，当你尝试这么做时，<code>Rust</code> 编译器会报错。</li>
</ul>
</li>
<li>第二，<code>Rust</code>对含有<code>async fn</code>的<code>trait</code>，还没有一个很好的被标准库接受的实现。<a target="_blank" rel="noopener" href="https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/">async-fn-in-traits-are-hard</a><ul>
<li><code>#[async_trait]</code>。这是目前最推荐的无缝使用<code>async trait</code>的方法。未来<code>async trait</code>如果有了标准实现，我们不需要对现有代码做任何改动。</li>
</ul>
</li>
</ul>
<p><strong>5.6.3 vtable 会为每个类型的每个 trait 实现生成一张表</strong></p>
<pre><code>use std::fmt::{Debug, Display};
use std::mem::transmute;

fn main() {
    let s1 = String::from("hello world!");
    let s2 = String::from("goodbye world!");
    // Display / Debug trait object for s
    let w1: &amp;dyn Display = &amp;s1;
    let w2: &amp;dyn Debug = &amp;s1;

    // Display / Debug trait object for s1
    let w3: &amp;dyn Display = &amp;s2;
    let w4: &amp;dyn Debug = &amp;s2;

    // 强行把 triat object 转换成两个地址 (usize, usize)
    // 这是不安全的，所以是 unsafe
    let (addr1, vtable1): (usize, usize) = unsafe { transmute(w1) };
    let (addr2, vtable2): (usize, usize) = unsafe { transmute(w2) };
    let (addr3, vtable3): (usize, usize) = unsafe { transmute(w3) };
    let (addr4, vtable4): (usize, usize) = unsafe { transmute(w4) };

    // s 和 s1 在栈上的地址，以及 main 在 TEXT 段的地址
    println!(
        "s1: {:p}, s2: {:p}, main(): {:p}",
        &amp;s1, &amp;s2, main as *const ()
    );
    // trait object(s / Display) 的 ptr 地址和 vtable 地址
    println!("addr1: 0x{:x}, vtable1: 0x{:x}", addr1, vtable1);
    // trait object(s / Debug) 的 ptr 地址和 vtable 地址
    println!("addr2: 0x{:x}, vtable2: 0x{:x}", addr2, vtable2);

    // trait object(s1 / Display) 的 ptr 地址和 vtable 地址
    println!("addr3: 0x{:x}, vtable3: 0x{:x}", addr3, vtable3);

    // trait object(s1 / Display) 的 ptr 地址和 vtable 地址
    println!("addr4: 0x{:x}, vtable4: 0x{:x}", addr4, vtable4);

    // 指向同一个数据的 trait object 其 ptr 地址相同
    assert_eq!(addr1, addr2);
    assert_eq!(addr3, addr4);

    // 指向同一种类型的同一个 trait 的 vtable 地址相同
    // 这里都是 String + Display
    assert_eq!(vtable1, vtable3);
    // 这里都是 String + Debug
    assert_eq!(vtable2, vtable4);
}
</code></pre>
<h1 id="六、常见的trait"><a href="#六、常见的trait" class="headerlink" title="六、常见的trait"></a>六、常见的trait</h1><p><img src="https://upload-images.jianshu.io/upload_images/12321605-47e2d8e9449cc47a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="common_trait.png"></p>
<!--[点我查看原图](./common_trait.png)-->

<p><a target="_blank" rel="noopener" href="https://eq2dxlycqpe.feishu.cn/mindnotes/CHrobt9YPmFPuCnNmilcsUYBn8b#mindmap">脑图链接</a></p>
<ul>
<li><code>Clone/Copy trait</code>，约定了数据被深拷贝和浅拷贝的行为；</li>
<li><code>Read/Write trait</code>，约定了对<code>I/O</code>读写的行为；<code>Iterator</code>，约定了迭代器的行为；</li>
<li><code>Debug</code>，约定了数据如何被以<code>debug</code>的方式显示出来的行为；</li>
<li><code>Default</code>，约定数据类型的缺省值如何产生的行为；</li>
<li><code>From&lt;T&gt;/TryFrom&lt;T&gt;</code>，约定了数据间如何转换的行为。</li>
</ul>
<h2 id="6-1、Clone-Copy-Drop"><a href="#6-1、Clone-Copy-Drop" class="headerlink" title="6.1、Clone/Copy/Drop"></a>6.1、Clone/Copy/Drop</h2><p><strong>6.1.1 Clone trait</strong></p>
<pre><code>pub trait Clone {
  fn clone(&amp;self) -&gt; Self;

  fn clone_from(&amp;mut self, source: &amp;Self) {
    *self = source.clone()
  }
}
</code></pre>
<p><code>Clone trait</code>有两个方法， <code>clone()</code>和<code>clone_from()</code>，后者有缺省实现，所以平时我们只需要实现<code>clone()</code>方法即可。如果<code>a</code>已经存在，用  <strong>a.clone_from(&amp;b) 可以避免内存分配</strong>，提高效率。</p>
<p><code>Clone trait</code>可以通过派生宏直接实现，这样能简化不少代码。如果在你的数据结构里，每一个字段都已经实现了 <code>Clone trait</code>，你可以用 <code>#[derive(Clone)]</code> ，看下面的代码：</p>
<pre><code>#[derive(Clone, Debug)]
struct Developer {
  name: String,
  age: u8,
  lang: Language
}

#[allow(dead_code)]
#[derive(Clone, Debug)]
enum Language {
  Rust,
  TypeScript,
  Elixir,
  Haskell
}

fn main() {
    let dev = Developer {
        name: "Tyr".to_string(),
        age: 18,
        lang: Language::Rust
    };
    let dev1 = dev.clone();
    println!("dev: {:?}, addr of dev name: {:p}", dev, dev.name.as_str());
    println!("dev1: {:?}, addr of dev1 name: {:p}", dev1, dev1.name.as_str())
}
</code></pre>
<p>如果没有为<code>Language</code>实现<code>Clone</code>的话，<code>Developer</code>的派生宏<code>Clone</code>将会编译出错。运行这段代码可以看到，对于 <code>name</code>，也就是<code>String</code>类型的<code>Clone</code>，其堆上的内存也被<code>Clone</code>了一份，<strong>所以 Clone 是深度拷贝，栈内存和堆内存一起拷贝。</strong></p>
<p><strong>6.1.2 Copy trait</strong></p>
<p>和<code>Clone trait</code>不同的是，<code>Copy trait</code>没有任何额外的方法，它只是一个标记<code>trait（marker trait）</code>。它的 <code>trait</code>定义：</p>
<pre><code>pub trait Copy: Clone {}
</code></pre>
<p>这样的<code>trait</code>虽然没有任何行为，但它可以用作<code>trait bound</code>来进行类型安全检查，<strong>所以我们管它叫标记 trait</strong>。</p>
<p>和<code>Clone</code>一样，如果数据结构的所有字段都实现了<code>Copy</code>，也可以用 <code>#[derive(Copy)]</code>宏来为数据结构实现<code>Copy</code>。</p>
<p>Q: 不可变引用实现了<code>Copy</code>，而可变引用<code>&amp;mut T</code>没有实现<code>Copy</code>。为什么是这样？</p>
<p><strong>因为如果可变引用实现了 Copy trait，那么生成一个可变引用然后把它赋值给另一个变量时，就会违背所有权规则：同一个作用域下只能有一个可变引用</strong>。可见，Rust 标准库在哪些结构可以 Copy、哪些不可以 Copy 上，有着仔细的考量。</p>
<p><strong>6.1.3 Drop trait</strong></p>
<pre><code>pub trait Drop {
    fn drop(&amp;mut self);
}
</code></pre>
<p>大部分场景无需为数据结构提供<code>Drop trait</code>，系统默认会依次对数据结构的每个域做<code>drop</code>。但有两种情况你可能需要手工实现<code>Drop</code>。</p>
<ul>
<li>第一种是希望在数据结束生命周期的时候做一些事情，比如记日志。</li>
<li>第二种是需要对资源回收的场景。编译器并不知道你额外使用了哪些资源，也就无法帮助你<code>drop</code>它们。比如说锁资源的释放，在<code>MutexGuard</code>中实现了<code>Drop</code>来释放锁资源：</li>
</ul>
<p>比如：</p>
<pre><code>impl&lt;T: ?Sized&gt; Drop for MutexGuard&lt;'_, T&gt; {
    #[inline]
    fn drop(&amp;mut self) {
        unsafe {
            self.lock.poison.done(&amp;self.poison);
            self.lock.inner.raw_unlock();
        }
    }
}
</code></pre>
<p>需要注意的是，<code>Copy trait</code> 和 <code>Drop trait</code> 是互斥的，两者不能共存，当你尝试为同一种数据类型实现<code>Copy</code> 时，也实现<code>Drop</code>，编译器就会报错。这其实很好理解：<code>Copy</code>是按位做浅拷贝，那么它会默认拷贝的数据没有需要释放的资源；而<code>Drop</code>恰恰是为了释放额外的资源而生的。</p>
<p>我们还是写一段代码来辅助理解，在代码中，强行用<code>Box::into_raw</code>获得堆内存的指针，放入<code>RawBuffer</code>结构中，这样就接管了这块堆内存的释放。</p>
<p>但是这个操作不会破坏<code>Rust</code>的正确性保证：即便你<code>Copy</code>了<code>N</code>份<code>RawBuffer</code>，由于无法实现<code>Drop trait</code>，<code>RawBuffer</code>指向的那同一块堆内存不会释放，所以不会出现<code>use after free</code>的内存安全问题。</p>
<pre><code>use std::{fmt, slice};

// 注意这里，我们实现了 Copy，这是因为 *mut u8/usize 都支持 Copy
#[derive(Clone, Copy)]
struct RawBuffer {
    // 裸指针用 *const / *mut 来表述，这和引用的 &amp; 不同
    ptr: *mut u8,
    len: usize,
}

impl From&lt;Vec&lt;u8&gt;&gt; for RawBuffer {
    fn from(vec: Vec&lt;u8&gt;) -&gt; Self {
        let slice = vec.into_boxed_slice();
        Self {
            len: slice.len(),
            // into_raw 之后，Box 就不管这块内存的释放了，RawBuffer 需要处理释放
            ptr: Box::into_raw(slice) as *mut u8,
        }
    }
}

// 如果 RawBuffer 实现了 Drop trait，就可以在所有者退出时释放堆内存
// 然后，Drop trait 会跟 Copy trait 冲突，要么不实现 Copy，要么不实现 Drop
// 如果不实现 Drop，那么就会导致内存泄漏，但它不会对正确性有任何破坏
// 比如不会出现 use after free 这样的问题。
// 你可以试着把下面注释去掉，看看会出什么问题
// impl Drop for RawBuffer {
//     #[inline]
//     fn drop(&amp;mut self) {
//         let data = unsafe { Box::from_raw(slice::from_raw_parts_mut(self.ptr, self.len)) };
//         drop(data)
//     }
// }

impl fmt::Debug for RawBuffer {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        let data = self.as_ref();
        write!(f, "{:p}: {:?}", self.ptr, data)
    }
}

impl AsRef&lt;[u8]&gt; for RawBuffer {
    fn as_ref(&amp;self) -&gt; &amp;[u8] {
        unsafe { slice::from_raw_parts(self.ptr, self.len) }
    }
}

fn main() {
    let data = vec![1, 2, 3, 4];

    let buf: RawBuffer = data.into();

    // 因为 buf 允许 Copy，所以这里 Copy 了一份
    use_buffer(buf);

    // buf 还能用
    println!("buf: {:?}", buf);
}

fn use_buffer(buf: RawBuffer) {
    println!("buf to die: {:?}", buf);

    // 这里不用特意 drop，写出来只是为了说明 Copy 出来的 buf 被 Drop 了
    drop(buf)
}
    
</code></pre>
<p>对于代码安全来说，<strong>内存泄漏危害大？还是 use after free 危害大呢？肯定是后者</strong>。<code>Rust</code>的底线是内存安全，所以两害相权取其轻。</p>
<h2 id="6-2、Sized-Send-Sync-Unpin"><a href="#6-2、Sized-Send-Sync-Unpin" class="headerlink" title="6.2、Sized/Send/Sync/Unpin"></a>6.2、Sized/Send/Sync/Unpin</h2><p><strong>6.2.1 Sized</strong></p>
<p><code>Sized trait</code>用于标记有具体大小的类型。在使用泛型参数时，<code>Rust</code>编译器会自动为泛型参数加上<code>Sized</code>约束，比如下面的<code>Data</code>和处理<code>Data</code>的函数<code>process_data</code>：</p>
<pre><code>struct Data&lt;T&gt; {
    inner: T,
}

fn process_data&lt;T&gt;(data: Data&lt;T&gt;) {
    todo!();
}
</code></pre>
<p>它等价于：</p>
<pre><code>struct Data&lt;T: Sized&gt; {
    inner: T,
}

fn process_data&lt;T: Sized&gt;(data: Data&lt;T&gt;) {
    todo!();
}
    
</code></pre>
<p>但是这个自动添加的约束有时候不太适用，在少数情况下，需要<code>T</code>是可变类型的，怎么办？<code>Rust</code> 提供了<code>?Sized</code>来摆脱这个约束。</p>
<pre><code>trait MyDisplay {
    fn display(&amp;self);
}

// 实现 MyDisplay trait 为具有 ?Sized 范围的泛型类型
impl&lt;T: ?Sized&gt; MyDisplay for T
    where
        T: std::fmt::Debug
{
    fn display(&amp;self) {
        println!("{:?}", self);
    }
}

fn main() {
    let text: &amp;str = "Hello, world!";
    let slice = &amp;[1, 2, 3, 4, 5];

    (*text).display(); // 调用处理 ?Sized 的 MyDisplay trait 实现
    (*slice).display(); // 调用处理 ?Sized 的 MyDisplay trait 实现
}
</code></pre>
<p>这样<code>[T]</code>或者<code>str</code>类型也可以使用<code>display</code>方法。</p>
<p><strong>6.2.2 Send/Sync</strong></p>
<pre><code>pub unsafe auto trait Send {}
pub unsafe auto trait Sync {}
</code></pre>
<p>这两个<code>trait</code>都是<code>unsafe auto trait</code>，<code>auto</code>意味着编译器会在合适的场合，自动为数据结构添加它们的实现，而 <code>unsafe</code>代表实现的这个<code>trait</code>可能会违背<code>Rust</code>的内存安全准则，如果开发者手工实现这两个<code>trait</code> ，要自己为它们的安全性负责。</p>
<p><code>Send/Sync</code>是<code>Rust</code>并发安全的基础：</p>
<ul>
<li>如果一个类型<code>T</code>实现了<code>Send trait</code>，意味着<code>T</code>可以安全地从一个线程移动到另一个线程，也就是说所有权可以在线程间移动。</li>
<li>如果一个类型<code>T</code>实现了<code>Sync trait</code>，则意味着<code>&amp;T</code>可以安全地在多个线程中共享。一个类型<code>T</code>满足<code>Sync trait</code>，当且仅当<code>&amp;T</code>满足<code>Send trait</code>。</li>
</ul>
<p>对于<code>Send/Sync</code>在线程安全中的作用，可以这么看，如果一个类型 <code>T:Send</code>，那么<code>T</code>在某个线程中的独占访问是线程安全的；如果一个类型<code>T:Sync</code>，那么<code>T</code>在线程间的只读共享是安全的。</p>
<p>对于我们自己定义的数据结构，如果其内部的所有域都实现了<code>Send/Sync</code>，那么这个数据结构会被自动添加<code>Send/Sync</code> 。基本上原生数据结构都支持<code>Send/Sync</code>，也就是说，绝大多数自定义的数据结构都是满足<code>Send/Sync</code>的。标准库中，不支持<code>Send/Sync</code>的数据结构主要有：</p>
<ul>
<li>裸指针<code>*const T/*mut T</code>。它们是不安全的，所以既不是<code>Send</code>也不是<code>Sync</code>。</li>
<li><code>UnsafeCell&lt;T&gt;</code>不支持<code>Sync</code>。也就是说，任何使用了<code>Cell</code>或者<code>RefCell</code>的数据结构不支持<code>Sync</code>。</li>
<li>引用计数<code>Rc</code>不支持<code>Send</code>也不支持<code>Sync</code>。所以<code>Rc</code>无法跨线程。</li>
</ul>
<p>如果尝试跨线程使用<code>Rc/RefCell</code>，会发生什么。在<code>Rust</code>下，如果想创建一个新的线程，需要使用 <code>std::thread::spawn：</code></p>
<pre><code>pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt; 
where
    F: FnOnce() -&gt; T,
    F: Send + 'static,
    T: Send + 'static,
</code></pre>
<p>它的参数是一个闭包，这个闭包需要<code>Send + 'static</code>：</p>
<ul>
<li><code>'static</code>意思是闭包捕获的自由变量必须是一个拥有所有权的类型，或者是一个拥有静态生命周期的引用；</li>
<li><code>Send</code>意思是，这些被捕获自由变量的所有权可以从一个线程移动到另一个线程。</li>
</ul>
<p>从这个接口上，可以得出结论：如果在线程间传递<code>Rc</code>，是无法编译通过的，因为<code>Rc</code>的实现不支持<code>Send</code>和<code>Sync</code>。写段代码验证一下：</p>
<pre><code>// Rc 既不是 Send，也不是 Sync
fn rc_is_not_send_and_sync() {
    let a = Rc::new(1);
    let b = a.clone();
    let c = a.clone();
    thread::spawn(move || {
        println!("c= {:?}", c);
    });
}
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-848c91cfd8aa2f21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>那么，<code>RefCell</code>可以在线程间转移所有权么？<code>RefCell</code>实现了<code>Send</code>，但没有实现<code>Sync</code>，所以，看起来是可以工作的：</p>
<p>既然<code>Rc</code>不能<code>Send</code>，我们无法跨线程使用<code>Rc</code>这样的数据，那么使用支持<code>Send/Sync</code>的<code>Arc</code>呢，使用<code>Arc</code>来获得，一个可以在多线程间共享，且可以修改的类型，可以？</p>
<pre><code>// RefCell 现在有多个 Arc 持有它，虽然 Arc 是 Send/Sync，但 RefCell 不是 Sync
fn refcell_is_not_sync() {
    let a = Arc::new(RefCell::new(1));
    let b = a.clone();
    let c = a.clone();
    thread::spawn(move || {
        println!("c= {:?}", c);
    });
}
</code></pre>
<p>因为 <code>Arc</code>内部的数据是共享的，需要支持<code>Sync</code>的数据结构，但是<code>RefCell</code>不是<code>Sync</code>，编译失败。所以在多线程情况下，我们只能使用支持<code>Send/Sync</code>的<code>Arc</code> ，和<code>Mutex</code>一起，构造一个可以在多线程间共享且可以修改的类型（代码）：</p>
<pre><code>use std::{
    sync::{Arc, Mutex},
    thread,
};

// Arc&lt;Mutex&lt;T&gt;&gt; 可以多线程共享且修改数据
fn arc_mutext_is_send_sync() {
    let a = Arc::new(Mutex::new(1));
    let b = a.clone();
    let c = a.clone();
    let handle = thread::spawn(move || {
        let mut g = c.lock().unwrap();
        *g += 1;
    });

    {
        let mut g = b.lock().unwrap();
        *g += 1;
    }

    handle.join().unwrap();
    println!("a= {:?}", a);
}

fn main() {
    arc_mutext_is_send_sync();
}
</code></pre>
<h2 id="6-3、From-Into-AsRef-AsMut"><a href="#6-3、From-Into-AsRef-AsMut" class="headerlink" title="6.3、From/Into/AsRef/AsMut"></a>6.3、From<t>/Into<t>/AsRef<t>/AsMut<t></t></t></t></t></h2><pre><code>// 第一种方法，为每一种转换提供一个方法
// 把字符串 s 转换成 Path
let v = s.to_path();
// 把字符串 s 转换成 u64
let v = s.to_u64();

// 第二种方法，为 s 和要转换的类型之间实现一个 Into&lt;T&gt; trait
// v 的类型根据上下文得出
let v = s.into();
// 或者也可以显式地标注 v 的类型
let v: u64 = s.into();
</code></pre>
<p>第一种方式，在类型<code>T</code>的实现里，要为每一种可能的转换提供一个方法；第二种，我们为类型<code>T</code>和类型<code>U</code>之间的转换实现一个数据转换<code>trait</code>，这样可以用同一个方法来实现不同的转换。</p>
<p>显然，第二种方法要更好，因为它符合软件开发的开闭原则（<code>Open-Close Principle</code>），“软件中的对象（类、模块、函数等等）对扩展是开放的，但是对修改是封闭的”。</p>
<p>在第一种方式下，未来每次要添加对新类型的转换，都要重新修改类型<code>T</code>的实现，而第二种方式，我们只需要添加一个对于数据转换<code>trait</code>的新实现即可。</p>
<p>基于这个思路，对值类型的转换和对引用类型的转换，<code>Rust</code>提供了两套不同的<code>trait</code>：</p>
<ul>
<li>值类型到值类型的转换：<code>From&lt;T&gt;/Into&lt;T&gt;/TryFrom&lt;T&gt;/TryInto&lt;T&gt;</code></li>
<li>引用类型到引用类型的转换：<code>AsRef&lt;T&gt;/AsMut&lt;T&gt;</code></li>
</ul>
<p><strong>6.3.1 From<t>/Into<t></t></t></strong></p>
<pre><code>pub trait From&lt;T&gt; {
    fn from(T) -&gt; Self;
}

pub trait Into&lt;T&gt; {
    fn into(self) -&gt; T;
}
</code></pre>
<p>在实现<code>From</code>的时候会自动实现<code>Into</code>。这是因为：</p>
<pre><code>// 实现 From 会自动实现 Into
impl&lt;T, U&gt; Into&lt;U&gt; for T where U: From&lt;T&gt; {
    fn into(self) -&gt; U {
        U::from(self)
    }
}
</code></pre>
<p>所以大部分情况下，只用实现<code>From</code>，然后这两种方式都能做数据转换，比如：</p>
<pre><code>impl From&lt;[u8; 4]&gt; for Ipv4Addr {
    fn from(octets: [u8; 4]) -&gt; Ipv4Addr {
        Ipv4Addr { octets }
    }
}

let s = String::from("Hello world!");
let s: String = "Hello world!".into();
let addr = Ipv4Addr::from([127u8, 0u8, 0u8, 0u8]);
let addr :IpAddr = [127u8, 0u8, 0u8, 0u8].into();
</code></pre>
<p><code>From&lt;T&gt; </code>可以根据上下文做类型推导，使用场景更多；而且因为实现了 <code>From&lt;T&gt;</code> 会自动实现<code>Into&lt;T&gt;</code>，反之不会。所以需要的时候，<strong>不要去实现 Into<t>，只要实现 From<t> 就好了</t></t></strong>。</p>
<p>此外，<code>From</code>和<code>Into</code> <strong>还是自反的</strong>：把类型<code>T</code>的值转换成类型<code>T</code>，会直接返回。这是因为标准库有如下的实现：</p>
<pre><code>// From（以及 Into）是自反的
impl&lt;T&gt; From&lt;T&gt; for T {
    fn from(t: T) -&gt; T {
        t
    }
}

let result: i32 = i32::from(12);
</code></pre>
<p>注意，如果你的数据类型在转换过程中有可能出现错误，可以使用 <code>TryFrom&lt;T&gt;</code> 和 <code>TryInto&lt;T&gt;</code>，它们的用法和 <code>From&lt;T&gt;/Into&lt;T&gt;</code>一样，只是<code>trait</code>内多了一个关联类型<code>Error</code>，且返回的结果是<code>Result&lt;T, Self::Error&gt;</code>。</p>
<p><strong>6.3.2 AsRef<t>/AsMut<t></t></t></strong></p>
<p><code>AsRef&lt;T&gt;/AsMut&lt;T&gt;</code>用于从引用到引用的转换。还是先看它们的定义：</p>
<pre><code>pub trait AsRef&lt;T&gt; where T: ?Sized {
    fn as_ref(&amp;self) -&gt; &amp;T;
}

pub trait AsMut&lt;T&gt; where T: ?Sized {
    fn as_mut(&amp;mut self) -&gt; &amp;mut T;
}
</code></pre>
<p>在<code>trait</code>的定义上，都允许<code>T</code>使用大小可变的类型，如<code>str</code>、<code>[u8]</code>等。<code>AsMut&lt;T&gt;</code>除了使用可变引用生成可变引用外，其它都和<code>AsRef&lt;T&gt;</code>一样。</p>
<p>来写一段代码体验一下<code>AsRef</code>的使用和实现：</p>
<pre><code>#[allow(dead_code)]
enum Language {
    Rust,
    TypeScript,
    Elixir,
    Haskell,
}

impl AsRef&lt;str&gt; for Language {
    fn as_ref(&amp;self) -&gt; &amp;str {
        match self {
            Language::Rust =&gt; "Rust",
            Language::TypeScript =&gt; "TypeScript",
            Language::Elixir =&gt; "Elixir",
            Language::Haskell =&gt; "Haskell",
        }
    }
}

fn print_ref(v: impl AsRef&lt;str&gt;) {
    println!("{}", v.as_ref());
}

fn main() {
    let lang = Language::Rust;
    // &amp;str 实现了 AsRef&lt;str&gt;
    print_ref("Hello world!");
    // String 实现了 AsRef&lt;str&gt;
    print_ref("Hello world!".to_string());
    // 我们自己定义的 enum 也实现了 AsRef&lt;str&gt;
    print_ref(lang);
}
</code></pre>
<h2 id="6-4、Deref-DerefMut"><a href="#6-4、Deref-DerefMut" class="headerlink" title="6.4、Deref/DerefMut"></a>6.4、Deref/DerefMut</h2><p>操作符相关的 <code>trait</code> ，上一讲我们已经看到了 <code>Add&lt;Rhs&gt; trait</code>，它允许你重载加法运算符。<code>Rust</code>为所有的运算符都提供了<code>trait</code>，你可以为自己的类型重载某些操作符。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-9271a31e5e2f2be6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>今天重点要介绍的操作符是<code>Deref</code>和<code>DerefMut</code>。来看它们的定义：</p>
<pre><code>pub trait Deref {
    // 解引用出来的结果类型
    type Target: ?Sized;
    fn deref(&amp;self) -&gt; &amp;Self::Target;
}

pub trait DerefMut: Deref {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target;
}
</code></pre>
<p>可以看到，<code>DerefMut</code>“继承”了<code>Deref</code>，只是它额外提供了一个<code>deref_mut</code>方法，用来获取可变的解引用。所以这里重点学习<code>Deref</code>。</p>
<pre><code>let mut x = 42;
let y = &amp;mut x;
// 解引用，内部调用 DerefMut（其实现就是 *self）
*y += 1;
</code></pre>
<p>可以看到，它最终指向了堆上的<code>RcBox</code>内部的<code>value</code>的地址，然后如果对其解引用的话，得到了<code>value</code>对应的值。以下图为例，最终打印出 <code>v = 1</code>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-6d097a81cd05087f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从图中还可以看到，<code>Deref</code>和<code>DerefMut</code>是自动调用的，<code>*b 会被展开为 *(b.deref())</code>。</p>
<p>在<code>Rust</code>里，绝大多数智能指针都实现了<code>Deref</code>，我们也可以为自己的数据结构实现<code>Deref</code>。看一个例子（代码）：</p>
<pre><code>use std::ops::{Deref, DerefMut};

#[derive(Debug)]
struct Buffer&lt;T&gt;(Vec&lt;T&gt;);

impl&lt;T&gt; Buffer&lt;T&gt; {
    pub fn new(v: impl Into&lt;Vec&lt;T&gt;&gt;) -&gt; Self {
        Self(v.into())
    }
}

impl&lt;T&gt; Deref for Buffer&lt;T&gt; {
    type Target = [T];

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}

impl&lt;T&gt; DerefMut for Buffer&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.0
    }
}

fn main() {
    let mut buf = Buffer::new([1, 3, 2, 4]);
    // 因为实现了 Deref 和 DerefMut，这里 buf 可以直接访问 Vec&lt;T&gt; 的方法
    // 下面这句相当于：(&amp;mut buf).deref_mut().sort()，也就是 (&amp;mut buf.0).sort()
    buf.sort();
    println!("buf: {:?}", buf);
}
</code></pre>
<p>但是在这个例子里，数据结构<code>Buffer&lt;T&gt;</code>包裹住了<code>Vec&lt;T&gt;</code>，但这样一来，原本<code>Vec&lt;T&gt;</code>实现了的很多方法，现在使用起来就很不方便，需要用<code>buf.0</code>来访问。怎么办？</p>
<p><strong>可以实现 Deref 和 DerefMut，这样在解引用的时候，直接访问到 buf.0</strong>，省去了代码的啰嗦和数据结构内部字段的隐藏。</p>
<p>在这段代码里，还有一个值得注意的地方：写<code>buf.sort()</code>的时候，并没有做解引用的操作，为什么会相当于访问了 <code>buf.0.sort()</code>呢？这是因为<code>sort()</code>方法第一个参数是<code>&amp;mut self</code>，此时<code>Rust</code>编译器会强制做<code>Deref/DerefMut</code> 的解引用，所以这相当于 <code>(*(&amp;mut buf)).sort()</code>。</p>
<h2 id="6-5、Debug-Display-Default"><a href="#6-5、Debug-Display-Default" class="headerlink" title="6.5、Debug/Display/Default"></a>6.5、Debug/Display/Default</h2><p>可以看到，<code>Debug</code> 和 <code>Display</code> 两个 <code>trait</code> 的签名一样，都接受一个 <code>&amp;self</code> 和一个<code>&amp;mut Formatter</code>。那为什么要有两个一样的<code>trait</code>呢？</p>
<pre><code>pub trait Debug {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}

pub trait Display {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}
</code></pre>
<p>这是因为<code>Debug</code>是为开发者调试打印数据结构所设计的，而<code>Display</code>是给用户显示数据结构所设计的。这也是为什么 <code>Debug trait</code>的实现可以通过派生宏直接生成，而<code>Display</code>必须手工实现。在使用的时候，<code>Debug</code>用<code>{:?}</code>来打印，<code>Display</code>用<code>{}</code>打印。</p>
<p>最后看<code>Default trait</code>。它的定义如下：</p>
<pre><code>pub trait Default {
    fn default() -&gt; Self;
}
</code></pre>
<p><code>Default trait</code>用于为类型提供缺省值。它也可以通过<code>derive</code>宏 <code>#[derive(Default)]</code> 来生成实现，前提是类型中的每个字段都实现了ji<code>Default trait</code>。在初始化一个数据结构时，我们可以部分初始化，然后剩余的部分使用 <code>Default::default()</code>。</p>
<p><code>Debug/Display/Default</code> 如何使用，统一看个例子（代码）：</p>
<pre><code>use std::fmt;
// struct 可以 derive Default，但我们需要所有字段都实现了 Default
#[derive(Clone, Debug, Default)]
struct Developer {
    name: String,
    age: u8,
    lang: Language,
}

// enum 不能 derive Default
#[allow(dead_code)]
#[derive(Clone, Debug)]
enum Language {
    Rust,
    TypeScript,
    Elixir,
    Haskell,
}

// 手工实现 Default
impl Default for Language {
    fn default() -&gt; Self {
        Language::Rust
    }
}

impl Developer {
    pub fn new(name: &amp;str) -&gt; Self {
        // 用 ..Default::default() 为剩余字段使用缺省值
        Self {
            name: name.to_owned(),
            ..Default::default()
        }
    }
}

impl fmt::Display for Developer {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(
            f,
            "{}({} years old): {:?} developer",
            self.name, self.age, self.lang
        )
    }
}

fn main() {
    // 使用 T::default()
    let dev1 = Developer::default();
    // 使用 Default::default()，但此时类型无法通过上下文推断，需要提供类型
    let dev2: Developer = Default::default();
    // 使用 T::new
    let dev3 = Developer::new("Tyr");
    println!("dev1: {}\\ndev2: {}\\ndev3: {:?}", dev1, dev2, dev3);
    // dev1: (0 years old): Rust developer
    // dev2: (0 years old): Rust developer
    // dev3: Developer { name: "Tyr", age: 0, lang: Rust }
}
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-7024d6ef312021a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>在我们使用<code>Rust</code>开发时，<code>trait</code>占据了非常核心的地位。一个设计良好的<code>trait</code>可以大大提升整个系统的可用性和扩展性。</p>
<p><code>trait</code>是行为的延迟绑定。我们可以在不知道具体要处理什么数据结构的前提下，先通过<code>trait</code>把系统的很多行为约定好。</p>
<h1 id="七、智能指针"><a href="#七、智能指针" class="headerlink" title="七、智能指针"></a>七、智能指针</h1><p><img src="https://upload-images.jianshu.io/upload_images/12321605-0778976c917fec88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="smart_pointer.png"></p>
<!--[点我查看原图](./smart_pointer.png)-->

<p><a target="_blank" rel="noopener" href="https://eq2dxlycqpe.feishu.cn/mindnotes/XhcAbK69km6mubnBYVQcjDVFneg#mindmap">脑图链接</a></p>
<h2 id="7-1、String"><a href="#7-1、String" class="headerlink" title="7.1、String"></a>7.1、String</h2><p><strong>智能指针一定是一个胖指针，但胖指针不一定是一个智能指针</strong>。比如<code>&amp;str</code>就只是一个胖指针，它有指向堆内存字符串的指针，同时还有关于字符串长度的元数据。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-24efdf4fa54afd78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="smart_pointer.png"></p>
<p>那么又有一个问题了，<strong>智能指针和结构体有什么区别呢</strong>？因为我们知道，<code>String</code>是用结构体定义的：</p>
<pre><code>pub struct String {
    vec: Vec&lt;u8&gt;,
}
</code></pre>
<p>和普通的结构体不同的是，<code>String</code>实现了<code>Deref</code>和<code>DerefMut</code>，这使得它在解引用的时候，会得到<code>&amp;str</code>，看下面的标准库的实现：</p>
<pre><code>impl ops::Deref for String {
    type Target = str;

    fn deref(&amp;self) -&gt; &amp;str {
        unsafe { str::from_utf8_unchecked(&amp;self.vec) }
    }
}

impl ops::DerefMut for String {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut str {
        unsafe { str::from_utf8_unchecked_mut(&amp;mut *self.vec) }
    }
}
</code></pre>
<p>另外，由于在堆上分配了数据，<code>String</code>还需要为其分配的资源做相应的回收。而<code>String</code>内部使用了<code>Vec</code>，所以它可以依赖<code>Vec</code>的能力来释放堆内存。下面是标准库中<code>Vec</code>的<code>Drop trait</code>的实现：</p>
<pre><code>unsafe impl&lt;#[may_dangle] T, A: Allocator&gt; Drop for Vec&lt;T, A&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            // use drop for [T]
            // use a raw slice to refer to the elements of the vector as weakest necessary type;
            // could avoid questions of validity in certain cases
            ptr::drop_in_place(ptr::slice_from_raw_parts_mut(self.as_mut_ptr(), self.len))
        }
        // RawVec handles deallocation
    }
}
</code></pre>
<p>所以再清晰一下定义，在<code>Rust</code>中，<strong>凡是需要做资源回收的数据结构，且实现了 Deref/DerefMut/Drop，都是智能指针</strong>。</p>
<h2 id="7-2、Box-lt-T-gt"><a href="#7-2、Box-lt-T-gt" class="headerlink" title="7.2、Box<T>"></a>7.2、<code>Box&lt;T&gt;</code></h2><p>我们先看<code>Box&lt;T&gt;</code>，它是<code>Rust</code>中最基本的在堆上分配内存的方式，绝大多数其它包含堆内存分配的数据类型，内部都是通过<code>Box&lt;T&gt;</code>完成的，比如<code>Vec&lt;T&gt;</code>。</p>
<p><code>C</code>需要使用<code>malloc/calloc/realloc/free</code>来处理内存的分配，很多时候，被分配出来的内存在函数调用中来来回回使用，导致谁应该负责释放这件事情很难确定，给开发者造成了极大的心智负担。</p>
<p><code>C++</code>在此基础上改进了一下，提供了一个智能指针<code>unique_ptr</code>，可以在指针退出作用域的时候释放堆内存，这样保证了堆内存的单一所有权。这个<code>unique_ptr</code>就是<code>Rust</code>的<code>Box&lt;T&gt;</code>的前身。</p>
<p>你看<code>Box</code>的定义里，内部就是一个<code>Unique</code>用于致敬<code>C++</code>，<code>Unique</code>是一个私有的数据结构，我们不能直接使用，它包裹了一个<code>*const T</code>指针，并唯一拥有这个指针。</p>
<pre><code>pub struct Unique&lt;T: ?Sized&gt; {
    pointer: *const T,
    // NOTE: this marker has no consequences for variance, but is necessary
    // for dropck to understand that we logically own a `T`.
    //
    // For details, see:
    _marker: PhantomData&lt;T&gt;,
}
</code></pre>
<p><a target="_blank" rel="noopener" href="https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#phantom-data">phantom-data</a></p>
<p>堆上分配内存的<code>Box</code>其实有一个缺省的泛型参数<code>A</code>，就需要满足<code>Allocator trait</code>，并且默认是 <code>Global</code>：</p>
<pre><code>pub struct Box&lt;T: ?Sized,A: Allocator = Global&gt;(Unique&lt;T&gt;, A)
</code></pre>
<p><code>Allocator trait</code>提供很多方法：</p>
<ul>
<li><code>allocate</code>是主要方法，用于分配内存，对应<code>C</code>的<code>malloc/calloc</code>；</li>
<li><code>deallocate</code>，用于释放内存，对应<code>C</code>的<code>free</code>；</li>
<li>还有<code>grow/shrink</code>，用来扩大或缩小堆上已分配的内存，对应<code>C</code>的<code>realloc</code>。</li>
</ul>
<p>可以使用 <code>#[global_allocator]</code> 标记宏，定义你自己的全局分配器</p>
<pre><code>use jemallocator::Jemalloc;

#[global_allocator]
static GLOBAL: Jemalloc = Jemalloc;

fn main() {}
</code></pre>
<p>实现一个自己的内存分配Demo：</p>
<pre><code>use std::alloc::{GlobalAlloc, Layout, System};

struct MyAllocator;

unsafe impl GlobalAlloc for MyAllocator {
    unsafe fn alloc(&amp;self, layout: Layout) -&gt; *mut u8 {
        let data = System.alloc(layout);
        eprintln!("ALLOC: {:p}, size {}", data, layout.size());
        data
    }

    unsafe fn dealloc(&amp;self, ptr: *mut u8, layout: Layout) {
        System.dealloc(ptr, layout);
        eprintln!("FREE: {:p}, size {}", ptr, layout.size());
    }
}

#[global_allocator]
static GLOBAL: MyAllocator = MyAllocator;

#[allow(dead_code)]
struct Matrix {
    // 使用不规则的数字如 505 可以让 dbg! 的打印很容易分辨出来
    data: [u8; 505],
}

impl Default for Matrix {
    fn default() -&gt; Self {
        Self { data: [0; 505] }
    }
}

fn main() {
    // 在这句执行之前已经有好多内存分配
    let data = Box::new(Matrix::default());

    // 输出中有一个 1024 大小的内存分配，是 println! 导致的
    println!(
        "!!! allocated memory: {:p}, len: {}",
        &amp;*data,
        std::mem::size_of::&lt;Matrix&gt;()
    );

    // data 在这里 drop，可以在打印中看到 FREE
    // 之后还有很多其它内存被释放
}
</code></pre>
<p>搞明白<code>Box</code>的内存分配，我们还很关心内存是如何释放的，来看它实现的<code>Drop trait</code>：</p>
<pre><code>#[stable(feature = "rust1", since = "1.0.0")]
unsafe impl&lt;#[may_dangle] T: ?Sized, A: Allocator&gt; Drop for Box&lt;T, A&gt; {
    fn drop(&amp;mut self) {
        // FIXME: Do nothing, drop is currently performed by compiler.
    }
}
</code></pre>
<p>目前<code>drop trait</code>什么都没有做，编译器会自动插入<code>deallocate</code>的代码。这是<code>Rust</code>语言的一种策略：在具体实现还没有稳定下来之前，我先把接口稳定，实现随着之后的迭代慢慢稳定。</p>
<h2 id="7-3、PhantomData"><a href="#7-3、PhantomData" class="headerlink" title="7.3、PhantomData"></a>7.3、PhantomData</h2><p>现在要设计一个<code>User</code>和<code>Product</code>数据结构，它们都有一个<code>u64</code>类型的<code>id</code>。然而我希望每个数据结构的<code>id</code>只能和同种类型的<code>id</code>比较，也就是说如果<code>user.id</code>和<code>product.id</code>比较，编译器就能直接报错，拒绝这种行为。该怎么做呢？</p>
<p>如果你使用过任何其他支持泛型的语言，无论是 <code>Java</code>、<code>Swift</code>还是<code>TypeScript</code>，可能都接触过<code>Phantom Type</code>（<strong>幽灵类型</strong>）的概念。像刚才的写法，<code>Swift/TypeScript</code>会让其通过，因为它们的编译器会自动把多余的泛型参数当成 <code>Phantom type</code>来用,比如下面<code>TypeScript</code>的例子，可以编译：</p>
<pre><code>// NotUsed is allowed
class MyNumber&lt;T, NotUsed&gt; {
    inner: T;
    add: (x: T, y: T) =&gt; T;
}
</code></pre>
<p>但<code>Rust</code>对此有洁癖。<code>Rust</code>并不希望在定义类型时，出现目前还没使用，但未来会被使用的泛型参数，所以<code>Rust</code>编译器对此无情拒绝，把门关得严严实实。</p>
<p>不过<code>Rust</code>知道<code>Phantom Type</code>的必要性，所以开了一扇叫<code>PhantomData</code>的窗户：让我们可以用<code>PhantomData</code>来持有<code>Phantom Type</code>。<strong>但它被广泛用在处理，数据结构定义过程中不需要，但是在实现过程中需要的泛型参数</strong>。</p>
<p>实现<code>user.id</code>, <code>product.id</code> 不能比较的<code>Demo</code>：</p>
<pre><code>use std::marker::PhantomData;

#[derive(Debug, Default, PartialEq, Eq)]
pub struct Identifier&lt;T&gt; {
    inner: u64,
    _tag: PhantomData&lt;T&gt;,
}

#[derive(Debug, Default, PartialEq, Eq)]
pub struct User {
    id: Identifier&lt;Self&gt;,
}

#[derive(Debug, Default, PartialEq, Eq)]
pub struct Product {
    id: Identifier&lt;Self&gt;,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn id_should_not_be_the_same() {
        let user = User::default();
        let product = Product::default();

        // 两个 id 不能比较，因为他们属于不同的类型
        // assert_ne!(user.id, product.id);

        assert_eq!(user.id.inner, product.id.inner);
    }
}
</code></pre>
<p>在定义数据结构时，对于额外的、暂时不需要的泛型参数，用<code>PhantomData</code>来“拥有”它们，这样可以规避编译器的报错。<code>PhantomData</code>正如其名，它实际上长度为零，是个<code>ZST（Zero-Sized Type</code>），就像不存在一样，唯一作用就是类型的标记。</p>
<h2 id="7-4、Cow-lt-’a-B-gt"><a href="#7-4、Cow-lt-’a-B-gt" class="headerlink" title="7.4、Cow<’a, B>"></a>7.4、Cow&lt;’a, B&gt;</h2><p>它是一个 <code>enum</code>，可以包含一个对类型<code>B</code>的只读引用，或者包含对类型<code>B</code>的拥有所有权的数据。定义：</p>
<pre><code>pub enum Cow&lt;'a, B&gt; where B: 'a + ToOwned + ?Sized {
  Borrowed(&amp;'a B),
  Owned(&lt;B as ToOwned&gt;::Owned),
}


impl ToOwned for str {
    type Owned = String; // Borrowed&lt;str&gt;
    #[inline]
    fn to_owned(&amp;self) -&gt; String {
        unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }
    }

    fn clone_into(&amp;self, target: &amp;mut String) {
        let mut b = mem::take(target).into_bytes();
        self.as_bytes().clone_into(&amp;mut b);
        *target = unsafe { String::from_utf8_unchecked(b) }
    }
}

    
impl Borrow&lt;str&gt; for String {
    #[inline]
    fn borrow(&amp;self) -&gt; &amp;str {
        &amp;self[..]
    }
}
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-604b64302bda9c11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>Cow</code>是智能指针，那它自然需要实现 <code>Deref trait</code>：</p>
<pre><code>impl&lt;B: ?Sized + ToOwned&gt; Deref for Cow&lt;'_, B&gt; {
    type Target = B;

    fn deref(&amp;self) -&gt; &amp;B {
        match *self {
            Borrowed(borrowed) =&gt; borrowed,
            Owned(ref owned) =&gt; owned.borrow(),
        }
    }
}
</code></pre>
<p>实现的原理很简单，根据<code>self</code>是<code>Borrowed</code>还是<code>Owned</code>，我们分别取其内容，生成引用：</p>
<ul>
<li>对于<code>Borrowed</code>，直接就是引用；</li>
<li>对于<code>Owned</code>，调用其<code>borrow()</code>方法，获得引用。</li>
</ul>
<p>使用<code>Demo</code>：</p>
<pre><code>use std::borrow::Cow;

use url::Url;
fn main() {
    let url = Url::parse("https://tyr.com/rust?page=1024&amp;sort=desc&amp;extra=hello%20world").unwrap();
    let mut pairs = url.query_pairs();

    assert_eq!(pairs.count(), 3);

    let (mut k, v) = pairs.next().unwrap();
    // 因为 k, v 都是 Cow&lt;str&gt; 他们用起来感觉和 &amp;str 或者 String 一样
    // 此刻，他们都是 Borrowed
    println!("key: {}, v: {}", k, v);
    // 当修改发生时，k 变成 Owned
    k.to_mut().push_str("_lala");

    print_pairs((k, v));

    print_pairs(pairs.next().unwrap());
    // 在处理 extra=hello%20world 时，value 被处理成 "hello world"
    // 所以这里 value 是 Owned
    print_pairs(pairs.next().unwrap());
}

fn print_pairs(pair: (Cow&lt;str&gt;, Cow&lt;str&gt;)) {
    println!("key: {}, value: {}", show_cow(pair.0), show_cow(pair.1));
}

fn show_cow(cow: Cow&lt;str&gt;) -&gt; String {
    match cow {
        Cow::Borrowed(v) =&gt; format!("Borrowed {}", v),
        Cow::Owned(v) =&gt; format!("Owned {}", v),
    }
}
</code></pre>
<h2 id="7-5、MutexGuard"><a href="#7-5、MutexGuard" class="headerlink" title="7.5、MutexGuard"></a>7.5、MutexGuard</h2><p><code>MutexGuard&lt;T&gt;</code>是另外一类很有意思的智能指针：它不但通过<code>Deref</code>提供良好的用户体验，<strong>还通过 Drop trait 来确保，使用到的内存以外的资源在退出时进行释放</strong>。</p>
<p><code>MutexGuard</code>这个结构是在调用<code>Mutex::lock</code>时生成的：</p>
<pre><code>pub fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;'_, T&gt;&gt; {
    unsafe {
        self.inner.raw_lock();
        MutexGuard::new(self)
    }
}
</code></pre>
<p>首先，它会取得锁资源，如果拿不到，会在这里等待；如果拿到了，会把<code>Mutex</code>结构的引用传递给<code>MutexGuard</code>。</p>
<p>我们看<code>MutexGuard</code>的定义以及它的<code>Deref</code>和<code>Drop</code>的实现，很简单：</p>
<pre><code>// 这里用 must_use，当你得到了却不使用 MutexGuard 时会报警
#[must_use = "if unused the Mutex will immediately unlock"]
pub struct MutexGuard&lt;'a, T: ?Sized + 'a&gt; {
    lock: &amp;'a Mutex&lt;T&gt;,
    poison: poison::Guard,
}

impl&lt;T: ?Sized&gt; Deref for MutexGuard&lt;'_, T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        unsafe { &amp;*self.lock.data.get() }
    }
}

impl&lt;T: ?Sized&gt; DerefMut for MutexGuard&lt;'_, T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut T {
        unsafe { &amp;mut *self.lock.data.get() }
    }
}

impl&lt;T: ?Sized&gt; Drop for MutexGuard&lt;'_, T&gt; {
    #[inline]
    fn drop(&amp;mut self) {
        unsafe {
            self.lock.poison.done(&amp;self.poison);
            self.lock.inner.raw_unlock();
        }
    }
}
</code></pre>
<p>从代码中可以看到，当<code>MutexGuard</code>结束时，<code>Mutex</code>会做<code>unlock</code>，这样用户在使用<code>Mutex</code>时，可以不必关心何时释放这个互斥锁。因为无论你在调用栈上怎样传递<code>MutexGuard</code> ，哪怕在错误处理流程上提前退出，<code>Rust</code>有所有权机制，可以确保只要<code>MutexGuard</code>离开作用域，锁就会被释放。</p>
<p>使用Demo：</p>
<pre><code>use lazy_static::lazy_static;
use std::borrow::Cow;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

// lazy_static 宏可以生成复杂的 static 对象
lazy_static! {
    // 一般情况下 Mutex 和 Arc 一起在多线程环境下提供对共享内存的使用
    // 如果你把 Mutex 声明成 static，其生命周期是静态的，不需要 Arc
    static ref METRICS: Mutex&lt;HashMap&lt;Cow&lt;'static, str&gt;, usize&gt;&gt; =
        Mutex::new(HashMap::new());
}

fn main() {
    // 用 Arc 来提供并发环境下的共享所有权（使用引用计数）
    let metrics: Arc&lt;Mutex&lt;HashMap&lt;Cow&lt;'static, str&gt;, usize&gt;&gt;&gt; =
        Arc::new(Mutex::new(HashMap::new()));
    for _ in 0..32 {
        let m = metrics.clone();
        thread::spawn(move || {
            let mut g = m.lock().unwrap();
            // 此时只有拿到 MutexGuard 的线程可以访问 HashMap
            let data = &amp;mut *g;
            // Cow 实现了很多数据结构的 From trait，
            // 所以我们可以用 "hello".into() 生成 Cow
            let entry = data.entry("hello".into()).or_insert(0);
            *entry += 1;
            // MutexGuard 被 Drop，锁被释放
        });
    }

    thread::sleep(Duration::from_millis(100));

    println!("metrics: {:?}", metrics.lock().unwrap());
}
</code></pre>
<h2 id="7-6、实现自己的智能指针"><a href="#7-6、实现自己的智能指针" class="headerlink" title="7.6、实现自己的智能指针"></a>7.6、实现自己的智能指针</h2><p>内部用一个字节表示字符串的长度，用<code>30</code>个字节表示字符串内容，再加上<code>1</code>个字节的<code>tag</code>，正好也是<code>32</code>字节，可以和 <code>String</code>放在一个<code>enum</code>里使用。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-ebea5b78bdb08ca4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>示例代码：</p>
<pre><code>use std::{fmt, ops::Deref, str};

const MINI_STRING_MAX_LEN: usize = 30;

// MyString 里，String 有 3 个 word，供 24 字节，所以它以 8 字节对齐
// 所以 enum 的 tag + padding 最少 8 字节，整个结构占 32 字节。
// MiniString 可以最多有 30 字节（再加上 1 字节长度和 1字节 tag），就是 32 字节.
struct MiniString {
    len: u8,
    data: [u8; MINI_STRING_MAX_LEN],
}

impl MiniString {
    // 这里 new 接口不暴露出去，保证传入的 v 的字节长度小于等于 30
    fn new(v: impl AsRef&lt;str&gt;) -&gt; Self {
        let bytes = v.as_ref().as_bytes();
        // 我们在拷贝内容时一定要使用字符串的字节长度
        let len = bytes.len();
        let mut data = [0u8; MINI_STRING_MAX_LEN];
        data[..len].copy_from_slice(bytes);
        Self {
            len: len as u8,
            data,
        }
    }
}

impl Deref for MiniString {
    type Target = str;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        // 由于生成 MiniString 的接口是隐藏的，它只能来自字符串，所以下面这行是安全的
        str::from_utf8(&amp;self.data[..self.len as usize]).unwrap()
        // 也可以直接用 unsafe 版本
        // unsafe { str::from_utf8_unchecked(&amp;self.data[..self.len as usize]) }
    }
}

impl fmt::Debug for MiniString {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        // 这里由于实现了 Deref trait，可以直接得到一个 &amp;str 输出
        write!(f, "{}", self.deref())
    }
}

#[derive(Debug)]
enum MyString {
    Inline(MiniString),
    Standard(String),
}

// 实现 Deref 接口对两种不同的场景统一得到 &amp;str
impl Deref for MyString {
    type Target = str;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        match *self {
            MyString::Inline(ref v) =&gt; v.deref(),
            MyString::Standard(ref v) =&gt; v.deref(),
        }
    }
}

impl From&lt;&amp;str&gt; for MyString {
    fn from(s: &amp;str) -&gt; Self {
        match s.len() &gt; MINI_STRING_MAX_LEN {
            true =&gt; Self::Standard(s.to_owned()),
            _ =&gt; Self::Inline(MiniString::new(s)),
        }
    }
}

impl fmt::Display for MyString {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, "{}", self.deref())
    }
}

fn main() {
    let len1 = std::mem::size_of::&lt;MyString&gt;();
    let len2 = std::mem::size_of::&lt;MiniString&gt;();
    println!("Len: MyString {}, MiniString {}", len1, len2);

    let s1: MyString = "hello world".into();
    let s2: MyString = "这是一个超过了三十个字节的很长很长的字符串".into();

    // debug 输出
    println!("s1: {:?}, s2: {:?}", s1, s2);
    // display 输出
    println!(
        "s1: {}({} bytes, {} chars), s2: {}({} bytes, {} chars)",
        s1,
        s1.len(),
        s1.chars().count(),
        s2,
        s2.len(),
        s2.chars().count()
    );

    // MyString 可以使用一切 &amp;str 接口，感谢 Rust 的自动 Deref
    assert!(s1.ends_with("world"));
    assert!(s2.starts_with("这"));
}
</code></pre>
<h1 id="八、集合容器"><a href="#八、集合容器" class="headerlink" title="八、集合容器"></a>八、集合容器</h1><p><img src="https://upload-images.jianshu.io/upload_images/12321605-d21364723716dfc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>集合容器，顾名思义，就是把一系列拥有相同类型的数据放在一起，统一处理，比如：</p>
<ul>
<li>我们熟悉的字符串<code>String</code>、数组<code>[T; n]</code>、列表<code>Vec</code>和哈希表<code>HashMap</code>等；</li>
<li>虽然到处在使用，但还并不熟悉的切片<code>slice</code>；</li>
<li>在其他语言中使用过，但在<code>Rust</code>中还没有用过的循环缓冲区<code>VecDeque</code>、双向列表<code>LinkedList</code>等。</li>
</ul>
<h2 id="8-1、切片"><a href="#8-1、切片" class="headerlink" title="8.1、切片"></a>8.1、切片</h2><p>在<code>Rust</code>里，切片是描述一组属于同一类型、长度不确定的、在内存中连续存放的数据结构，用<code>[T]</code>来表述。因为长度不确定，所以切片是个 <code>DST（Dynamically Sized Type）</code>。</p>
<p>切片一般只出现在数据结构的定义中，不能直接访问，在使用中主要用以下形式：</p>
<ul>
<li><code>&amp;[T]</code>：表示一个只读的切片引用。</li>
<li><code>&amp;mut [T]</code>：表示一个可写的切片引用。</li>
<li><code>Box&lt;[T]&gt;</code>：一个在堆上分配的切片。</li>
</ul>
<p>怎么理解切片呢？我打个比方，<strong>切片之于具体的数据结构，就像数据库中的视图之于表</strong>。你可以把它看成一种工具，让我们可以统一访问行为相同、结构类似但有些许差异的类型。</p>
<p>来看下面的代码，辅助理解：</p>
<pre><code>fn main() {
    let arr = [1, 2, 3, 4, 5];
    let vec = vec![1, 2, 3, 4, 5];
    let s1 = &amp;arr[..2];
    let s2 = &amp;vec[..2];
    println!("s1: {:?}, s2: {:?}", s1, s2);

    // &amp;[T] 和 &amp;[T] 是否相等取决于长度和内容是否相等
    assert_eq!(s1, s2);
    // &amp;[T] 可以和 Vec&lt;T&gt;/[T;n] 比较，也会看长度和内容
    assert_eq!(&amp;arr[..], vec);
    assert_eq!(&amp;vec[..], arr);
}
</code></pre>
<p>对于<code>array</code>和<code>vector</code>，虽然是不同的数据结构，一个放在栈上，一个放在堆上，但它们的切片是类似的；而且对于相同内容数据的相同切片，比如 <code>&amp;arr[1…3]</code> 和 <code>&amp;vec[1…3]</code>，这两者是等价的。除此之外，切片和对应的数据结构也可以直接比较，这是因为它们之间实现了 <code>PartialEq trait</code>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-dec233931b0e6d6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>Vec&lt;T&gt;</code>、<code>&amp;[T]</code>和<code>&amp;Vec&lt;T&gt;</code>关系：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-6dfdf5802b7efc3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>在使用的时候，支持切片的具体数据类型，你可以根据需要，解引用转换成切片类型。比如<code>Vec</code>和<code>[T; n]</code>会转化成为 <code>&amp;[T]</code>，这是因为<code>Vec</code>实现了<code>Deref trait</code>，而<code>array</code>内建了到<code>&amp;[T]</code>的解引用。</p>
<h2 id="8-2、迭代器-Iterator"><a href="#8-2、迭代器-Iterator" class="headerlink" title="8.2、迭代器 Iterator"></a>8.2、迭代器 Iterator</h2><p>迭代器可以说是切片的孪生兄弟。切片是集合数据的视图，而迭代器定义了对集合数据的各种各样的访问操作。</p>
<p>通过切片的<code>iter()</code>方法，我们可以生成一个迭代器，对切片进行迭代。</p>
<p><code>iterator trait</code>有大量的方法，但绝大多数情况下，我们只需要定义它的关联类型<code>Item</code>和<code>next()</code>方法。</p>
<ul>
<li><p><code>Item</code>定义了每次我们从迭代器中取出的数据类型；</p>
</li>
<li><p><code>next()</code>是从迭代器里取下一个值的方法。当一个迭代器的<code>next()</code>方法返回<code>None</code>时，表明迭代器中没有数据了。</p>
<pre><code>  #[must_use = "iterators are lazy and do nothing unless consumed"]
  pub trait Iterator {
      type Item;
      fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
      // 大量缺省的方法，包括 size_hint, count, chain, zip, map, 
      // filter, for_each, skip, take_while, flat_map, flatten
      // collect, partition 等
      ... 
  }
</code></pre>
</li>
</ul>
<p>看一个例子，对<code>Vec</code>使用<code>iter()</code>方法，并进行各种 <code>map/filter/take</code> 操作。在函数式编程语言中，这样的写法很常见，代码的可读性很强。<code>Rust</code>也支持这种写法：</p>
<pre><code>fn main() {
    // 这里 Vec&lt;T&gt; 在调用 iter() 时被解引用成 &amp;[T]，所以可以访问 iter()
    let result = vec![1, 2, 3, 4]
        .iter()
        .map(|v| v * v)
        .filter(|v| *v &lt; 16)
        .take(1)
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("{:?}", result);
}
</code></pre>
<p>整个过程是这样的：</p>
<ul>
<li>在<code>collect()</code>执行的时候，它实际试图使用<code>FromIterator</code>从迭代器中构建一个集合类型，这会不断调用<code>next()</code>获取下一个数据；</li>
<li>此时的<code>Iterator</code>是<code>Take</code>，<code>Take</code>调自己的<code>next()</code>，也就是它会调用<code>Filter</code>的<code>next()</code>；</li>
<li><code>Filter</code>的<code>next()</code>实际上调用自己内部的<code>iter</code>的<code>find()</code>，此时内部的<code>iter</code>是<code>Map</code>，<code>find()</code>会使用 <code>try_fold()</code>，它会继续调用<code>next()</code>，也就是<code>Map</code>的<code>next()</code>；</li>
<li><code>Map</code>的<code>next()</code>会调用其内部的<code>iter</code>取<code>next()</code>然后执行<code>map</code>函数。而此时内部的<code>iter</code>来自<code>Vec&lt;i32&gt;</code>。</li>
</ul>
<p>所以，只有在<code>collect()</code>时，才触发代码一层层调用下去，并且调用会根据需要随时结束。这段代码中我们使用了 <code>take(1)</code>，整个调用链循环一次，就能满足<code>take(1)</code>以及所有中间过程的要求，所以它只会循环一次。</p>
<h2 id="8-3、-amp-str、String、-amp-String"><a href="#8-3、-amp-str、String、-amp-String" class="headerlink" title="8.3、&amp;str、String、&amp;String"></a>8.3、&amp;str、String、&amp;String</h2><p><img src="https://upload-images.jianshu.io/upload_images/12321605-4e8d1564b198c2fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-a7c1df71af6856dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="8-4、Vet-lt-T-gt-、Box-lt-T-gt-、-amp-T、-amp-mut-T"><a href="#8-4、Vet-lt-T-gt-、Box-lt-T-gt-、-amp-T、-amp-mut-T" class="headerlink" title="8.4、Vet<T>、Box<[T]>、&amp;T、&amp;mut T"></a>8.4、<code>Vet&lt;T&gt;</code>、<code>Box&lt;[T]&gt;</code>、&amp;T、&amp;mut T</h2><p><code>Box&lt;[T]&gt;</code>是一个比较有意思的存在，它和<code>Vec&lt;T&gt;</code>有一点点差别：<code>Vec&lt;T&gt;</code> 有额外的<code>capacity</code>，可以增长；而 <code>Box&lt;[T]&gt;</code>一旦生成就固定下来，没有<code>capacity</code>，也无法增长。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-60b754cdacf92cfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>那么如何产生 <code>Box&lt;[T]&gt;</code> 呢？目前可用的接口就只有一个：从已有的<code>Vec</code>中转换。我们看代码：</p>
<pre><code>use std::ops::Deref;

fn main() {
    let mut v1 = vec![1, 2, 3, 4];
    v1.push(5);
    println!("cap should be 8: {}", v1.capacity());

    // 从 Vec&lt;T&gt; 转换成 Box&lt;[T]&gt;，此时会丢弃多余的 capacity
    let b1 = v1.into_boxed_slice();
    let mut b2 = b1.clone();

    let v2 = b1.into_vec();
    println!("cap should be exactly 5: {}", v2.capacity());

    assert!(b2.deref() == v2);

    // Box&lt;[T]&gt; 可以更改其内部数据，但无法 push
    b2[0] = 2;
    // b2.push(6);
    println!("b2: {:?}", b2);

    // 注意 Box&lt;[T]&gt; 和 Box&lt;[T; n]&gt; 并不相同
    let b3 = Box::new([2, 2, 3, 4, 5]);
    println!("b3: {:?}", b3);

    // b2 和 b3 相等，但 b3.deref() 和 v2 无法比较
    assert!(b2 == b3);
    // assert!(b3.deref() == v2);
}
</code></pre>
<p>运行代码可以看到，<code>Vec&lt;T&gt;</code>可以通过<code>into_boxed_slice()</code>转换成<code>Box&lt;[T]&gt;</code>，<code>Box&lt;[T]&gt;</code>也可以通过<code>into_vec()</code>转换回<code>Vec&lt;T&gt;</code>。</p>
<p>这两个转换都是很轻量的转换，只是变换一下结构，不涉及数据的拷贝。区别是，当<code>Vec&lt;T&gt;</code>转换成<code>Box&lt;[T]&gt;</code>时，没有使用到的容量就会被丢弃，所以整体占用的内存可能会降低。而且<code>Box&lt;[T]&gt;</code>有一个很好的特性是，不像<code>Box&lt;[T;n]&gt;</code>那样在编译时就要确定大小，它可以在运行期生成，以后大小不会再改变。</p>
<p>所以，**当我们需要在堆上创建固定大小的集合数据，且不希望自动增长，那么，可以先创建 Vec<t>，再转换成 Box&lt;[T]&gt;**。<code>tokio</code>在提供<code>broadcast channel</code>时，就使用了<code>Box&lt;[T]&gt;</code> 这个特性，你感兴趣的话，可以自己看看源码。</t></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-73bcf88711b5227e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<pre><code>fn main() {
    let vec = vec![1, 2, 3];

    let result = vec_to_array(vec);

    match result {
        Some(arr) =&gt; println!("Array: {:?}", arr),
        None =&gt; println!("Conversion failed"),
    }
}

// 将 Vec&lt;i32&gt; 转换为 [i32; 3] 数组
fn vec_to_array(vec: Vec&lt;i32&gt;) -&gt; Option&lt;[i32; 3]&gt; {
    if vec.len() == 3 {
        let mut array = [0; 3];  // 创建一个固定大小的新数组

        // 转换 Vec&lt;i32&gt; 为 slice，尝试将其转换为 [i32; 3] 数组引用
        let slice = vec.as_slice().try_into().unwrap();

        // 使用 clone_from_slice 将数组引用的内容复制到新数组中
        array.clone_from_slice(slice);

        Some(array)
    } else {
        None
    }
}
</code></pre>
<h1 id="九、哈希表"><a href="#九、哈希表" class="headerlink" title="九、哈希表"></a>九、哈希表</h1><p><code>Google</code>的工程师<code>Matt Kulukundis</code>在<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?t=210&amp;v=ncHmEUmJZf4&amp;feature=youtu.be">cppCon 2017</a> 做的一个演讲，说：全世界<code>Google</code>的服务器上<code>1%</code>的<code>CPU</code>时间用来做哈希表的计算，超过<code>4%</code>的内存用来存储哈希表。足以证明哈希表的重要性。</p>
<blockquote>
<p>A hash map implemented with quadratic probing and SIMD lookup.</p>
</blockquote>
<p>二次探查（<code>quadratic probing</code>）和<code>SIMD</code>查表（<code>SIMD lookup</code>）它们是<code>Rust</code>哈希表算法的设计核心。</p>
<p><strong>如何解决哈希冲突？</strong></p>
<p>理论上，主要的冲突解决机制有链地址法（<code>chaining</code>）和开放寻址法（<code>open addressing</code>）。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-cd0027fae02c2537.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>开放寻址法把整个哈希表看做一个大数组，不引入额外的内存，当冲突产生时，按照一定的规则把数据插入到其它空闲的位置。比如线性探寻（<code>linear probing</code>）在出现哈希冲突时，不断往后探寻，直到找到空闲的位置插入。</p>
<p>而<strong>二次探查</strong>，理论上是在冲突发生时，不断探寻哈希位置加减<code>n</code>的二次方，找到空闲的位置插入，我们看图，更容易理解：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-c6f0be1fe5256f35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="9-1、HashMap-的数据结构"><a href="#9-1、HashMap-的数据结构" class="headerlink" title="9.1、HashMap 的数据结构"></a>9.1、HashMap 的数据结构</h2><pre><code>use hashbrown::hash_map as base;

#[derive(Clone)]
pub struct RandomState {
    k0: u64,
    k1: u64,
}

pub struct HashMap&lt;K, V, S = RandomState&gt; {
    base: base::HashMap&lt;K, V, S&gt;,
}
</code></pre>
<p>可以看到，<code>HashMap</code>有三个泛型参数，<code>K</code>和<code>V</code>代表<code>key/value</code> 的类型，<code>S</code>是哈希算法的状态，它默认是 <code>RandomState</code>，占两个<code>u64</code>。<code>RandomState</code>使用<code>SipHash</code>作为缺省的哈希算法，它是一个加密安全的哈希函数（<code>cryptographically secure hashing</code>）。</p>
<p>从定义中还能看到，<code>Rust</code>的<code>HashMap</code>复用了<code>hashbrown</code>的<code>HashMap</code>。<code>hashbrown</code>是<code>Rust</code>下对<a target="_blank" rel="noopener" href="https://abseil.io/blog/20180927-swisstables"> Google Swiss Table</a> 的一个改进版实现，我们打开<code>hashbrown</code> 的代码，看它的结构：</p>
<pre><code>pub struct HashMap&lt;K, V, S = DefaultHashBuilder, A: Allocator + Clone = Global&gt; {
    pub(crate) hash_builder: S,
    pub(crate) table: RawTable&lt;(K, V), A&gt;,
}
</code></pre>
<p>可以看到，<code>HashMap</code>里有两个域，一个是<code>hash_builder</code>，类型是刚才我们提到的标准库使用的<code>RandomState</code>，还有一个是具体的<code>RawTable</code>：</p>
<pre><code>pub struct RawTable&lt;T, A: Allocator + Clone = Global&gt; {
    table: RawTableInner&lt;A&gt;,
    // Tell dropck that we own instances of T.
    marker: PhantomData&lt;T&gt;,
}

struct RawTableInner&lt;A&gt; {
    // Mask to get an index from a hash value. The value is one less than the
    // number of buckets in the table.
    bucket_mask: usize,

    // [Padding], T1, T2, ..., Tlast, C1, C2, ...
    //                                ^ points here
    ctrl: NonNull&lt;u8&gt;,

    // Number of elements that can be inserted before we need to grow the table
    growth_left: usize,

    // Number of elements in the table, only really used by len()
    items: usize,

    alloc: A,
}
</code></pre>
<p><code>RawTable</code>中，实际上有意义的数据结构是<code>RawTableInner</code>，前四个字段很重要：</p>
<ul>
<li><code>usize</code>的<code>bucket_mask</code>，是哈希表中哈希桶的数量减一；</li>
<li>名字叫<code>ctrl</code>的指针，它指向哈希表堆内存末端的<code>ctrl</code>区；</li>
<li><code>usize</code>的字段<code>growth_left</code>，指哈希表在下次自动增长前还能存储多少数据；</li>
<li><code>usize</code>的<code>items</code>，表明哈希表现在有多少数据。</li>
</ul>
<p>这里最后的<code>alloc</code>字段，和<code>RawTable</code>的<code>marker</code>一样，只是一个用来占位的类型，我们现在只需知道，它用来分配在堆上的内存。</p>
<p><strong>9.1.1 HashMap 的基本使用方法</strong></p>
<pre><code>use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    explain("empty", &amp;map);

    map.insert('a', 1);
    explain("added 1", &amp;map);

    map.insert('b', 2);
    map.insert('c', 3);
    explain("added 3", &amp;map);

    map.insert('d', 4);
    explain("added 4", &amp;map);

    // get 时需要使用引用，并且也返回引用
    assert_eq!(map.get(&amp;'a'), Some(&amp;1));
    assert_eq!(map.get_key_value(&amp;'b'), Some((&amp;'b', &amp;2)));

    map.remove(&amp;'a');
    // 删除后就找不到了
    assert_eq!(map.contains_key(&amp;'a'), false);
    assert_eq!(map.get(&amp;'a'), None);
    explain("removed", &amp;map);
    // shrink 后哈希表变小
    map.shrink_to_fit();
    explain("shrinked", &amp;map);
}

fn explain&lt;K, V&gt;(name: &amp;str, map: &amp;HashMap&lt;K, V&gt;) {
    println!("{}: len: {}, cap: {}", name, map.len(), map.capacity());
}
</code></pre>
<h2 id="9-2、HashMap-的内存布局"><a href="#9-2、HashMap-的内存布局" class="headerlink" title="9.2、HashMap 的内存布局"></a>9.2、HashMap 的内存布局</h2><p>但是通过<code>HashMap</code>的公开接口，我们无法看到<code>HashMap</code>在内存中是如何布局的，还是需要借助之前使用过的 <code>std::mem::transmute</code>方法，来把数据结构打出来：</p>
<pre><code>use std::collections::HashMap;

fn main() {
    let map = HashMap::new();
    let mut map = explain("empty", map);

    map.insert('a', 1);
    let mut map = explain("added 1", map);
    map.insert('b', 2);
    map.insert('c', 3);

    let mut map = explain("added 3", map);

    map.insert('d', 4);

    let mut map = explain("added 4", map);

    map.remove(&amp;'a');

    explain("final", map);
}

// HashMap 结构有两个 u64 的 RandomState，然后是四个 usize，
// 分别是 bucket_mask, ctrl, growth_left 和 items
// 我们 transmute 打印之后，再 transmute 回去
fn explain&lt;K, V&gt;(name: &amp;str, map: HashMap&lt;K, V&gt;) -&gt; HashMap&lt;K, V&gt; {
    let arr: [usize; 6] = unsafe { std::mem::transmute(map) };
    println!(
        "{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}",
        name, arr[2], arr[3], arr[4], arr[5]
    );
    unsafe { std::mem::transmute(arr) }
}
</code></pre>
<p>可以看到</p>
<pre><code>empty: bucket_mask 0x0, ctrl 0x1056df820, growth_left: 0, items: 0
added 1: bucket_mask 0x3, ctrl 0x7fa0d1405e30, growth_left: 2, items: 1
added 3: bucket_mask 0x3, ctrl 0x7fa0d1405e30, growth_left: 0, items: 3
added 4: bucket_mask 0x7, ctrl 0x7fa0d1405e90, growth_left: 3, items: 4
final: bucket_mask 0x7, ctrl 0x7fa0d1405e90, growth_left: 4, items: 3
</code></pre>
<p>在<code>OS X</code>下，一开始哈希表为空，<code>ctrl</code>地址看上去是一个<code>TEXT/RODATA</code>段的地址，应该是指向了一个默认的空表地址；插入第一个数据后，哈希表分配了<code>4</code>个<code>bucket</code>，<code>ctrl</code>地址发生改变；在插入三个数据后，<code>growth_left</code>为零，再插入时，哈希表重新分配，<code>ctrl</code>地址继续改变。</p>
<p>因为哈希表有<code>8</code>个<code>bucket（0x7 + 1）</code>，每个<code>bucket</code>大小是<code>key（char+value（i32）</code>的大小，也就是<code>8</code>个字节，所以一共是<code>64</code>个字节。对于这个例子，通过<code>ctrl</code>地址减去<code>64</code>，就可以得到哈希表的堆内存起始地址。然后，我们可以用<code>rust-gdb/rust-lldb</code>来打印这个内存。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-cad3bc3699270d41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>9.2.1 Ctrl表</strong></p>
<p>一张<code>ctrl</code>表里，有若干个<code>128bit</code>或者说<code>16</code>个字节的分组（<code>group</code>），<code>group</code>里的每个字节叫<code>ctrl byte</code>，对应一个<code>bucket</code>，那么一个<code>group</code>对应<code>16</code>个<code>bucket</code>。如果一个<code>bucket</code>对应的<code>ctrl byte</code>首位不为<code>1</code>，就表示这个<code>ctrl byte</code>被使用；如果所有位都是<code>1</code>，或者说这个字节是 0xff，那么它是空闲的。</p>
<p>一组<code>control byte</code>的整个<code>128 bit</code> 的数据，可以通过一条指令被加载进来，然后和某个值进行<code>mask</code>，找到它所在的位置。这就是一开始提到的<code>SIMD</code>查表。</p>
<p>具体怎么操作，我们来看<code>HashMap</code>是如何通过<code>ctrl</code>表来进行数据查询的。假设这张表里已经添加了一些数据，我们现在要查找<code>key</code>为<code>c</code>的数据：</p>
<ol>
<li>首先对<code>c</code>做哈希，得到一个哈希值<code>h</code>；</li>
<li>把<code>h</code>跟<code>bucket_mask</code>做与，得到一个值，图中是<code>139</code>；</li>
<li>拿着这个<code>139</code>，找到对应的<code>ctrl group</code>的起始位置，因为<code>ctrl group</code>以<code>16</code>为一组，所以这里找到<code>128</code>；</li>
<li>用<code>SIMD</code>指令加载从<code>128</code>对应地址开始的<code>16</code>个字节；</li>
<li>对<code>hash</code>取头<code>7</code>个<code>bit</code>，然后和刚刚取出的<code>16</code>个字节一起做与，找到对应的匹配，如果找到了，它（们）很大概率是要找的值；</li>
<li>如果不是，那么以二次探查（以<code>16</code>的倍数不断累积）的方式往后查找，直到找到为止。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-d40cf768ac278e77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>所以，当<code>HashMap</code>插入和删除数据，以及因此导致重新分配的时候，主要工作就是在维护这张<code>ctrl</code>表和数据的对应。</p>
<p>因为<code>ctrl</code>表是所有操作最先触及的内存，所以在 <code>HashMap</code> 的结构中，堆内存的指针直接指向<code>ctrl</code>表，而不是指向堆内存的起始位置，这样可以减少一次内存的访问。</p>
<p><strong>9.2.2 哈希表重新分配与增长</strong></p>
<p>首先，哈希表会按幂扩容，从<code>4</code>个<code>bucket</code>扩展到<code>8</code>个<code>bucket</code>。</p>
<p>这会导致分配新的堆内存，然后原来的<code>ctrl table</code>和对应的<code>kv</code>数据会被移动到新的内存中。这个例子里因为<code>char</code>和 <code>i32</code>实现了<code>Copy trait</code>，所以是拷贝；如果<code>key</code>的类型是<code>String</code>，那么只有<code>String</code>的<code>24</code>个字节 (<code>ptr|cap|len</code>) 的结构被移动，<code>String</code>的实际内存不需要变动。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-607c75a01e0219d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="9-3、删除一个值"><a href="#9-3、删除一个值" class="headerlink" title="9.3、删除一个值"></a>9.3、删除一个值</h2><p>当要在哈希表中删除一个值时，整个过程和查找类似，先要找到要被删除的<code>key</code>所在的位置。在找到具体位置后，并不需要实际清除内存，只需要将它的<code>ctrl byte</code>设回 <code>0xff</code>（或者标记成删除状态）。这样，这个<code>bucket</code>就可以被再次使用了：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-b0b9f03a7fa666d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这里有一个问题，当<code>key/value</code>有额外的内存时，比如<code>String</code>，它的内存不会立即回收，只有在下一次对应的<code>bucket</code> 被使用时，让<code>HashMap</code>不再拥有这个<code>String</code>的所有权之后，这个<code>String</code>的内存才被回收。我们看下面的示意图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-8946f4e07a0c2725.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>一般来说，这并不会带来什么问题，顶多是内存占用率稍高一些。但某些极端情况下，比如在哈希表中添加大量内容，又删除大量内容后运行，这时你可以通过<code>shrink_to_fit/shrink_to</code> 释放掉不需要的内存。</p>
<h2 id="9-4、自定义-Hash-key"><a href="#9-4、自定义-Hash-key" class="headerlink" title="9.4、自定义 Hash key"></a>9.4、自定义 Hash key</h2><p>有时候，我们需要让自定义的数据结构成为<code>HashMap</code>的<code>key</code>。此时，要使用到三个<code> trait：Hash、PartialEq、Eq</code>，不过这三个<code>trait</code>都可以通过派生宏自动生成。其中：</p>
<ul>
<li>实现了<code>Hash</code>，可以让数据结构计算哈希；</li>
<li>实现了<code>PartialEq/Eq</code>，可以让数据结构进行相等和不相等的比较。<code>Eq</code>实现了比较的自反性（<code>a == a</code>）、对称性（<code>a == b</code>则<code>b == a</code>）以及传递性（<code>a == b</code>，<code>b == c</code>，则<code>a == c</code>），<code>PartialEq</code>没有实现自反性。</li>
</ul>
<p>Demo：</p>
<pre><code>use std::{
    collections::{hash_map::DefaultHasher, HashMap},
    hash::{Hash, Hasher},
};

// 如果要支持 Hash，可以用 #[derive(Hash)]，前提是每个字段都实现了 Hash
// 如果要能作为 HashMap 的 key，还需要 PartialEq 和 Eq
#[derive(Debug, Hash, PartialEq, Eq)]
struct Student&lt;'a&gt; {
    name: &amp;'a str,
    age: u8,
}

impl&lt;'a&gt; Student&lt;'a&gt; {
    pub fn new(name: &amp;'a str, age: u8) -&gt; Self {
        Self { name, age }
    }
}
fn main() {
    let mut hasher = DefaultHasher::new();
    let student = Student::new("Tyr", 18);
    // 实现了 Hash 的数据结构可以直接调用 hash 方法
    student.hash(&amp;mut hasher);
    let mut map = HashMap::new();
    // 实现了 Hash / PartialEq / Eq 的数据结构可以作为 HashMap 的 key
    map.insert(student, vec!["Math", "Writing"]);
    println!("hash: 0x{:x}, map: {:?}", hasher.finish(), map);
}
</code></pre>
<h2 id="9-5、HashSet-BTreeMap-BTreeSet"><a href="#9-5、HashSet-BTreeMap-BTreeSet" class="headerlink" title="9.5、HashSet/BTreeMap/BTreeSet"></a>9.5、HashSet/BTreeMap/BTreeSet</h2><p>有时我们只需要简单确认元素是否在集合中，如果用<code>HashMap</code>就有些浪费空间了。这时可以用<code>HashSet</code>，它就是简化的 <code>HashMap</code>，可以用来存放无序的集合，定义直接是<code>HashMap</code>：</p>
<pre><code>use hashbrown::hash_set as base;

pub struct HashSet&lt;T, S = RandomState&gt; {
    base: base::HashSet&lt;T, S&gt;,
}

pub struct HashSet&lt;T, S = DefaultHashBuilder, A: Allocator + Clone = Global&gt; {
    pub(crate) map: HashMap&lt;T, (), S, A&gt;,
}
</code></pre>
<p>另一个和<code>HashMap</code>一样常用的数据结构就是<code>BTreeMap</code> 了。<code>BTreeMap</code>是内部使用<code>B-tree</code>来组织哈希表的数据结构。另外<code>BTreeSet</code>和<code>HashSet</code>类似，是<code>BTreeMap</code>的简化版，可以用来存放有序集合。</p>
<pre><code>pub struct BTreeMap&lt;K, V&gt; {
    root: Option&lt;Root&lt;K, V&gt;&gt;,
    length: usize,
}

pub type Root&lt;K, V&gt; = NodeRef&lt;marker::Owned, K, V, marker::LeafOrInternal&gt;;

pub struct NodeRef&lt;BorrowType, K, V, Type&gt; {
    height: usize,
    node: NonNull&lt;LeafNode&lt;K, V&gt;&gt;,
    _marker: PhantomData&lt;(BorrowType, Type)&gt;,
}

struct LeafNode&lt;K, V&gt; {
    parent: Option&lt;NonNull&lt;InternalNode&lt;K, V&gt;&gt;&gt;,
    parent_idx: MaybeUninit&lt;u16&gt;,
    len: u16,
    keys: [MaybeUninit&lt;K&gt;; CAPACITY],
    vals: [MaybeUninit&lt;V&gt;; CAPACITY],
}

struct InternalNode&lt;K, V&gt; {
    data: LeafNode&lt;K, V&gt;,
    edges: [MaybeUninit&lt;BoxedNode&lt;K, V&gt;&gt;; 2 * B],
}
</code></pre>
<p>有序Demo：</p>
<pre><code>use std::collections::BTreeMap;

fn main() {
    let map = BTreeMap::new();
    let mut map = explain("empty", map);

    for i in 0..16usize {
        map.insert(format!("Tyr {}", i), i);
    }

    let mut map = explain("added", map);

    map.remove("Tyr 1");

    let map = explain("remove 1", map);

    for item in map.iter() {
        println!("{:?}", item);
    }
}

// BTreeMap 结构有 height，node 和 length
// 我们 transmute 打印之后，再 transmute 回去
fn explain&lt;K, V&gt;(name: &amp;str, map: BTreeMap&lt;K, V&gt;) -&gt; BTreeMap&lt;K, V&gt; {
    let arr: [usize; 3] = unsafe { std::mem::transmute(map) };
    println!(
        "{}: height: {}, root node: 0x{:x}, len: 0x{:x}",
        name, arr[0], arr[1], arr[2]
    );
    unsafe { std::mem::transmute(arr) }
}

// 输出
("Tyr 0", 0)
("Tyr 10", 10)
("Tyr 11", 11)
("Tyr 12", 12)
("Tyr 13", 13)
("Tyr 14", 14)
("Tyr 15", 15)
("Tyr 2", 2)
("Tyr 3", 3)
("Tyr 4", 4)
("Tyr 5", 5)
("Tyr 6", 6)
("Tyr 7", 7)
("Tyr 8", 8)
("Tyr 9", 9)
</code></pre>
<p>可以看到，在遍历时，<code>BTreeMap</code>会按照<code>key</code>的顺序把值打印出来。如果你想让自定义的数据结构可以作为<code>BTreeMap</code>的<code>key</code>，那么需要实现<code>PartialOrd</code>和<code>Ord</code>，这两者的关系和<code>PartialEq/Eq</code>类似，<code>PartialOrd</code>也没有实现自反性。同样的，<code>PartialOrd</code>和<code>Ord</code>也可以通过派生宏来实现。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-2609878b8984d0a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>9.5.1 为什么 Rust 的 HashMap 要缺省采用加密安全的哈希算法？</strong></p>
<p>我们知道哈希表在软件系统中的重要地位，但哈希表在最坏情况下，如果绝大多数<code>key</code>的<code>hash</code>都碰撞在一起，性能会到 <code>O(n)</code>，这会极大拖累系统的效率。</p>
<p>比如<code>1M</code>大小的<code>session</code>表，正常情况下查表速度是<code>O(1)</code>，但极端情况下，需要比较<code>1M</code>个数据后才能找到，这样的系统就容易被<code>DoS</code>攻击。所以如果不是加密安全的哈希函数，只要黑客知道哈希算法，就可以构造出大量的<code>key</code>产生足够多的哈希碰撞，造成目标系统<code>DoS</code>。</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SipHash">SipHash</a> 就是为了回应<code>DoS</code>攻击而创建的哈希算法，虽然和<code>sha2</code>这样的加密哈希不同（不要将<code>SipHash</code>用于加密！），但它可以提供类似等级的安全性。把<code>SipHash</code>作为 <code>HashMap</code>的缺省的哈希算法，<code>Rust</code>可以避免开发者在不知情的情况下被<code>DoS</code>，就像曾经在<code>Web</code>世界发生的那样。</p>
<p>当然，这一切的代价是性能损耗，虽然<code>SipHash</code>非常快，但它比<code>hashbrown</code>缺省使用的<code>Ahash</code>慢了不少。如果你确定使用的<code>HashMap</code>不需要<code>DoS</code>防护（比如一个完全内部使用的<code>HashMap</code>），那么可以用 <a target="_blank" rel="noopener" href="https://github.com/tkaitchuck/aHash">Ahash</a> 来替换。你只需要使用<code>Ahash</code>提供的<code>RandomState</code>即可：</p>
<h1 id="十、错误处理"><a href="#十、错误处理" class="headerlink" title="十、错误处理"></a>十、错误处理</h1><p><img src="https://upload-images.jianshu.io/upload_images/12321605-cf21e1b5a9880697.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误处理的主流方法.png"></p>
<!--[点我查看原图](./err.png)-->
<p><a target="_blank" rel="noopener" href="https://eq2dxlycqpe.feishu.cn/mindnotes/CLddbpWvCm4FXYnG03Ec8A26n1f#mindmap">脑图链接</a></p>
<h1 id="十一、闭包：FnOnce、FnMut、Fn"><a href="#十一、闭包：FnOnce、FnMut、Fn" class="headerlink" title="十一、闭包：FnOnce、FnMut、Fn"></a>十一、闭包：FnOnce、FnMut、Fn</h1><blockquote>
<p>闭包是将函数，或者说代码和其环境一起存储的一种数据结构。闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分（第二讲）。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-7ad9826f70293d9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>之前的课程中，多次见到了创建新线程的 <code>thread::spawn</code>，它的参数就是一个闭包：</p>
<pre><code>pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt; 
where
    F: FnOnce() -&gt; T,
    F: Send + 'static,
    T: Send + 'static,
</code></pre>
<p>仔细看这个接口：</p>
<ol>
<li><code>F: FnOnce() → T</code>，表明<code>F</code>是一个接受<code>0</code>个参数、返回<code>T</code>的闭包。</li>
<li><code>F: Send + 'static</code>，说明闭包<code>F</code>这个数据结构，需要静态生命周期或者拥有所有权，并且它还能被发送给另一个线程。</li>
<li><code>T: Send + 'static</code>，说明闭包<code>F</code>返回的数据结构<code>T</code>，需要静态生命周期或者拥有所有权，并且它还能被发送给另一个线程。</li>
</ol>
<h2 id="11-1、闭包本质上是什么？"><a href="#11-1、闭包本质上是什么？" class="headerlink" title="11.1、闭包本质上是什么？"></a>11.1、闭包本质上是什么？</h2><p>闭包是一种匿名类型，<strong>一旦声明，就会产生一个新的类型</strong>，但这个类型无法被其它地方使用。<strong>这个类型就像一个结构体，会包含所有捕获的变量</strong>。</p>
<pre><code>use std::{collections::HashMap, mem::size_of_val};
fn main() {
    // 长度为 0
    let c1 = || println!("hello world!");
    // 和参数无关，长度也为 0
    let c2 = |i: i32| println!("hello: {}", i);
    let name = String::from("tyr");
    let name1 = name.clone();
    let mut table = HashMap::new();
    table.insert("hello", "world");
    // 如果捕获一个引用，长度为 8
    let c3 = || println!("hello: {}", name);
    // 捕获移动的数据 name1(长度 24) + table(长度 48)，closure 长度 72
    let c4 = move || println!("hello: {}, {:?}", name1, table);
    let name2 = name.clone();
    // 和局部变量无关，捕获了一个 String name2，closure 长度 24
    let c5 = move || {
        let x = 1;
        let name3 = String::from("lindsey");
        println!("hello: {}, {:?}, {:?}", x, name2, name3);
    };

    println!(
        "c1: {}, c2: {}, c3: {}, c4: {}, c5: {}, main: {}",
        size_of_val(&amp;c1),
        size_of_val(&amp;c2),
        size_of_val(&amp;c3),
        size_of_val(&amp;c4),
        size_of_val(&amp;c5),
        size_of_val(&amp;main),
    )
}
</code></pre>
<ul>
<li><code>c1</code>没有参数，也没捕获任何变量，从代码输出可以看到，<code>c1</code>长度为<code>0</code>；</li>
<li><code>c2</code>有一个<code>i32</code>作为参数，没有捕获任何变量，长度也为<code>0</code>，可以看出参数跟闭包的大小无关；</li>
<li><code>c3</code>捕获了一个对变量<code>name</code>的引用，这个引用是<code>&amp;String</code>，长度为<code>8</code>。而<code>c3</code>的长度也是<code>8</code>；</li>
<li><code>c4</code>捕获了变量<code>name1</code>和<code>table</code>，由于用了<code>move</code>，它们的所有权移动到了<code>c4</code>中。<code>c4</code>长度是<code>72</code>，恰好等于 <code>String</code>的<code>24</code>字节，加上<code>HashMap</code>的<code>48</code>字节。</li>
<li><code>c5</code>捕获了<code>name2</code>，<code>name2</code>的所有权移动到了<code>c5</code>，虽然<code>c5</code>有局部变量，但它的大小和局部变量也无关，<code>c5</code>的大小等于<code>String</code>的<code>24</code>字节。</li>
</ul>
<p><strong>加 move 和不加 move，这两种闭包有什么本质上的不同？</strong></p>
<p>可以看到，不带<code>move</code>时，闭包捕获的是对应自由变量的引用；<br>带<code>move</code>时，对应自由变量的所有权会被移动到闭包结构中。</p>
<p><strong>还知道了，闭包的大小跟参数、局部变量都无关，只跟捕获的变量有关。</strong></p>
<p>而<code>c4</code>捕获的<code>name</code>和<code>table</code>，内存结构和下面的结构体一模一样：</p>
<pre><code>struct Closure4 {
    name: String,  // (ptr|cap|len)=24字节
    table: HashMap&lt;&amp;str, &amp;str&gt; // (RandomState(16)|mask|ctrl|left|len)=48字节
}
</code></pre>
<p>不过，对于<code>closure</code>类型来说，编译器知道像函数一样调用闭包<code>c4()</code>是合法的，并且知道执行<code>c4()</code>时，代码应该跳转到什么地址来执行。在执行过程中，如果遇到<code>name</code>、<code>table</code>，可以从自己的数据结构中获取。</p>
<p>那么多想一步，闭包捕获变量的顺序，和其内存结构的顺序是一致的么？的确如此，如果我们调整闭包里使用<code>name1</code>和<code>table</code>的顺序：</p>
<pre><code>let c4 = move || println!("hello: {:?}, {}", table, name1);
</code></pre>
<p>其数据的位置是相反的，类似于：</p>
<pre><code>struct Closure4 {
    table: HashMap&lt;&amp;str, &amp;str&gt; // (RandomState(16)|mask|ctrl|left|len)=48字节
    name: String,  // (ptr|cap|len)=24字节
}
</code></pre>
<p>不过这只是逻辑上的位置，<code>struct</code>在内存的排布，Rust 编译器会重排内存，让数据能够以最小的代价对齐，所以有些情况下，内存中数据的顺序可能和<code>struct</code>定义不一致。</p>
<p>所以回到刚才闭包和结构体的比较。在<code>Rust</code>里，闭包产生的匿名数据类型，格式和<code>struct</code>是一样的。看图中<code>gdb</code>的输出，闭包是存储在栈上，并且除了捕获的数据外，闭包本身不包含任何额外函数指针指向闭包的代码。如果理解了<code>c3/c4</code> 这两个闭包，<code>c5</code>是如何构造的就很好理解了。</p>
<p>现在，你是不是可以回答为什么<code>thread::spawn</code>对传入的闭包约束是<code>Send + 'static</code>了？究竟什么样的闭包满足它呢？很明显，使用了<code>move</code>且<code>move</code>到闭包内的数据结构满足<code>Send</code>，因为此时，闭包的数据结构拥有所有数据的所有权，它的生命周期是<code>'static</code>。</p>
<p><strong>11.1.1 不同语言的闭包设计</strong></p>
<p>闭包最大的问题是变量的多重引用导致生命周期不明确，所以你先想，其它支持闭包的语言（<code>lambda</code> 也是闭包），它们的闭包会放在哪里？</p>
<p>因为闭包这玩意，从当前上下文中捕获了些变量，变得有点不伦不类，不像函数那样清楚，尤其是这些被捕获的变量，它们的归属和生命周期处理起来很麻烦。所以，大部分编程语言的闭包很多时候无法放在栈上，需要额外的堆分配。你可以看这个 Golang 的例子。</p>
<p>不光<code>Golang</code>，<code>Java/Swift/Python/JavaScript</code> 等语言都是如此，这也是为什么大多数编程语言闭包的性能要远低于函数调用。因为使用闭包就意味着：<strong>额外的堆内存分配、潜在的动态分派（很多语言会把闭包处理成函数指针）、额外的内存回收。</strong></p>
<p>在其他语言中，闭包变量因为多重引用导致生命周期不明确，但<code>Rust</code>从一开始就消灭了这个问题：</p>
<ul>
<li>如果不使用<code>move</code>转移所有权，闭包会引用上下文中的变量，这个引用受借用规则的约束，所以只要编译通过，那么闭包对变量的引用就不会超过变量的生命周期，没有内存安全问题。</li>
<li>如果使用<code>move</code>转移所有权，上下文中的变量在转移后就无法访问，闭包完全接管这些变量，它们的生命周期和闭包一致，所以也不会有内存安全问题。</li>
</ul>
<p>而<code>Rust</code>为每个闭包生成一个新的类型，又使得调用闭包时可以直接和代码对应，省去了使用函数指针再转一道手的额外消耗。</p>
<h2 id="11-2、FnOnce"><a href="#11-2、FnOnce" class="headerlink" title="11.2、FnOnce"></a>11.2、FnOnce</h2><p>定义：</p>
<pre><code>pub trait FnOnce&lt;Args&gt; {
    type Output;
    extern "rust-call" fn call_once(self, args: Args) -&gt; Self::Output;
}
</code></pre>
<p><code>FnOnce</code>有一个关联类型<code>Output</code>，显然，它是闭包返回值的类型；还有一个方法<code>call_once</code>，要注意的是 <code>call_once</code>第一个参数是<code>self</code>，它会转移<code>self</code>的所有权到<code>call_once</code>函数中。</p>
<p>这也是为什么<code>FnOnce</code>被称作<code>Once</code> ：<strong>它只能被调用一次</strong>。再次调用，编译器就会报变量已经被<code>move</code>这样的常见所有权错误了。</p>
<pre><code>fn main() {
    let name = String::from("Tyr");
    // 这个闭包啥也不干，只是把捕获的参数返回去
    let c = move |greeting: String| (greeting, name);

    let result = c("hello".to_string());

    println!("result: {:?}", result);

    // 无法再次调用
    let result = c("hi".to_string());
}
</code></pre>
<p>这个闭包<code>c</code>，啥也没做，只是把捕获的参数返回。就像一个结构体里，某个字段被转移走之后，就不能再访问一样，闭包内部的数据一旦被转移，这个闭包就不完整了，也就无法再次使用，所以它是一个<code>FnOnce</code>的闭包。</p>
<p>如果一个闭包并不转移自己的内部数据，那么它就不是<code>FnOnce</code>，然而，一旦它被当做<code>FnOnce</code>调用，自己会被转移到<code>call_once</code>函数的作用域中，之后就无法再次调用了，我们看个例子（代码）：</p>
<pre><code>fn main() {
    let name = String::from("Tyr");

    // 这个闭包会 clone 内部的数据返回，所以它不是 FnOnce
    let c = move |greeting: String| (greeting, name.clone());

    // 所以 c1 可以被调用多次

    println!("c1 call once: {:?}", c("qiao".into()));
    println!("c1 call twice: {:?}", c("bonjour".into()));

    // 然而一旦它被当成 FnOnce 被调用，就无法被再次调用
    println!("result: {:?}", call_once("hi".into(), c));

    // 无法再次调用
    // let result = c("hi".to_string());

    // Fn 也可以被当成 FnOnce 调用，只要接口一致就可以
    println!("result: {:?}", call_once("hola".into(), not_closure));
}

fn call_once(arg: String, c: impl FnOnce(String) -&gt; (String, String)) -&gt; (String, String) {
    c(arg)
}

fn not_closure(arg: String) -&gt; (String, String) {
    (arg, "Rosie".into())
}
</code></pre>
<h2 id="11-3、FnMut"><a href="#11-3、FnMut" class="headerlink" title="11.3、FnMut"></a>11.3、FnMut</h2><p>理解了<code>FnOnce</code>，我们再来看<code>FnMut</code>，它的定义如下：</p>
<pre><code>pub trait FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; {
    extern "rust-call" fn call_mut(
        &amp;mut self, 
        args: Args
    ) -&gt; Self::Output;
}
 
</code></pre>
<p>首先，<code>FnMut</code>“继承”了<code>FnOnce</code>，或者说<code>FnOnce</code>是<code>FnMut</code>的<code>super trait</code>。所以<code>FnMut</code>也拥有<code>Output</code>这个关联类型和<code>call_once</code>这个方法。此外，它还有一个<code>call_mut()</code>方法。注意<code>call_mut()</code>传入<code>&amp;mut self</code>，它不移动<code>self</code>，所以<code>FnMut</code>可以被多次调用。</p>
<p>因为<code>FnOnce</code>是<code>FnMut</code>的<code>super trait</code>，所以，一个<code>FnMut</code>闭包，可以被传给一个需要<code>FnOnce</code>的上下文，此时调用闭包相当于调用了<code>call_once()</code>。</p>
<p>如果你理解了前面讲的闭包的内存组织结构，那么<code>FnMut</code>就不难理解，就像结构体如果想改变数据需要用<code>let mut</code>声明一样，如果你想改变闭包捕获的数据结构，那么就需要<code>FnMut</code>。我们看个例子（代码）： </p>
<pre><code>fn main() {
    let mut name = String::from("hello");
    let mut name1 = String::from("hola");

    // 捕获 &amp;mut name
    let mut c = || {
        name.push_str(" Tyr");
        println!("c: {}", name);
    };

    // 捕获 mut name1，注意 name1 需要声明成 mut
    let mut c1 = move || {
        name1.push_str("!");
        println!("c1: {}", name1);
    };

    c();
    c1();

    call_mut(&amp;mut c);
    call_mut(&amp;mut c1);

    call_once(c);
    call_once(c1);
}

// 在作为参数时，FnMut 也要显式地使用 mut，或者 &amp;mut
fn call_mut(c: &amp;mut impl FnMut()) {
    c();
}

// 想想看，为啥 call_once 不需要 mut？
fn call_once(c: impl FnOnce()) {
    c();
}
</code></pre>
<p>在声明的闭包<code>c</code>和<code>c1</code>里，我们修改了捕获的<code>name</code>和<code>name1</code>。不同的是<code>name</code>使用了引用，而<code>name1</code>移动了所有权，这两种情况和其它代码一样，也需要遵循所有权和借用有关的规则。所以，如果在闭包<code>c</code>里借用了<code>name</code>，你就不能把<code>name</code>移动给另一个闭包<code>c1</code>。</p>
<p>这里也展示了，<code>c</code>和<code>c1</code>这两个符合<code>FnMut</code>的闭包，能作为<code>FnOnce</code>来调用。我们在代码中也确认了，<code>FnMut</code>可以被多次调用，这是因为<code>call_mut()</code>使用的是<code>&amp;mut self</code>，不移动所有权。</p>
<h2 id="11-4、Fn"><a href="#11-4、Fn" class="headerlink" title="11.4、Fn"></a>11.4、Fn</h2><pre><code>pub trait Fn&lt;Args&gt;: FnMut&lt;Args&gt; {
    extern "rust-call" fn call(&amp;self, args: Args) -&gt; Self::Output;
}
</code></pre>
<p>可以看到，它“继承”了<code>FnMut</code>，或者说<code>FnMut</code>是<code>Fn</code>的<code>super trait</code>。这也就意味着任何需要<code>FnOnce</code>或者<code>FnMut</code>的场合，都可以传入满足<code>Fn</code>的闭包。我们继续看例子（代码）：</p>
<pre><code>fn main() {
    let v = vec![0u8; 1024];
    let v1 = vec![0u8; 1023];

    // Fn，不移动所有权
    let mut c = |x: u64| v.len() as u64 * x;
    // Fn，移动所有权
    let mut c1 = move |x: u64| v1.len() as u64 * x;

    println!("direct call: {}", c(2));
    println!("direct call: {}", c1(2));

    println!("call: {}", call(3, &amp;c));
    println!("call: {}", call(3, &amp;c1));

    println!("call_mut: {}", call_mut(4, &amp;mut c));
    println!("call_mut: {}", call_mut(4, &amp;mut c1));

    println!("call_once: {}", call_once(5, c));
    println!("call_once: {}", call_once(5, c1));
}

fn call(arg: u64, c: &amp;impl Fn(u64) -&gt; u64) -&gt; u64 {
    c(arg)
}

fn call_mut(arg: u64, c: &amp;mut impl FnMut(u64) -&gt; u64) -&gt; u64 {
    c(arg)
}

fn call_once(arg: u64, c: impl FnOnce(u64) -&gt; u64) -&gt; u64 {
    c(arg)
}
</code></pre>
<h2 id="11-5、闭包的使用场景"><a href="#11-5、闭包的使用场景" class="headerlink" title="11.5、闭包的使用场景"></a>11.5、闭包的使用场景</h2><pre><code>fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;
where
    Self: Sized,
    F: FnMut(Self::Item) -&gt; B,
{
    Map::new(self, f)
}
</code></pre>
<p>可以看到，<code>Iterator</code>的<code>map()</code>方法接受一个<code>FnMut</code>，它的参数是<code>Self::Item</code>，返回值是没有约束的泛型参数 <code>B</code>。<code>Self::Item</code>是<code>Iterator::next()</code>方法吐出来的数据，被<code>map</code>之后，可以得到另一个结果。</p>
<pre><code>use std::ops::Mul;

fn main() {
    let c1 = curry(5);
    println!("5 multiply 2 is: {}", c1(2));

    let adder2 = curry(3.14);
    println!("pi multiply 4^2 is: {}", adder2(4. * 4.));
}

fn curry&lt;T&gt;(x: T) -&gt; impl Fn(T) -&gt; T
where
    T: Mul&lt;Output = T&gt; + Copy,
{
    move |y| x * y
}
</code></pre>
<p>最后，闭包还有一种并不少见，但可能不太容易理解的用法：为它实现某个<code>trait</code>，使其也能表现出其他行为，而不仅仅是作为函数被调用。比如说有些接口既可以传入一个结构体，又可以传入一个函数或者闭包。</p>
<p>我们看一个<code>tonic</code>（<code>Rust</code>下的<code>gRPC</code>库）的例子：</p>
<pre><code>pub trait Interceptor {
    /// Intercept a request before it is sent, optionally cancelling it.
    fn call(&amp;mut self, request: crate::Request&lt;()&gt;) -&gt; Result&lt;crate::Request&lt;()&gt;, Status&gt;;
}

impl&lt;F&gt; Interceptor for F
where
    F: FnMut(crate::Request&lt;()&gt;) -&gt; Result&lt;crate::Request&lt;()&gt;, Status&gt;,
{
    fn call(&amp;mut self, request: crate::Request&lt;()&gt;) -&gt; Result&lt;crate::Request&lt;()&gt;, Status&gt; {
        self(request)
    }
}
</code></pre>
<blockquote>
<p>self是谁？ self指代的是F。F是闭包，本质上是特殊的结构体。 他有自己的域， 一个是从外面捕获的变量作为域 一个是自己的局部变量作为域 将request传递进去，也就是从外部捕捉的变量作为域。 通过闭包本身的关联函数，将这些域的值给计算返回一个Result结果 那么看上去就是位闭包实现一个trait 这样trait本身的行为就可以通过闭包来调用他自己的方法，将本身的行为也就是方法给改写成另外一种了。也就是做和说的表现出其他行为。这个其他行为就是通过闭包调用他本身的函数而改写后的行为。</p>
</blockquote>
<p>在这个例子里，<code>Interceptor</code>有一个<code>call</code>方法，它可以让<code>gRPC Request</code>被发送出去之前被修改，一般是添加各种头，比如<code>Authorization</code>头。</p>
<p><strong>11.5.1 小结</strong></p>
<p><code>Rust</code>闭包的效率非常高。首先闭包捕获的变量，都储存在栈上，没有堆内存分配。其次因为闭包在创建时会隐式地创建自己的类型，每个闭包都是一个新的类型。通过闭包自己唯一的类型，Rust 不需要额外的函数指针来运行闭包，所以闭包的调用效率和函数调用几乎一致。</p>
<p><code>Rust</code>支持三种不同的闭包<code>trait</code>：<code>FnOnce</code>、<code>FnMut</code>和<code>Fn</code>。<code>FnOnce</code>是<code>FnMut</code>的<code>super trait</code>，而<code>FnMut</code>又是<code>Fn</code>的<code>super trait</code>。从这些<code>trait</code>的接口可以看出，</p>
<ul>
<li><code>FnOnce</code>只能调用一次；</li>
<li><code>FnMut</code>允许在执行时修改闭包的内部数据，可以执行多次；</li>
<li><code>Fn</code>不允许修改闭包的内部数据，也可以执行多次。</li>
</ul>
<p>总结一下三种闭包使用的情况以及它们之间的关系：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-a1335c3b1d20a8e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="十二、unsafe"><a href="#十二、unsafe" class="headerlink" title="十二、unsafe"></a>十二、unsafe</h1><h2 id="12-1-unsafe-trait"><a href="#12-1-unsafe-trait" class="headerlink" title="12.1 unsafe trait"></a>12.1 unsafe trait</h2><p><code>Rust</code>里，名气最大的<code>unsafe</code>代码应该就是<code>Send/Sync</code>这两个<code>trait</code>了：</p>
<pre><code>pub unsafe auto trait Send {}
pub unsafe auto trait Sync {}
</code></pre>
<p>因为<code>Send/Sync</code>是<code>auto trait</code>，所以大部分情况下，你自己的数据结构不需要实现<code>Send/Sync</code>，然而，当你在数据结构里使用裸指针时，<strong>因为裸指针是没有实现 Send/Sync 的，连带着你的数据结构也就没有实现 Send/Sync</strong>。但很可能你的结构是线程安全的，你也需要它线程安全。</p>
<p>此时，如果你可以保证它能在线程中安全地移动，那可以实现<code>Send</code>；如果可以保证它能在线程中安全地共享，也可以去实现<code>Sync</code>。之前我们讨论过的<code>Bytes</code>就在使用裸指针的情况下实现了<code>Send/Sync</code>：</p>
<pre><code>pub struct Bytes {
    ptr: *const u8,
    len: usize,
    // inlined "trait object"
    data: AtomicPtr&lt;()&gt;,
    vtable: &amp;'static Vtable,
}

// Vtable must enforce this behavior
unsafe impl Send for Bytes {}
unsafe impl Sync for Bytes {}
</code></pre>
<p>但是，在实现 Send/Sync 的时候要特别小心，<strong>如果你无法保证数据结构的线程安全，错误实现 Send/Sync 之后，会导致程序出现莫名其妙的还不太容易复现的崩溃</strong>。</p>
<p>比如下面的代码，强行为<code>Evil</code>实现了<code>Send</code>，而<code>Evil</code>内部携带的<code>Rc</code>是不允许实现<code>Send</code>的。这段代码通过实现<code>Send</code>而规避了<code>Rust</code>的并发安全检查，使其可以编译通过（代码）：</p>
<pre><code>use std::{cell::RefCell, rc::Rc, thread};

#[derive(Debug, Default, Clone)]
struct Evil {
    data: Rc&lt;RefCell&lt;usize&gt;&gt;,
}

// 为 Evil 强行实现 Send，这会让 Rc 整个紊乱
unsafe impl Send for Evil {}

fn main() {
    let v = Evil::default();
    let v1 = v.clone();
    let v2 = v.clone();

    let t1 = thread::spawn(move || {
        let v3 = v.clone();
        let mut data = v3.data.borrow_mut();
        *data += 1;
        println!("v3: {:?}", data);
    });

    let t2 = thread::spawn(move || {
        let v4 = v1.clone();
        let mut data = v4.data.borrow_mut();
        *data += 1;
        println!("v4: {:?}", data);
    });

    t2.join().unwrap();
    t1.join().unwrap();

    let mut data = v2.data.borrow_mut();
    *data += 1;

    println!("v2: {:?}", data);
}
</code></pre>
<p>任何<code>trait</code>，只要声明成<code>unsafe</code>，它就是一个<code>unsafe trait</code>。而一个正常的<code>trait</code>里也可以包含<code>unsafe</code>函数，我们看下面的示例（代码）：</p>
<pre><code>// 实现这个 trait 的开发者要保证实现是内存安全的
unsafe trait Foo {
    fn foo(&amp;self);
}

trait Bar {
    // 调用这个函数的人要保证调用是安全的
    unsafe fn bar(&amp;self);
}

struct Nonsense;

unsafe impl Foo for Nonsense {
    fn foo(&amp;self) {
        println!("foo!");
    }
}

impl Bar for Nonsense {
    unsafe fn bar(&amp;self) {
        println!("bar!");
        }
    }
    
    fn main() {
        let nonsense = Nonsense;
        // 调用者无需关心 safety
        nonsense.foo();
    
        // 调用者需要为 safety 负责
        unsafe { nonsense.bar() };
    }
</code></pre>
<p><code>unsafe trait</code>是对<code>trait</code>的实现者的约束，它告诉<code>trait</code>的实现者：实现我的时候要小心，要保证内存安全，所以实现的时候需要加<code>unsafe</code>关键字。</p>
<p>但<code>unsafe trait</code>对于调用者来说，可以正常调用，不需要任何<code>unsafe block</code>，因为这里的<code>safety</code>已经被实现者保证了，毕竟如果实现者没保证，调用者也做不了什么来保证<code>safety</code>，就像我们使用<code>Send/Sync</code>一样。</p>
<p>而<code>unsafe fn</code>是函数对调用者的约束，它告诉函数的调用者：如果你胡乱使用我，会带来内存安全方面的问题，请妥善使用，所以调用<code>unsafe fn</code>时，需要加<code>unsafe block</code>提醒别人注意。</p>
<p>再来看一个实现和调用都是<code>unsafe</code>的<code>trait：GlobalAlloc</code>。</p>
<pre><code>use std::alloc::{GlobalAlloc, Layout, System};

struct MyAllocator;

unsafe impl GlobalAlloc for MyAllocator {
    unsafe fn alloc(&amp;self, layout: Layout) -&gt; *mut u8 {
        let data = System.alloc(layout);
        eprintln!("ALLOC: {:p}, size {}", data, layout.size());
        data
    }

    unsafe fn dealloc(&amp;self, ptr: *mut u8, layout: Layout) {
        System.dealloc(ptr, layout);
        eprintln!("FREE: {:p}, size {}", ptr, layout.size());
    }
}

#[global_allocator]
static GLOBAL: MyAllocator = MyAllocator;
</code></pre>
<h2 id="12-2、unsafe-函数"><a href="#12-2、unsafe-函数" class="headerlink" title="12.2、unsafe 函数"></a>12.2、unsafe 函数</h2><pre><code>use std::collections::HashMap;

fn main() {
    let map = HashMap::new();
    let mut map = explain("empty", map);

    map.insert(String::from("a"), 1);
    explain("added 1", map);
}

// HashMap 结构有两个 u64 的 RandomState，然后是四个 usize，
// 分别是 bucket_mask, ctrl, growth_left 和 items
// 我们 transmute 打印之后，再 transmute 回去
fn explain&lt;K, V&gt;(name: &amp;str, map: HashMap&lt;K, V&gt;) -&gt; HashMap&lt;K, V&gt; {
    let arr: [usize; 6] = unsafe { std::mem::transmute(map) };
    println!(
        "{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}",
        name, arr[2], arr[3], arr[4], arr[5]
    );

    // 因为 std:mem::transmute 是一个 unsafe 函数，所以我们需要 unsafe
    unsafe { std::mem::transmute(arr) }
}
</code></pre>
<p>要调用一个<code>unsafe</code>函数，你需要使用<code>unsafe block</code>把它包裹起来。这相当于在提醒大家，注意啊，这里有<code>unsafe</code> 代码！</p>
<p>另一种调用<code>unsafe</code>函数的方法是定义<code>unsafe fn</code>，然后在这个<code>unsafe fn</code>里调用其它<code>unsafe fn</code>。</p>
<pre><code>// safe 版本，验证合法性，如果不合法返回错误
pub fn from_utf8(v: &amp;[u8]) -&gt; Result&lt;&amp;str, Utf8Error&gt; {
    run_utf8_validation(v)?;
    // SAFETY: Just ran validation.
    Ok(unsafe { from_utf8_unchecked(v) })
}

// 不验证合法性，调用者需要确保 &amp;[u8] 里都是合法的字符
pub const unsafe fn from_utf8_unchecked(v: &amp;[u8]) -&gt; &amp;str {
    // SAFETY: the caller must guarantee that the bytes `v` are valid UTF-8.
    // Also relies on `&amp;str` and `&amp;[u8]` having the same layout.
    unsafe { mem::transmute(v) }
}
</code></pre>
<h2 id="12-3-对裸指针解引用"><a href="#12-3-对裸指针解引用" class="headerlink" title="12.3 对裸指针解引用"></a>12.3 对裸指针解引用</h2><p>裸指针在生成的时候无需<code>unsafe</code>，因为它并没有内存不安全的操作，但裸指针的解引用操作是不安全的，潜在有风险，它也需要使用<code>unsafe</code>来明确告诉编译器，以及代码的阅读者，也就是说要使用<code>unsafe block</code>包裹起来。</p>
<pre><code>fn main() {
    // let r1 = 0x123 as *mut u32;
    // unsafe { *r1 += 1; } // panic
    
    let mut age = 18;
    // 不可变指针
    let r1 = &amp;age as *const i32;
    // 可变指针
    let r2 = &amp;mut age as *mut i32;
    // 使用裸指针，可以绕过 immutable / mutable borrow rule
    // 然而，对指针解引用需要使用 unsafe
    unsafe {
        println!("r1: {}, r2: {}", *r1, *r2);
        *r2 = 10;
    }
    println!("{}", age); // 10
}
</code></pre>
<p>我们可以看到，使用裸指针，可变指针和不可变指针可以共存，不像可变引用和不可变引用无法共存。这是因为裸指针的任何对内存的操作，无论是<code>ptr::read/ptr::write</code>，还是解引用，都是<code>unsafe</code>的操作，所以只要读写内存，裸指针的使用者就需要对内存安全负责。</p>
<h2 id="12-4-FFI"><a href="#12-4-FFI" class="headerlink" title="12.4 FFI"></a>12.4 FFI</h2><p><code>FFI</code> ：<code>Foreign Function Interface</code>/语言交互接口。</p>
<p>当<code>Rust</code>要使用其它语言的能力时，<code>Rust</code>编译器并不能保证那些语言具备内存安全，所以和第三方语言交互的接口，一律要使用<code>unsafe</code>，比如，我们调用<code>libc</code>来进行<code>C</code>语言开发者熟知的<code>malloc/free</code>（代码）：</p>
<pre><code>use std::mem::transmute;

fn main() {
    let data = unsafe {
        let p = libc::malloc(8);
        let arr: &amp;mut [u8; 8] = transmute(p);
        arr
    };

    data.copy_from_slice(&amp;[1, 2, 3, 4, 5, 6, 7, 8]);

    println!("data: {:?}", data);

    unsafe { libc::free(transmute(data)) };
}
</code></pre>
<p><strong>12.4.1 FFI Demo</strong></p>
<pre><code>[dependencies]
anyhow = "1"

[build-dependencies]
bindgen = "0.59"
</code></pre>
<p>其中<code>bindgen</code>需要在编译期使用， 所以我们在根目录下创建一个<code>build.rs</code>使其在编译期运行：</p>
<pre><code>fn main() {
    // 告诉 rustc 需要 link bzip2
    println!("cargo:rustc-link-lib=bz2");

    // 告诉 cargo 当 wrapper.h 变化时重新运行
    println!("cargo:rerun-if-changed=wrapper.h");

    // 配置 bindgen，并生成 Bindings 结构
    let bindings = bindgen::Builder::default()
        .header("wrapper.h")
        .parse_callbacks(Box::new(bindgen::CargoCallbacks))
        .generate()
        .expect("Unable to generate bindings");

    // 生成 Rust 代码
    bindings
        .write_to_file("src/bindings.rs")
        .expect("Failed to write bindings");
}
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-6fb2ec47bd3308c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="12-5-不推荐-unsafe-的场景"><a href="#12-5-不推荐-unsafe-的场景" class="headerlink" title="12.5 不推荐 unsafe 的场景"></a>12.5 不推荐 unsafe 的场景</h2><p><strong>12.5.1 访问或者修改可变静态变量</strong></p>
<pre><code>use std::thread;

static mut COUNTER: usize = 1;

fn main() {
    let t1 = thread::spawn(move || {
        unsafe { COUNTER += 10 };
    });

    let t2 = thread::spawn(move || {
        unsafe { COUNTER *= 10 };
    });

    t2.join().unwrap();
    t1.join().unwrap();

    unsafe { println!("COUNTER: {}", COUNTER) };
}
</code></pre>
<p>可以用<code>Atomic</code>来替代</p>
<pre><code>use std::{
    sync::atomic::{AtomicUsize, Ordering},
    thread,
};

static COUNTER: AtomicUsize = AtomicUsize::new(1);

fn main() {
    let t1 = thread::spawn(move || {
        COUNTER.fetch_add(10, Ordering::SeqCst);
    });

    let t2 = thread::spawn(move || {
        COUNTER
            .fetch_update(Ordering::SeqCst, Ordering::SeqCst, |v| Some(v * 10))
            .unwrap();
    });

    t2.join().unwrap();
    t1.join().unwrap();

    println!("COUNTER: {}", COUNTER.load(Ordering::Relaxed));
}
</code></pre>
<p><strong>12.5.2 在宏里使用 unsafe</strong></p>
<p>首先使用你的宏的开发者，可能压根不知道<code>unsafe</code>代码的存在；其次，含有<code>unsafe</code>代码的宏在被使用到的时候，相当于把<code>unsafe</code>代码注入到当前上下文中。在不知情的情况下，开发者到处调用这样的宏，会导致<code>unsafe</code>代码充斥在系统的各个角落，不好处理；最后，一旦<code>unsafe</code>代码出现问题，你可能都很难找到问题的根本原因。</p>
<pre><code>// Generate implementation for dyn $name
macro_rules! downcast_dyn {
    ($name:ident) =&gt; {
        /// A struct with a private constructor, for use with
        /// `__private_get_type_id__`. Its single field is private,
        /// ensuring that it can only be constructed from this module
        #[doc(hidden)]
        #[allow(dead_code)]
        pub struct PrivateHelper(());

        impl dyn $name + 'static {
            /// Downcasts generic body to a specific type.
            #[allow(dead_code)]
            pub fn downcast_ref&lt;T: $name + 'static&gt;(&amp;self) -&gt; Option&lt;&amp;T&gt; {
                if self.__private_get_type_id__(PrivateHelper(())).0
                    == std::any::TypeId::of::&lt;T&gt;()
                {
                    // SAFETY: external crates cannot override the default
                    // implementation of `__private_get_type_id__`, since
                    // it requires returning a private type. We can therefore
                    // rely on the returned `TypeId`, which ensures that this
                    // case is correct.
                    unsafe { Some(&amp;*(self as *const dyn $name as *const T)) }
                } else {
                    None
                }
            }

            /// Downcasts a generic body to a mutable specific type.
            #[allow(dead_code)]
            pub fn downcast_mut&lt;T: $name + 'static&gt;(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
                if self.__private_get_type_id__(PrivateHelper(())).0
                    == std::any::TypeId::of::&lt;T&gt;()
                {
                    // SAFETY: external crates cannot override the default
                    // implementation of `__private_get_type_id__`, since
                    // it requires returning a private type. We can therefore
                    // rely on the returned `TypeId`, which ensures that this
                    // case is correct.
                    unsafe { Some(&amp;mut *(self as *const dyn $name as *const T as *mut T)) }
                } else {
                    None
                }
            }
        }
    };
}
</code></pre>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="1、Rust-特点"><a href="#1、Rust-特点" class="headerlink" title="1、Rust 特点"></a>1、Rust 特点</h2><ul>
<li><code>Rust</code>的变量默认是不可变的，如果要修改变量的值，需要显式地使用<code>mut</code>关键字。</li>
<li>除了<code>let/static/const/fn</code>等少数语句外，<code>Rust</code>绝大多数代码都是表达式（<code>expression</code>）。所以 <code>if/while/for/loop</code>都会返回一个值，函数最后一个表达式就是函数的返回值，这和函数式编程语言一致。</li>
<li><code>Rust</code>支持面向接口编程和泛型编程。</li>
<li><code>Rust</code>有非常丰富的数据类型和强大的标准库。</li>
<li><code>Rust</code>有非常丰富的控制流程，包括模式匹配（<code>pattern match</code>）。</li>
</ul>
<h2 id="2、基本语法和基础数据类型"><a href="#2、基本语法和基础数据类型" class="headerlink" title="2、基本语法和基础数据类型"></a>2、基本语法和基础数据类型</h2><p><strong>变量和函数</strong></p>
<p>前面说到，<code>Rust</code>支持类型推导，在编译器能够推导类型的情况下，变量类型一般可以省略，但常量（<code>const</code>）和静态变量（<code>static</code>）必须声明类型。</p>
<p>定义变量的时候，根据需要，你可以添加<code>mut</code>关键字让变量具备可变性。默认变量不可变是一个很重要的特性，它符合最小权限原则（<code>Principle of Least Privilege</code>），有助于我们写出健壮且正确的代码。当你使用<code>mut</code>却没有修改变量，Rust 编译期会友好地报警，提示你移除不必要的 mut。</p>
<p><strong>函数是一等公民，可以作为参数或者返回值。</strong></p>
<pre><code>fn apply(value: i32, f: fn(i32) -&gt; i32) -&gt; i32 {
    f(value)
}

fn square(value: i32) -&gt; i32 {
    value * value
}

fn cube(value: i32) -&gt; i32 {
    value * value * value
}

fn main() {
    println!("apply square: {}", apply(2, square));
    println!("apply cube: {}", apply(2, cube));
}
</code></pre>
<p><strong>数据结构</strong></p>
<p>数据结构是程序的核心组成部分，在对复杂的问题进行建模时，我们就要自定义数据结构。<code>Rust</code>非常强大，可以用 <code>struct</code>定义结构体，用<code>enum</code>定义标签联合体（<code>tagged union</code>），还可以像<code>Python</code>一样随手定义元组（<code>tuple</code>）类型。</p>
<pre><code>#[derive(Debug)]
enum Gender {
  Unspecified = 0,
  Female = 1,
  Male = 2,
}

// UserId/TopicId ：struct 的特殊形式，称为元组结构体。它的域都是匿名的，可以用索引访问，适用于简单的结构体。
#[derive(Debug, Copy, Clone)]
struct UserId(u64);

#[derive(Debug, Copy, Clone)]
struct TopicId(u64);


// User/Topic：标准的结构体，可以把任何类型组合在结构体里使用。
#[derive(Debug)]
struct User {
  id: UserId,
  name: String,
  gender: Gender,
}

#[derive(Debug)]
struct Topic {
  id: TopicId,
  name: String,
  owner: UserId,
}

// Event：标准的标签联合体，它定义了三种事件：Join、Leave、Message。每种事件都有自己的数据结构。
// 定义聊天室中可能发生的事件
#[derive(Debug)]
enum Event {
  Join((UserId, TopicId)),
  Leave((UserId, TopicId)),
  Message((UserId, TopicId, String)),
}

fn main() {
    let alice = User { id: UserId(1), name: "Alice".into(), gender: Gender::Female };
    let bob = User { id: UserId(2), name: "Bob".into(), gender: Gender::Male };
    
    let topic = Topic { id: TopicId(1), name: "rust".into(), owner: UserId(1) };
    let event1 = Event::Join((alice.id, topic.id));
    let event2 = Event::Join((bob.id, topic.id));
    let event3 = Event::Message((alice.id, topic.id, "Hello world!".into()));
    
    println!("event1: {:?}, event2: {:?}, event3: {:?}", event1, event2, event3);
}
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-96b3c794deae6d17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="3、控制流程"><a href="#3、控制流程" class="headerlink" title="3、控制流程"></a>3、控制流程</h2><p><img src="https://upload-images.jianshu.io/upload_images/12321605-c78351ef2d14e70d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="4、模式匹配"><a href="#4、模式匹配" class="headerlink" title="4、模式匹配"></a>4、模式匹配</h2><pre><code>fn process_event(event: &amp;Event) {
    match event {
        Event::Join((uid, _tid)) =&gt; println!("user {:?} joined", uid),
        Event::Leave((uid, tid)) =&gt; println!("user {:?} left {:?}", uid, tid),
        Event::Message((_, _, msg)) =&gt; println!("broadcast: {}", msg),
    }
}


fn process_message(event: &amp;Event) {
    if let Event::Message((_, _, msg)) = event {
        println!("broadcast: {}", msg);   
    }
}
</code></pre>
<h2 id="5、Rust-项目的组织"><a href="#5、Rust-项目的组织" class="headerlink" title="5、Rust 项目的组织"></a>5、Rust 项目的组织</h2><p>当<code>Rust</code>代码规模越来越大时，我们就无法用单一文件承载代码了，需要多个文件甚至多个目录协同工作，这时我们可以用 <code>mod</code>来组织代码。</p>
<p>具体做法是：在项目的入口文件<code>lib.rs/main.rs</code> 里，用<code>mod</code>来声明要加载的其它代码文件。如果模块内容比较多，可以放在一个目录下，在该目录下放一个<code>mod.rs</code>引入该模块的其它文件。这个文件，和<code>Python</code>的<code>__init__.py</code>有异曲同工之妙。这样处理之后，就可以用<code>mod</code>+目录名引入这个模块了，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-d9442605729d2834.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>在<code>Rust</code>里，一个项目也被称为一个<code>crate</code>。<code>crate</code>可以是可执行项目，也可以是一个库，我们可以用<code>cargo new &lt;name&gt; --lib</code>来创建一个库。当<code>crate</code>里的代码改变时，这个<code>crate</code>需要被重新编译。</p>
<p>当代码规模继续增长，把所有代码放在一个<code>crate</code>里就不是一个好主意了，因为任何代码的修改都会导致这个<code>crate</code>重新编译，这样效率不高。我们可以使用<code>workspace</code>。</p>
<p>一个<code>workspace</code>可以包含一到多个<code>crates</code>，当代码发生改变时，只有涉及的<code>crates</code>才需要重新编译。当我们要构建一个<code>workspace</code>时，需要先在某个目录下生成一个如图所示的<code>Cargo.toml</code>，包含<code>workspace</code>里所有的<code>crates</code>，然后可以<code>cargo new</code>生成对应的<code>crates</code>：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-83035085c8e45801.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-5b5e4dc861e848ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="6、常见问题"><a href="#6、常见问题" class="headerlink" title="6、常见问题"></a>6、常见问题</h2><p><strong>Q：如果我想创建双向链表，该怎么处理？</strong></p>
<p><code>Rust</code>标准库有 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">LinkedList</a>，它是一个双向链表的实现。但是当你需要使用链表的时候，可以先考虑一下，同样的需求是否可以用列表<code>Vec&lt;T&gt;</code>、循环缓冲区<code>VecDeque&lt;T&gt;</code>来实现。因为，链表对缓存非常不友好，性能会差很多。</p>
<p>你也许好奇为什么<code>Rust</code>标准库的<code>LinkedList</code>不用<code>Rc/Weak</code>，那是因为标准库直接用<code>NonNull</code>指针和<code>unsafe</code>。</p>
<p><strong>Q：为什么我的函数返回一个引用的时候，编译器总是跟我过不去？</strong></p>
<p>函数返回引用时，除非是静态引用，那么这个引用一定和带有引用的某个输入参数有关。输入参数可能是<code>&amp;self</code>、<code>&amp;mut self</code>或者<code>&amp;T/&amp;mut T</code>。我们要建立正确的输入和返回值之间的关系，这个关系和函数内部的实现无关，只和函数的签名有关。</p>
<pre><code>pub fn get&lt;Q: ?Sized&gt;(&amp;self, k: &amp;Q) -&gt; Option&lt;&amp;V&gt;
    where
        K: Borrow&lt;Q&gt;,
        Q: Hash + Eq
</code></pre>
<p>我们并不用实现它或者知道它如何实现，就可以确定返回值<code>Option&lt;&amp;V&gt;</code>到底跟谁有关系。因为这里只有两个选择：<code>&amp;self</code>或者<code>k: &amp;Q</code>。显然是<code>&amp;self</code>，因为<code>HashMap</code>持有数据，而<code>k</code>只是用来在<code>HashMap</code>里查询的<code>key</code>。</p>
<p>当你要返回在函数执行过程中，创建的或者得到的数据，和参数无关，那么无论它是一个有所有权的数据，还是一个引用，你只能返回带所有权的数据。对于引用，这就意味着调用<code>clone()</code>或者<code>to_owned()</code>来，从引用中得到所有权。</p>
<p><strong>Q：为什么标准库的数据结构比如 Rc / Vec 用那么多 unsafe，但别人总是告诉我，unsafe 不好？</strong></p>
<p>标准库的责任是，在保证安全的情况下，即使牺牲一定的可读性，也要用最高效的手段来实现要实现的功能；同时，为标准库的用户提供一个优雅、高级的抽象，让他们可以在绝大多数场合下写出漂亮的代码，无需和丑陋打交道。</p>
<p><code>Rust</code>中，<code>unsafe</code>代码把程序的正确性和安全性交给了开发者来保证，而标准库的开发者花了大量的精力和测试来保证这种正确性和安全性。而我们自己撰写<code>unsafe</code>代码时，除非有经验丰富的开发者<code>review</code> 代码，否则，有可能疏于对并发情况的考虑，写出了有问题的代码。</p>
<p>所以只要不是必须，建议不要写<code>unsafe</code>代码。<strong>毕竟大部分我们要处理的问题，都可以通过良好的设计、合适的数据结构和算法来实现。</strong></p>
<p><strong>Q: 下面代码为什么会报错</strong></p>
<pre><code>use std::str::Chars;

// 错误，为什么？
fn lifetime1() -&gt; &amp;str {
    let name = "Tyr".to_string();
    &amp;name[1..]
}

// 错误，为什么？
fn lifetime2(name: String) -&gt; &amp;str {
    &amp;name[1..]
}

// 正确，为什么？
fn lifetime3(name: &amp;str) -&gt; Chars {
    name.chars()
}
</code></pre>
<p>第一个，没有标注生命周期，但即使标注也不对，因为返回值引用了本地已经<code>drop</code>的<code>String</code>，会造成悬垂指针问题；</p>
<p>第二个，和第一个类似，因为参数是具有所有权的<code>String</code>，该<code>String</code>会在函数执行完后被<code>drop</code>，返回值不能引用该 <code>String</code>；</p>
<p>第三个，因为<code>Chars</code>的完整定义是<code>Chars&lt;'a&gt;</code>，根据生命周期标注规则，<code>Chars</code>内部的引用的生命周期和参数<code>name</code> 一致，所以不会产生问题。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023/06/22/cahce-eight-legged-essay/" title="缓存基础技术"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 缓存基础技术</span></a><a class="button is-default" href="/2023/05/01/the-beauty-of-compilation-principle/" title="《编译原理之美》"><span class="has-text-weight-semibold">下一页: 《编译原理之美》</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="fanlv/blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/fanlv"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com/fanlvlgh"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Ryo 2024</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p class="is-flex is-justify-content-center"><a title="备案号：鄂ICP备2022016224号-2" target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn/">备案号：鄂ICP备2022016224号-2 &nbsp;</a></p></div><div><span>博学之，审问之，慎思之，明辨之，笃行之</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>