<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>网络基础知识</title><meta name="description" content="行万里路，读万卷书"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "https://hm.baidu.com/hm.js?" + '2c076421eb9f21a0a143f8ee9c4ab171';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><meta name="referrer" content="no-referrer"><link rel="icon" href="/null"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="一、TCP基础知识1.1 TCP和UDP的区别？TCP是面向连接的协议，在收发数据前必须和对方建立可靠的连接，建立连接的3次握手、断开连接的4次挥手，为数据传输打下可靠基础;
UDP是无连接的，不可靠传输，尽最大努力交付数据，协议简单、资源要求少、传输速度快、实时性高的特点，适用于对传输效率要求高，但准确率要求低的应用场景，比如域名转换(DNS)、远程文件服务器(NFS)等。
1.2 TCP 为什么需要三次握手？为什么需要四次挥手？如何保证可靠?为什么需要三次握手？  
三次握手能确保双发的收发能力（确定双通道通畅）是OK。
为什么需要四次挥手
因为TCP是全双工协议，双方都可以发送和接收数据。当一方决定终止连接时，另一方可能还有数据需要发送。
如何保证可靠?

错误检测：TCP使用校验和功能来检测数据包在.."><meta name="generator" content="Hexo 5.4.2">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Ryo's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">网络基础知识</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81TCP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">一、TCP基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1.1 TCP和UDP的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-TCP-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0"><span class="toc-text">1.2 TCP 为什么需要三次握手？为什么需要四次挥手？如何保证可靠?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8C%85%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%BC%A0%E8%BE%93%EF%BC%9F"><span class="toc-text">1.3 TCP如何保证包的顺序传输？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%EF%BC%9F"><span class="toc-text">1.4 TCP超时重传？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-text">1.5 TCP流量控制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-text">1.6 TCP 拥塞控制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88TIME-WAIT%E7%8A%B6%E6%80%81%E5%BF%85%E9%A1%BB%E7%AD%89%E5%BE%852MSL%E6%97%B6%E9%97%B4%EF%BC%9F"><span class="toc-text">1.7 释放连接时为什么TIME-WAIT状态必须等待2MSL时间？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-TCP%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">1.8 TCP常用的几种定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-%E4%BB%80%E4%B9%88%E6%98%AF-TCP-BBR"><span class="toc-text">1.9 什么是 TCP BBR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%92%8C%E6%96%AD%E5%BC%80%E8%BF%87%E7%A8%8B%E4%BC%9A%E5%8F%97%E5%93%AA%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%A1%B9%E7%9A%84%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-text">1.10 TCP连接的建立和断开过程会受哪些配置项的影响？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-11-TCP-%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B%E5%8F%97%E5%88%B0%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-text">1.11 TCP 数据发送和接收过程受到什么影响？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-12-TCP-%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB"><span class="toc-text">1.12 TCP 状态转移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-13-TCP-SO-LINGER"><span class="toc-text">1.13 TCP SO_LINGER</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-14-TCP-%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E5%BE%81"><span class="toc-text">1.14 TCP 糊涂窗口综合征</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%85%B6%E4%BB%96%E5%9F%BA%E7%A1%80"><span class="toc-text">二、其他基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AFMTU%EF%BC%9F"><span class="toc-text">2.1 什么是MTU？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E4%BB%80%E4%B9%88%E6%98%AF-Path-MTU-Discovery%EF%BC%9F"><span class="toc-text">2.2 什么是 Path MTU Discovery？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Path-MTU-Discovery-%E6%98%AF%E8%BF%99%E4%B8%AA%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%A7%A6%E5%8F%91%EF%BC%9F"><span class="toc-text">2.3 Path MTU Discovery 是这个是什么时候会触发？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E4%BB%80%E4%B9%88%E6%98%AFMSS%EF%BC%9F"><span class="toc-text">2.4 什么是MSS？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-IP%E5%88%86%E7%89%87%E3%80%81TCP%E5%88%86%E7%BB%84%EF%BC%9F"><span class="toc-text">2.5 IP分片、TCP分组？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-Delay-ack%E3%80%81-Nagle%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">2.6 Delay ack、 Nagle算法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E6%95%B0%E6%8D%AE%E5%8C%85%E7%BB%8F%E8%BF%87%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8C%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%A2%AB%E4%BF%AE%E6%94%B9%E3%80%82"><span class="toc-text">2.7 数据包经过路由器，哪些字段可能会被修改。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-IP-%E9%83%A8%E9%A6%96-20-%E4%B8%AA%E5%AD%97%E8%8A%82"><span class="toc-text">2.8 IP 部首 20 个字节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-TCP-%E9%83%A8%E9%A6%96-20-%E4%B8%AA%E5%AD%97%E8%8A%82"><span class="toc-text">2.9 TCP 部首 20 个字节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-UDP-%E9%A6%96%E9%83%A8-8-%E5%AD%97%E8%8A%82"><span class="toc-text">2.10 UDP 首部 8 字节</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%85%B6%E4%BB%96"><span class="toc-text">三、其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%EF%BC%8C%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">3.1 浏览器访问一个网址，经历了哪些过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-https-%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">3.2 https 加密过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE"><span class="toc-text">3.3 证书签名和验签</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BD%91%E7%BB%9CIO%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">3.4 服务端网络IO线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Syn%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E9%98%B2%E6%8A%A4%E6%8E%AA%E6%96%BD%E6%94%BB%E5%87%BB%E3%80%82%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E3%80%82"><span class="toc-text">3.5 Syn攻击原理与防护措施攻击。什么是半连接队列。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-Http1-0%E3%80%81Http2-0%E3%80%81Http3-0-%E5%8C%BA%E5%88%AB"><span class="toc-text">3.6 Http1.0、Http2.0、Http3.0 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-http-cache"><span class="toc-text">3.7 http-cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E4%BB%80%E4%B9%88%E6%98%AFXSS%E6%94%BB%E5%87%BB%E3%80%81CSRF%E6%94%BB%E5%87%BB%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%B8%B8%E8%A7%81%E7%9A%84%E9%A2%84%E9%98%B2%E3%80%82"><span class="toc-text">3.8 什么是XSS攻击、CSRF攻击？有什么常见的预防。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%AF%B9%E6%AF%94-Thrift-vs-Protobuf"><span class="toc-text">3.9 网络传输协议对比 Thrift vs Protobuf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-Nginx%E8%A7%A3%E5%86%B3%E6%83%8A%E7%BE%A4%E7%8E%B0%E8%B1%A1%EF%BC%9F"><span class="toc-text">3.10 Nginx解决惊群现象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-11-Traceroute%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">3.11 Traceroute原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-12-%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%EF%BC%9F-RIP%E3%80%81OSPF%E3%80%81BGP%EF%BC%9F"><span class="toc-text">3.12 路由协议？ RIP、OSPF、BGP？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-13-NAT%EF%BC%9FP2P%E7%A9%BF%E9%80%8F%EF%BC%9F"><span class="toc-text">3.13 NAT？P2P穿透？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-14-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%94%B6%E5%8F%96%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8E%9F%E7%90%86"><span class="toc-text">3.14 操作系统收取数据包原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-15-OSI-%E4%B8%83%E5%B1%82%E5%92%8C-TCP-IP-%E5%9B%9B%E5%B1%82"><span class="toc-text">3.15 OSI 七层和 TCP&#x2F;IP 四层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-16-%E7%BD%91%E7%BB%9C%E5%8C%85%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B"><span class="toc-text">3.16 网络包接收流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-17-%E5%85%B6%E4%BB%96"><span class="toc-text">3.17 其他</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/ele"><i class="tag post-item-tag">ele</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">网络基础知识</h1><time class="has-text-grey" datetime="2023-06-22T02:00:08.000Z">2023-06-22</time><article class="mt-2 post-content"><h1 id="一、TCP基础知识"><a href="#一、TCP基础知识" class="headerlink" title="一、TCP基础知识"></a>一、TCP基础知识</h1><h2 id="1-1-TCP和UDP的区别？"><a href="#1-1-TCP和UDP的区别？" class="headerlink" title="1.1 TCP和UDP的区别？"></a>1.1 TCP和UDP的区别？</h2><p><code>TCP</code>是面向连接的协议，在收发数据前必须和对方建立可靠的连接，建立连接的<code>3</code>次握手、断开连接的<code>4</code>次挥手，为数据传输打下可靠基础;</p>
<p><code>UDP</code>是无连接的，不可靠传输，尽最大努力交付数据，协议简单、资源要求少、传输速度快、实时性高的特点，适用于对传输效率要求高，但准确率要求低的应用场景，比如域名转换(<code>DNS</code>)、远程文件服务器(<code>NFS</code>)等。</p>
<h2 id="1-2-TCP-为什么需要三次握手？为什么需要四次挥手？如何保证可靠"><a href="#1-2-TCP-为什么需要三次握手？为什么需要四次挥手？如何保证可靠" class="headerlink" title="1.2 TCP 为什么需要三次握手？为什么需要四次挥手？如何保证可靠?"></a>1.2 TCP 为什么需要三次握手？为什么需要四次挥手？如何保证可靠?</h2><p><strong>为什么需要三次握手？</strong>  </p>
<p>三次握手能确保双发的收发能力（确定双通道通畅）是OK。</p>
<p><strong>为什么需要四次挥手</strong></p>
<p>因为<code>TCP</code>是全双工协议，双方都可以发送和接收数据。当一方决定终止连接时，另一方可能还有数据需要发送。</p>
<p><strong>如何保证可靠?</strong></p>
<ul>
<li>错误检测：<code>TCP</code>使用校验和功能来检测数据包在传输过程中是否出现错误。</li>
<li>顺序保证：<code>TCP</code>给每个数据包分配序号，接收方将数据包按序号重组，确保有序传输。</li>
<li>重传：如果接收方在一定时间内未对发送方的数据包进行确认，发送方将重传该数据包。</li>
<li>流量控制：发送方和接收方通过交换窗口大小协商数据传输速率，以避免传输过快导致的缓冲区溢出。</li>
<li>拥塞控制：<code>TCP</code> 使用各种算法来监测网络拥塞情况，并相应地调整数据发送速率。</li>
</ul>
<h2 id="1-3-TCP如何保证包的顺序传输？"><a href="#1-3-TCP如何保证包的顺序传输？" class="headerlink" title="1.3 TCP如何保证包的顺序传输？"></a>1.3 TCP如何保证包的顺序传输？</h2><p>序号传输，到接收方的缓存区以后会按序号重排。</p>
<h2 id="1-4-TCP超时重传？"><a href="#1-4-TCP超时重传？" class="headerlink" title="1.4 TCP超时重传？"></a>1.4 TCP超时重传？</h2><p>原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的<code>ACK</code>报文，那么就重新发送数据，直到发送成功为止。</p>
<p><code>RTO</code>（<code>Retransmission Timeout</code>）是<code>TCP</code>协议中用于设置重传定时器的超时时间。计算<code>RTO</code>的方法需要权衡：（1）设置合理的超时时间以避免过早重传，浪费带宽和资源；（2）又要确保能在适当的时间内检测到丢失的数据包并进行重传。</p>
<p><code>RTO</code> 的计算主要依赖于以下指标：</p>
<ol>
<li><code>RTT</code>（<code>Round-Trip Time</code>）：指数据包从发送方到接收方，以及<code>ACK</code>从接收方回到发送方所需的时间。网络条件、延迟和拥塞会影响<code>RTT</code>的变化。</li>
<li><code>SRTT</code>（<code>Smoothed Round-Trip Time</code>）：平滑<code>RTT</code>，是基于连续<code>RTT</code>测量值的加权平均值，用于估算当前的 <code>RTT</code>。</li>
<li><code>RTTVAR</code>（<code>Round-Trip Time Variation</code>）：<code>RTT</code>的变化量，用于描述<code>RTT</code>的不稳定程度。</li>
</ol>
<h2 id="1-5-TCP流量控制？"><a href="#1-5-TCP流量控制？" class="headerlink" title="1.5 TCP流量控制？"></a>1.5 TCP流量控制？</h2><p><code>TCP</code>流量控制（<code>Flow Control</code>）是一种控制数据发送速率的机制，避免发送方发送过快导致接收方的缓冲区溢出。流量控制通过「滑动窗口」（<code>Sliding Window</code>）实现，它可以根据接收方处理能力和网络状况动态调整发送速率。</p>
<p>以下是<code>TCP</code>流量控制的主要步骤：</p>
<ol>
<li><p><strong>接收方设置窗口大小</strong>：接收方根据其接收缓冲区可用空间设置一个窗口大小。窗口大小表示接收方允许发送方连续发送数据包的最大数量，不必等待每个数据包的确认。这个窗口大小值会在<code>ACK</code>数据包的<code>TCP</code>头部字段中反馈给发送方。</p>
</li>
<li><p><strong>发送方基于窗口大小调整发送速率</strong>：发送方根据接收到的窗口大小信息调整其发送速率。发送方会跟踪已发送但尚未被确认的数据包的数量，确保在接收到<code>ACK</code>前不至于超过接收方的窗口大小。</p>
</li>
<li><p><strong>滑动窗口</strong>：随着发送方接收到<code>ACK</code>，它将更新已发送但未确认的数据包数量。然后根据未确认数据包数量继续发送新的数据包，同时保持发送速率不超过接收方的窗口大小。这种动态调整发送速率的过程像一个滑动窗口一样。</p>
</li>
<li><p><strong>窗口大小调整</strong>：在数据传输过程中，接收方根据其接收缓冲区的剩余容量不断更新窗口大小。接收方通过<code>ACK</code>数据包将新的窗口大小发送给发送方。如果接收方的缓冲区已满，窗口大小将被设置为<code>0</code>，发送方会暂停发送数据，直到接收到有效窗口大小。</p>
</li>
</ol>
<p>通过滑动窗口的流量控制机制，<code>TCP</code>协议可以在不同的网络环境下实现稳定、高效的数据传输。同时，流量控制也能确保接收方及时处理数据包，防止缓冲区溢出。</p>
<h2 id="1-6-TCP-拥塞控制？"><a href="#1-6-TCP-拥塞控制？" class="headerlink" title="1.6 TCP 拥塞控制？"></a>1.6 TCP 拥塞控制？</h2><p><code>TCP</code>拥塞控制（<code>Congestion Control</code>）是一种<strong>动态调整数据发送速率的机制，目的是减少因网络拥塞造成的数据包丢失、重传和延迟</strong>。拥塞控制与流量控制相互补充，共同保证了<code>TCP</code>数据传输的可靠性和有效性。<code>TCP</code>拥塞控制主要依赖以下四个算法：</p>
<ol>
<li><p><strong>慢开始（Slow Start）：</strong> 该算法用于拥塞窗口（<code>cwnd</code>）的初始阶段，通过逐渐增大拥塞窗口来寻找可接受的发送速率。发送方以设置为<code>1 MTU</code>（最大传输单元）的初始拥塞窗口大小开始发送数据，并在每次收到<code>ACK</code>时将拥塞窗口大小加倍。慢开始会在拥塞窗口达到预设的门限（<code>ssthresh</code>）或出现丢包现象时结束。</p>
</li>
<li><p><strong>拥塞避免（Congestion Avoidance）：</strong> 当拥塞窗口达到门限，拥塞避免算法启动，以减缓窗口增长速率。在此阶段，拥塞窗口以加法增长，即每次收到一个<code>ACK</code>时，发送方会将拥塞窗口加上一个较小的固定值。这样，在网络达到饱和时，拥塞避免算法可以避免进一步加剧拥塞。</p>
</li>
<li><p><strong>快速重传（Fast Retransmit）：</strong> 该算法用于在无需等待<code>RTO</code>超时的情况下快速检测和重传丢失的数据包。当发送方连续收到三个具有相同<code>ACK</code>序号的<code>ACK</code>数据包时，快速重传算法启动，立即发送丢失的数据包。</p>
</li>
<li><p><strong>快速恢复（Fast Recovery）：</strong> 快速恢复算法在快速重传后启动，旨在在短时间内恢复慢开始门限和拥塞窗口。发送方会将门限设为其当前拥塞窗口的一半，并进入拥塞避免阶段，从而在正确调整拥塞窗口的同时避免重新回到慢开始阶段。</p>
</li>
</ol>
<p>通过这四种拥塞控制算法，<code>TCP</code>协议可以动态调整发送速率，适应不同的网络状况，减小拥塞，降低数据包丢失或延迟，从而提高数据传输效率。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-b11189d0ce6f023d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="1-7-释放连接时为什么TIME-WAIT状态必须等待2MSL时间？"><a href="#1-7-释放连接时为什么TIME-WAIT状态必须等待2MSL时间？" class="headerlink" title="1.7 释放连接时为什么TIME-WAIT状态必须等待2MSL时间？"></a>1.7 释放连接时为什么TIME-WAIT状态必须等待2MSL时间？</h2><p>在<code>TCP</code>连接释放过程中，当某个端点收到对方发送的<code>FIN</code>数据包并发送<code>ACK</code>确认后，<code>TCP</code>会进入<code>TIME-WAIT</code>状态。<code>TIME-WAIT</code>状态持续时间通常为<code>2MSL</code>（<code>MSL</code>是最长段生存时间，<code>Maximum Segment Lifetime</code>），这样设置的主要原因有两个：</p>
<ol>
<li><p><strong>确保最后一个 ACK 数据包正确传送：</strong> 当端点收到<code>FIN</code>数据包并发送<code>ACK</code>时，可能会因为网络原因造成<code>ACK</code>丢失，使对方无法知晓。在<code>2MSL</code>的等待期间，对方的重传定时器可能触发，重新发送<code>FIN</code>数据包。端点在<code>TIME-WAIT</code>状态可以重新发送<code>ACK</code>数据包，以确保对方收到，从而正常关闭连接。</p>
</li>
<li><p><strong>防止旧的数据包在新连接中传播：</strong> 进入<code>TIME-WAIT</code>状态后，端点会暂停一段时间再创建新的连接。这段时间内，旧连接的所有数据包都会因超过<code>MSL</code>而丢弃。设置为<code>2</code>倍<code>MSL</code>的时间可以确保旧连接产生的数据包在新连接创建之前已经被废弃并从网络中消散，降低出现错误的可能性。</p>
</li>
</ol>
<p>等待<code>2MSL</code>时间是<code>TCP</code>协议为保证数据包可靠传输和避免潜在错误设定的一种安全机制。通过这种机制，<code>TCP</code>可以有效防止数据包的错误传播，确保连接的正确关闭。</p>
<h2 id="1-8-TCP常用的几种定时器"><a href="#1-8-TCP常用的几种定时器" class="headerlink" title="1.8 TCP常用的几种定时器"></a>1.8 TCP常用的几种定时器</h2><p><code>TCP</code>协议中有以下四种常见的定时器，用于控制数据传输过程中的不同阶段和事件：</p>
<ol>
<li><p><strong>重传定时器（Retransmission Timer）：</strong> 重传定时器用于检测数据包发送后是否在合理的时间内收到确认 <code>ACK</code>，从而判断发送的数据包是否成功传达。如果在定时器超时前没有收到<code>ACK</code>，<code>TCP</code>端点会认为数据包已丢失并触发超时重传，重发该数据包。该定时器的超时时间取决于 <code>RTO</code>（<code>Retransmission Timeout</code>），可以通过<code>RTT</code>（往返时间）测量值来动态调整。</p>
</li>
<li><p><strong>确认延迟（Delayed ACK）定时器：</strong> 为了提高网络传输效率，接收端通常不会对每个收到的数据包立即发送 <code>ACK</code>。确认延迟定时器可以设置一个间隔时间内允许接收端批量发送确认<code>ACK</code>，减小网络负载。如果此定时器超时或连续收到相同序号的段，则接收端需要立即发送<code>ACK</code>。</p>
</li>
<li><p><strong>持续定时器（Persistence Timer）：</strong> <code>TCP</code>会根据接收方的窗口大小（<code>Window Size</code>）限制发送速率，防止接收缓冲区溢出。当接收方窗口大小为<code>0</code>时，发送方会停止发送数据。持续定时器用于在这种情况下周期性查询接收方窗口是否可用。定时器超时后，发送方会发送一个窗口探测数据包（<code>Window Probe</code>），监测接收方是否具有新的窗口大小。</p>
</li>
<li><p><strong>TIME-WAIT 定时器：</strong> 在<code>TCP</code>释放连接的过程中，某个端点收到对方的<code>FIN</code>数据包并发送确认<code>ACK</code>后，会进入<code>TIME-WAIT</code>状态。<code>TIME-WAIT</code>定时器的作用是持续时间通常为<code>2MSL</code>（<code>MSL</code>是最长段生存时间，<code>Maximum Segment Lifetime</code>）。在此期间，端点确保最后一个<code>ACK</code>数据包正确传输，并防止旧数据包在新连接中传播。</p>
</li>
<li><p><strong>保活计时器</strong>：保活计时器使用在某些实现中，用来防止在两个<code>TCP</code>之间的连接出现长时间的空闲。假定客户打开了到服务器的连接，传送了一些数据，然后就保持静默了。也许这个客户出故障了。在这种情况下，这个连接将永远的处理打开状态。要解决这种问题，在大多数的实现中都是使服务器设置保活计时器。每当服务器收到客户的信息，就将计时器复位。通常设置为两小时。若服务器过了两小时还没有收到客户的信息，他就发送探测报文段。若发送了<code>10</code>个探测报文段（每一个像个<code>75</code>秒）还没有响应，就假定客户除了故障，因而就终止了该连接。这种连接的断开当然不会使用四次握手，而是直接硬性的中断和客户端的<code>TCP</code>连接。</p>
</li>
</ol>
<p>这些定时器通过控制和调整<code>TCP</code>数据包的发送和接收，对<code>TCP</code>数据传输过程中的稳定性、可靠性和有效性起到关键作用。</p>
<h2 id="1-9-什么是-TCP-BBR"><a href="#1-9-什么是-TCP-BBR" class="headerlink" title="1.9 什么是 TCP BBR"></a>1.9 什么是 TCP BBR</h2><p><code>TCP BBR</code>（<code>Bottleneck Bandwidth and RTT</code>）是一种拥塞控制算法，旨在改善网络传输的性能。<code>TCP BBR</code>是由 <code>Google</code>提出并开发的，其主要目的是为了解决传统拥塞控制算法（如<code>TCP Cubic</code>和<code>TCP Reno</code>）在面对高延时、高带宽网络环境时的性能瓶颈和慢启动问题。</p>
<p><code>TCP BBR</code>算法基于现实网络条件来进行拥塞控制，主要关注两个关键指标：</p>
<ol>
<li><p><strong>Bottleneck Bandwidth（瓶颈带宽）：</strong> <code>BBR</code>估计当下可用的网络带宽，以便在确保效率的同时避免过度拥塞。这样可以确保<code>TCP</code>流量不会因填满队列而延长延迟。</p>
</li>
<li><p><strong>Round-Trip Time (RTT)：</strong> <code>BBR</code>需要估算网络的往返时间（<code>RTT</code>），以便对通信过程中的延时有个清晰的了解。这有助于<code>BBR</code>高效地利用网络资源，减小延迟，提升吞吐量。</p>
</li>
</ol>
<p><code>TCP BBR</code>通过估算这两个指标来持续适应并优化数据包发送速率，防止过度拥塞或延迟。<code>BBR</code>主要通过以下两个阶段实现其目标：</p>
<ol>
<li><p><strong>Startup 阶段：</strong> 在启动阶段，<code>BBR</code>加快发送速率，试图尽快找到网络的瓶颈带宽。然后在到达可用带宽上限时稳定发送速率，避免过度占用带宽。</p>
</li>
<li><p><strong>Probe and Decide 阶段：</strong> 在此阶段，<code>BBR</code>定期探测网络带宽和延迟的变化，并根据观察到的信息调整发送速率。这样<code>BBR</code>能在保持高吞吐量的同时，适应网络环境的变化。</p>
</li>
</ol>
<p>与传统的拥塞控制算法相比，<code>TCP BBR</code>能更有效地利用网络带宽，降低网络延迟，在具有丢包、高延迟和带宽共享的网络环境中获得更好的性能。多数<code>Linux</code>发行版支持<code>BBR</code>，可以通过内核参数配置启用。在云服务、内容分发网络和大型数据中心等应用场景中，<code>TCP BBR</code>可发挥重要作用。</p>
<h2 id="1-10-TCP连接的建立和断开过程会受哪些配置项的影响？"><a href="#1-10-TCP连接的建立和断开过程会受哪些配置项的影响？" class="headerlink" title="1.10 TCP连接的建立和断开过程会受哪些配置项的影响？"></a>1.10 TCP连接的建立和断开过程会受哪些配置项的影响？</h2><p><img src="https://upload-images.jianshu.io/upload_images/12321605-c7f662849b4f6fd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-539841c261c41c1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="1-11-TCP-数据发送和接收过程受到什么影响？"><a href="#1-11-TCP-数据发送和接收过程受到什么影响？" class="headerlink" title="1.11 TCP 数据发送和接收过程受到什么影响？"></a>1.11 TCP 数据发送和接收过程受到什么影响？</h2><p><img src="https://upload-images.jianshu.io/upload_images/12321605-5a5b23e96a9e6a7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-28810041b855b3f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="1-12-TCP-状态转移"><a href="#1-12-TCP-状态转移" class="headerlink" title="1.12 TCP 状态转移"></a>1.12 TCP 状态转移</h2><p><img src="https://upload-images.jianshu.io/upload_images/12321605-e28f2fb0b6209a24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="客户.png"></p>
<h2 id="1-13-TCP-SO-LINGER"><a href="#1-13-TCP-SO-LINGER" class="headerlink" title="1.13 TCP SO_LINGER"></a>1.13 TCP SO_LINGER</h2><p><img src="https://upload-images.jianshu.io/upload_images/12321605-6fa85ea99576f2eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="18.7.2 异常终业一个连接.png"></p>
<h2 id="1-14-TCP-糊涂窗口综合征"><a href="#1-14-TCP-糊涂窗口综合征" class="headerlink" title="1.14 TCP 糊涂窗口综合征"></a>1.14 TCP 糊涂窗口综合征</h2><p><img src="https://upload-images.jianshu.io/upload_images/12321605-b0065833b610f127.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="该现象可发生在两端中的任同一编：接收方可以通告一个小的富口（商不是一直韕銷有.png"></p>
<h1 id="二、其他基础"><a href="#二、其他基础" class="headerlink" title="二、其他基础"></a>二、其他基础</h1><h2 id="2-1-什么是MTU？"><a href="#2-1-什么是MTU？" class="headerlink" title="2.1 什么是MTU？"></a>2.1 什么是MTU？</h2><p><code>MTU</code>（<code>Maximum Transmission Unit</code>，最大传输单元）是指在网络传输过程中，一个数据包允许携带的最大数据量。这个值通常取决于底层网络层（如<code>IP</code>层）和链路层（如 <code>Ethernet</code>）的约束。<code>MTU</code>的大小对网络传输效率和延迟有很大影响。</p>
<p>不同类型的网络可能有不同的<code>MTU</code>值。例如，在<code>Ethernet</code>中，默认的<code>MTU</code>值为<code>1500</code>字节。<code>IP</code>数据包中包含<code>IP</code> 头部信息（通常为<code>20</code>字节）和传输层数据（如<code>TCP</code>数据）。因此，在<code>Ethernet</code>中，<code>TCP</code>数据包可携带最大的数据量是<code>1500</code>字节减去<code>IP</code>和<code>TCP</code>头部信息的大小。</p>
<p>在数据传输过程中，如果网络路径上的某个链路的<code>MTU</code>值较小，可能导致数据包太大而无法传输。在这种情况下，通常需要对大包进行分片（<code>Fragmentation</code>），将大包切分为多个小包进行发送。然而，分片可能会导致网络传输效率降低，因为每个分片可能需要单独处理和重传。<code>Path MTU Discovery</code> 是一种用于在网络路径中找到最小<code>MTU</code>值的技术，它可以帮助减少分片，提高网络传输效率。</p>
<h2 id="2-2-什么是-Path-MTU-Discovery？"><a href="#2-2-什么是-Path-MTU-Discovery？" class="headerlink" title="2.2 什么是 Path MTU Discovery？"></a>2.2 什么是 Path MTU Discovery？</h2><p><code>Path MTU Discovery</code>（<code>PMTUD</code>，路径最大传输单元发现）是一种在<code>IP</code>层查找两个端点之间的路径最小<code>MTU</code>值的技术。<code>PMTUD</code>的目的是选择最合适的数据包大小与网络路径相匹配，从而避免不必要的分片和拥塞，提高传输效率。</p>
<p><code>PMTUD</code>的基本工作原理如下：</p>
<ol>
<li><p><strong>设置原始数据包大小</strong>：发送方首先将数据包的大小设置为其本地<code>MTU</code>值。通常情况下，网络层（如<code>IP</code>层）会遵循“不分片”（<code>Do not Fragment，DF</code>）标识，不允许对数据包进行分片。</p>
</li>
<li><p><strong>发送数据包</strong>：发送方将数据包发送到网络中。当数据包在网络路径中经过不同类型的链路时，可能会遇到较小的<code>MTU</code> 值。</p>
</li>
<li><p><strong>接收 ICMP 错误消息</strong>：如果路径中的某个链路的<code>MTU</code>值大于数据包大小，路由器会抛弃该数据包（由于设置了<code>DF</code> 标识，阻止分片过程）。同时，路由器将发送一个<code>ICMP</code>错误消息（“需要分片，但<code>DF</code>标志已设置”）给发送方。该 <code>ICMP</code>消息包含了产生错误的链路的<code>MTU</code>值。</p>
</li>
<li><p><strong>重新调整数据包大小</strong>：当发送方收到<code>ICMP</code>错误消息后，它会根据<code>ICMP</code>消息提供的<code>MTU</code>值重新调整数据包大小。然后，发送方使用新的数据包大小重发数据包。</p>
</li>
<li><p><strong>查找路径 MTU</strong>：发送方持续沿着路径更新数据包大小，直到数据包成功抵达接收方而不产生<code>ICMP</code>错误消息。这个过程可以持续进行，以便在路径<code>MTU</code>发生变化时实时更新数据包大小。</p>
</li>
</ol>
<p>通过执行<code>Path MTU Discovery</code>，<code>TCP/IP</code>可以实现在网络路径中自适应地调整数据包大小，避免分片和降低传输延迟，从而提高网络性能。</p>
<h2 id="2-3-Path-MTU-Discovery-是这个是什么时候会触发？"><a href="#2-3-Path-MTU-Discovery-是这个是什么时候会触发？" class="headerlink" title="2.3 Path MTU Discovery 是这个是什么时候会触发？"></a>2.3 Path MTU Discovery 是这个是什么时候会触发？</h2><p><code>Path MTU Discovery</code>（<code>PMTUD</code>）通常是在<code>TCP</code>连接建立阶段开始启动的，并在整个连接过程中持续运作。以下是触发进行<code>PMTUD</code>的主要时机和条件：</p>
<ol>
<li><p><strong>TCP 连接建立阶段：</strong> 发送方会在连接建立阶段启动<code>Path MTU Discovery</code>。它通过将数据包的“不分片”（<code>Do not Fragment，DF</code>）标识设置为<code>1</code>，来阻止对数据包进行分片。初始数据包（如<code>SYN</code>数据包）的大小基于发送方的本地<code>MTU</code>值。</p>
</li>
<li><p><strong>连接过程中的数据传输：</strong> 在<code>TCP</code>数据传输过程中，发送方会持续使用之前发现的路径<code>MTU</code> 。如果路径发生变化或网络条件调整，导致<code>MTU</code>值更新，发送方会通过 <code>ICMP</code> 错误消息的接收实时更新路径 MTU。</p>
</li>
<li><p><strong>收到 ICMP 错误消息：</strong> 如果数据包的大小大于路径中某个链路的 MTU 值，那么路由器会抛弃该数据包，并向发送方发送 ICMP 错误消息（“需要分片，但 DF 标志已设置”）。发送方在收到此类 ICMP 错误消息时，会触发 Path MTU Discovery，根据从 ICMP 消息中获取的新的 MTU 值，重新调整数据包大小。</p>
</li>
<li><p><strong>TCP 保活保持定时器（optional）：</strong> 在一些实现中，TCP 连接可能会在长时间空闲后产生保活保持数据包（Keep-alive Probes）。如果启用此功能，保活保持数据包也可以用于触发 Path MTU Discovery，以确定路径 MTU 在空闲期间是否发生变化。</p>
</li>
</ol>
<p>总之，<code>Path MTU Discovery</code>在<code>TCP</code>连接的整个生命周期中都可能触发，主要时机包括连接建立阶段、连接过程中的数据传输和收到<code>ICMP</code>错误消息。这种动态探测机制确保了网络传输性能的优化和资源的充分利用。</p>
<h2 id="2-4-什么是MSS？"><a href="#2-4-什么是MSS？" class="headerlink" title="2.4 什么是MSS？"></a>2.4 什么是MSS？</h2><p><code>MSS</code>（<code>Maximum Segment Size</code>，最大段大小）是<code>TCP</code>数据包在网络传输过程中，载荷（即<code>TCP</code>数据段）的最大字节数。<code>MSS</code>并不包括<code>TCP</code>头和<code>IP</code>头部信息的大小。<code>MSS</code>的大小主要取决于网络的<code>MTU</code>（<code>Maximum Transmission Unit</code>，最大传输单元）值。</p>
<p>为了确保<code>TCP</code>数据包能够顺利在不同类型的链路上传输，避免分片和端点重新组合所带来的性能损失，<code>MSS</code>常常是根据网络路径<code>MTU</code>减去<code>IP</code>头部和<code>TCP</code>头部信息的大小计算得出的。</p>
<p>例如，在传统的<code>Ethernet</code>网络环境中，<code>MTU</code>默认值为<code>1500</code>字节。因为<code>IP</code>头部的大小通常为<code>20</code>字节，<code>TCP</code>头部的大小也通常为<code>20</code>字节，所以典型情况下，<code>MSS</code>的值为<code>1500 - 20(IP头部) - 20(TCP头部) = 1460 字节</code>。</p>
<p><code>MSS</code>值在<code>TCP</code>连接建立过程中（三次握手阶段）由双方实际最大段大小的取小值决定。客户端和服务器分别在发起连接（<code>SYN</code>）和确认连接（<code>SYN-ACK</code>）的数据包中，通过<code>MSS</code>选项来通知对方自己的最大段大小。通过协商获得的<code>MSS</code>值可以在后续数据传输过程中避免分片，提高网络传输效率。</p>
<h2 id="2-5-IP分片、TCP分组？"><a href="#2-5-IP分片、TCP分组？" class="headerlink" title="2.5 IP分片、TCP分组？"></a>2.5 IP分片、TCP分组？</h2><p><strong>1. IP 分片：</strong></p>
<p>当<code>IP</code>层的数据包大小超过当前网络链路的<code>MTU</code>（最大传输单元）时，会触发<code>IP</code>分片。<code>IP</code>分片是在网络层将大数据包拆分为若干个较小的数据包，使其大小适应网络链路的<code>MTU</code>，以便顺利传输。 分片后的数据包在网络层（<code>IP</code>层）重新组装，以还原原始大数据包。</p>
<p><strong>IP分片主要是为UDP服务的：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-239e59401384b4e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>2. TCP 分组：</strong></p>
<p><code>TCP</code>分组发生在传输层，主要是为了根据接收方拥有的空闲缓冲区大小（窗口大小）和 <code>MSS</code>（最大段大小）将数据流划分为合适大小的数据段。</p>
<p>当本地应用程序向<code>TCP</code>层传输大量数据时，<code>TCP</code>层为了遵循<code>MSS</code>值和接收方窗口大小的限制，会将数据拆分成较小的数据段，然后将这些段加上<code>TCP</code>头部分装成数据包。对于接收方而言，<code>TCP</code>层收到数据包后，会将数据包的数据部分提取出来，再将其串联成数据流，并传递给接收方应用程序。</p>
<p>总结：<code>IP</code>分片发生在网络层，主要是为了适应不同网络链路的<code>MTU</code>限制。<code>TCP</code>分组发生在传输层，是为了将数据流拆分成合适大小的数据段，以满足接收方窗口大小和<code>MSS</code>限制。在实际网络传输过程中，数据包可能会经历<code>IP</code>分片、<code>TCP</code> 分组或二者的结合。</p>
<h2 id="2-6-Delay-ack、-Nagle算法？"><a href="#2-6-Delay-ack、-Nagle算法？" class="headerlink" title="2.6 Delay ack、 Nagle算法？"></a>2.6 Delay ack、 Nagle算法？</h2><p><strong>1. Delayed ACK（延迟确认）：</strong></p>
<p><code>Delayed ACK</code>是一种<code>TCP</code>确认策略，用于减小频繁发送小数据包的<code>ACK</code>（确认）带来的网络开销。在这种策略下，<code>TCP</code>接收方在收到数据包后，并不立即发送<code>ACK</code>，而是等待一段时间（通常为<code>100-200</code>毫秒），期间如果接收方有需要发送的数据，则将<code>ACK</code>与数据一并发送。这样可以有效地降低<code>ACK</code>数据包在网络中的传输数量，提高网络利用率。</p>
<p>但是，如果在延迟时间内没有接收到新的数据，则<code>ACK</code>会按照设置的超时时间被发送出去，以确保发送方能够及时得到确认信息，避免无谓的重传。</p>
<p><strong>2. Nagle 算法：</strong></p>
<p><code>Nagle</code>算法是一种<code>TCP</code>流量控制策略，用于减少小数据包在网络中的传输, 从而避免网络拥塞。<code>Nagle</code>算法通过合并多个正在等待确认的小数据包，并将它们组装成一个较大的数据包一起发送。</p>
<p><code>Nagle</code>算法的核心逻辑如下：</p>
<p>a. 如果发送方的发送缓冲区中有未确认的小数据包（即已发送但尚未收到<code>ACK</code>的数据包），则将新生成的小数据包放在发送缓冲区中等待。<br>b. 如果接收到一个<code>ACK</code>（对之前发送缓冲区内的数据包的确认），<code>Nagle</code>算法会将缓冲区中的所有小数据包合并为一个新的数据包一起发送。<br>c. 如果发送缓冲区已满或者达到<code>MSS</code>（最大段大小），则直接发送。</p>
<p><code>Nagle</code>算法与<code>Delayed ACK</code>都有助于降低小数据包的数量，从而减少网络拥塞和提高网络传输效率。然而，在某些需要低延迟和高实时性的应用场景（如实时游戏、音视频通话等）下，它们可能会影响传输性能。因此，可以根据实际应用需求决定是否启用这两个算法。</p>
<h2 id="2-7-数据包经过路由器，哪些字段可能会被修改。"><a href="#2-7-数据包经过路由器，哪些字段可能会被修改。" class="headerlink" title="2.7 数据包经过路由器，哪些字段可能会被修改。"></a>2.7 数据包经过路由器，哪些字段可能会被修改。</h2><ol>
<li><code>IP</code>层<ul>
<li><code>TTL</code>（<code>Time To Live</code>）：每经过一个路由器，<code>TTL</code>的值会减<code>1</code>，以防止数据包在网络中无限循环。当<code>TTL</code> 减至<code>0</code>时，路由器会丢弃该数据包，并可能发送一个<code>ICMP</code>差错报文通知发送方。</li>
<li>校验和（<code>Header Checksum</code>）：<code>TTL</code> 的改变会导致 <code>IP</code> 头部的校验和发生变化。路由器需要重新计算并更新校验和字段，以确保数据包在接收端被正确解析。</li>
<li>源<code>IP</code>地址和目标<code>IP</code>地址：在某些特殊情况下，如使用<code>NAT</code>（网络地址转换）技术时，路由器可能需要修改源 <code>IP</code>地址和/或目标<code>IP</code>地址。</li>
</ul>
</li>
<li>链路层<ul>
<li>源<code>MAC</code>地址和目标<code>MAC</code>地址：路由器在转发数据包时，需要将源<code>MAC</code>地址改为自身的<code>MAC</code>地址，并将目标 <code>MAC</code>地址改为下一个跳点（下一个路由器或者最终目的主机）的<code>MAC</code>地址。</li>
</ul>
</li>
</ol>
<h2 id="2-8-IP-部首-20-个字节"><a href="#2-8-IP-部首-20-个字节" class="headerlink" title="2.8 IP 部首 20 个字节"></a>2.8 IP 部首 20 个字节</h2><ol>
<li><p>4字节： 4位版本、4位首部长度、8位服务类型、 16位总长度（65 536）</p>
<ul>
<li>版本4位，表示版本号，目前最广泛的是4=B1000，即常说的IPv4；相信IPv6以后会广泛应用，它能给世界上每个纽扣都分配一个IP地址。 一般是 0100 表示IPV4</li>
<li>头长4位，数据包头部长度。它表示数据包头部包括多少个32位长整型，也就是多少个4字节的数据。无选项则为5（红色部分）。 一般是 0101 表示 5*4=20个</li>
<li>服务类型，包括8个二进制位，一般全部都是0，大多数的TCP/IP以忽略</li>
<li>包裹总长16位，当前数据包的总长度，单位是字节。当然最大只能是65535，及64KB。 （这个是除了以太网部首长度以后的包长度，加上以太网部首等于整个长度）</li>
</ul>
</li>
<li><p>4字节 ： 16位重组标示、3位标志、13位偏移</p>
<ul>
<li>重组标识16位，发送主机赋予的标识，以便接收方进行分片重组。 通常每发一个报文就会加1</li>
<li>标志3位，他们各自的意义如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 保留段位(2)：1位，未使用 0… …. …. …. = Reserved bit: Not set<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不分段位(1)：1位，.1.. …. …. …. = Don’t fragment: Set TCP都是1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 更多段位(0)：1位，..0. …. …. …. = More fragments: Not set 是否有更多数据包，</li>
<li>段偏移量13位，与更多段位组合，帮助接收方组合分段的报文，以字节为单位。…0 0000 0000 0000 = Fragment offset: 0 当前分片的索引书</li>
</ul>
</li>
<li><p>4字节 ：1字节TTL、1字节协议代码、2字节头部校验</p>
<ul>
<li>生存时间8位，经常ping命令看到的TTL（Time To Live）就是这个，每经过一个路由器，该值就减一，到零丢弃。</li>
<li>协议代码8位，表明使用该包裹的上层协议，如ICMP=1，IGMP =2，TCP=6，UDP=17等。</li>
<li>头检验和16位，是IPv4数据包头部的校验和。</li>
</ul>
</li>
<li><p>4字节 源IP地址</p>
</li>
<li><p>4字节 目的IP地址</p>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-02f4aa42ece94276.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IP数据报的格式如图3-1所示。普通的1P首部长为20个字节，除非含有送项字段。.png"></p>
<h2 id="2-9-TCP-部首-20-个字节"><a href="#2-9-TCP-部首-20-个字节" class="headerlink" title="2.9 TCP 部首 20 个字节"></a>2.9 TCP 部首 20 个字节</h2><ol>
<li>4字节 ：2字节源端口号，2字节目的端口号</li>
<li>4字节：包序列号 Sequence number: 1    (relative sequence number)</li>
<li>4字节：Ack序列号 Acknowledgment number: 5    (relative ack number)</li>
<li>4字节 4位首部长度、保留6位、6个标志位，16位窗口大小<ul>
<li>4-1.偏移4位，类似IP，表明数据距包头有多少个32位。 0101 …. = Header Length: 20 bytes (5)</li>
<li>4-2.保留6位，未使用，应置零。<pre><code>   000. .... .... = Reserved: Not set
   ...0 .... .... = Nonce: Not set
   .... 0... .... = Congestion Window Reduced (CWR): Not set cwnd
   .... .0.. .... = ECN-Echo: Not set
  * 通告接收窗口（rwnd）：预防应用程序发送的数据超过对方的缓冲区，接收方使用的流量控制。
  * 拥塞窗口（cwnd）：预防应用程序发送的数据超过了网络所能承载的能力。发送方使用的流量控制。
  * 发送窗口：就是指上面两者的较小值
</code></pre>
</li>
<li>4-3.紧急比特URG—当URG＝1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。…. ..0. …. = Urgent: Not set</li>
<li>4-4.确认比特ACK—只有当ACK＝1时确认号字段才有效。当ACK＝0时，确认号无效。…. …1 …. = Acknowledgment: Set</li>
<li>4-5 …. …. 0… = Push: Not set  PSH为1的情况，一般只出现在 DATA内容不为0的包中，也就是说PSH为1表示的是有真正的TCP数据包内容被传递。</li>
<li>4-6.复位比特RST(Reset) —当RST＝1时，表明TCP连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。…. …. .0.. = Reset: Not set</li>
<li>4-7.同步比特SYN—同步比特SYN置为1，就表示这是一个连接请求或连接接受报文。…. …. ..0. = Syn: Not set</li>
<li>4-8.终止比特FIN(FINal)—用来释放一个连接。当FIN＝1时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。…. …. …0 = Fin: Not set</li>
<li>4-9.窗口字段16位，窗口字段用来控制对方发送的数据量，单位为字节。TCP连接的一端根据设置的缓存空间大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限。Window size value: 908</li>
</ul>
</li>
<li>4字节：2字节校验和、2字节紧急指针<ul>
<li>5-1 校验和：源机器基于数据内容计算一个数值，收信息机要与源机器数值 结果完全一样，从而证明数据的有效性。检验和覆盖了整个的TCP报文段：这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证的。Checksum: 0xf3d2 [unverified]</li>
<li>5-2 紧急指针：是一个正偏移量，与序号字段中的值相加表示紧急数据最后一个字节的序号。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式 Urgent pointer: 0 <br><img src="https://upload-images.jianshu.io/upload_images/12321605-1a727839f7143886.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="16位源鈉口号.png"></li>
</ul>
</li>
</ol>
<h2 id="2-10-UDP-首部-8-字节"><a href="#2-10-UDP-首部-8-字节" class="headerlink" title="2.10 UDP 首部 8 字节"></a>2.10 UDP 首部 8 字节</h2><ol>
<li>4字节 ：2字节源端口号，2字节目的端口号</li>
<li>4字节 ：2字节UDP包长度，2字节UDP校验和</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-37a2cbcb16fc6205.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.2 UDP首部.png"></p>
<h1 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h1><h2 id="3-1-浏览器访问一个网址，经历了哪些过程？"><a href="#3-1-浏览器访问一个网址，经历了哪些过程？" class="headerlink" title="3.1 浏览器访问一个网址，经历了哪些过程？"></a>3.1 浏览器访问一个网址，经历了哪些过程？</h2><ol>
<li><p>在浏览器中输入<code>www.example.com</code>域名，操作系统会先检查自己本地的<code>hosts</code>文件是否有这个网址映射关系，如果有，就先调用这个<code>IP</code>地址映射，完成域名解析。</p>
</li>
<li><p>如果<code>hosts</code>里没有这个域名的映射，则查找本地<code>DNS</code>解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</p>
</li>
<li><p>如果<code>hosts</code>与本地<code>DNS</code>解析器缓存都没有相应的网址映射关系，首先会找<code>TCP/IP</code>参数中设置的首选DNS服务器，在此我们叫它本地<code>DNS</code>服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p>
</li>
<li><p>如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个<code>IP</code>地址映射，完成域名解析，此解析不具有权威性。</p>
</li>
<li><p>如果本地<code>DNS</code>服务器本地区域文件与缓存解析都失效，则根据本地<code>DNS</code>服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地<code>DNS</code>就把请求发至<code>13</code>台根<code>DNS</code>，根<code>DNS</code>服务器收到请求后会判断这个域名(<code>.com</code>)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个<code>IP</code>。本地<code>DNS</code>服务器收到<code>IP</code>信息后，将会联系负责<code>.com</code>域的这台服务器。这台负责<code>.com</code>域的服务器收到请求后，如果自己无法解析，它就会找一个管理<code>.com</code>域的下一级<code>DNS</code>服务器地址(<code>http://www.example.com</code>)给本地<code>DNS</code>服务器。当本地<code>DNS</code>服务器收到这个地址后，就会找<code>http://www.example.com</code>域服务器，重复上面的动作，进行查询，直至找到<code>www.example.com</code>主机。</p>
</li>
<li><p>如果用的是转发模式，此<code>DNS</code>服务器就会把请求转发至上一级<code>DNS</code>服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根<code>DNS</code>或把转请求转至上上级，以此循环。不管是本地<code>DNS</code>服务器用是是转发，还是根提示，最后都是把结果返回给本地<code>DNS</code>服务器，由此<code>DNS</code>服务器再返回给客户机。</p>
</li>
</ol>
<h2 id="3-2-https-加密过程？"><a href="#3-2-https-加密过程？" class="headerlink" title="3.2 https 加密过程？"></a>3.2 https 加密过程？</h2><p><code>HTTPS</code>协议是<code>HTTP</code>协议的安全版本，它在<code>HTTP</code>和<code>TCP</code>之间增加了一个安全层（<code>SSL</code>或<code>TLS</code>），用于在数据传输过程中提供加密、完整性和认证。<code>HTTPS</code>加密过程主要在<code>SSL/TLS</code>握手阶段完成，以下是简化的加密过程：</p>
<ol>
<li><p><strong>客户端发起握手请求：</strong> 当浏览器要访问<code>HTTPS</code>网站时，首先会向服务器发送一个<code>Client Hello</code>消息。这个消息中包含客户端支持的<code>SSL/TLS</code>版本、支持的加密算法（如：<code>AES、RSA、SHA</code>等）、支持的压缩方法<strong>以及一个随机数</strong>。</p>
</li>
<li><p><strong>服务器回应握手：</strong> 服务器收到客户端的请求后，会从中选择自己支持的最高<code>SSL/TLS</code>版本、加密算法和压缩方法，并发送一个<code>Server Hello</code>消息给客户端。此消息中包含选定的<code>SSL/TLS</code>版本、加密算法和压缩方法，<strong>以及一个随机数</strong>。服务器还会将其公钥证书（包含公钥）发送给客户端。</p>
</li>
<li><p><strong>验证证书：</strong> 客户端收到服务器的证书后，会首先验证证书的有效性和合法性。通常，这涉及验证证书的颁发机构、签名和过期时间等信息。如果证书验证失败，客户端会发出安全警告，让用户决定是否继续访问。</p>
</li>
<li><p><strong>生成预主密钥和主密钥：</strong> 验证证书后，<strong>客户端会生成一个新的随机数</strong>（预主密钥），然后使用服务器的公钥加密预主密钥，并将其发送给服务器。接着，客户端和服务器利用之前交换的三个随机数（客户端随机数、服务器随机数和预主密钥）通过预定的算法生成主密钥。值得注意的是，由于客户端和服务器都持有这三个随机数和加密算法，因此可以独立地计算出相同的主密钥。</p>
</li>
<li><p><strong>发送”Finished”消息：</strong> 服务器和客户端均完成主密钥的计算后，它们会互相发送<code>Finished</code>消息（由主密钥加密），以确认<code>SSL/TLS</code>连接已经建立。从此以后，双方之间的所有通信都使用这个主密钥进行加密和解密。</p>
</li>
<li><p><strong>数据传输：</strong> 握手完成后，客户端与服务器之间的数据传输将使用主密钥进行加密，确保数据的机密性、完整性和安全性。</p>
</li>
</ol>
<p>双向<code>TLS</code>：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-eb8abcce88a9a944.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pasted Graphic.png"></p>
<h2 id="3-3-证书签名和验签"><a href="#3-3-证书签名和验签" class="headerlink" title="3.3 证书签名和验签"></a>3.3 证书签名和验签</h2><p><img src="https://upload-images.jianshu.io/upload_images/12321605-2a9d1a812f05e536.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="3-4-服务端网络IO线程模型"><a href="#3-4-服务端网络IO线程模型" class="headerlink" title="3.4 服务端网络IO线程模型"></a>3.4 服务端网络IO线程模型</h2><p><strong>一、Thread Per Connection</strong></p>
<pre><code>采用阻塞式 I/O 模型获取输入数据；
每个连接都需要独立的线程完成数据输入，业务处理，数据返回的完整操作。
缺点：
当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大；
连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费。
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-714c4431d96deb48?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><strong>二、单Reactor单线程</strong></p>
<pre><code>优点：简单，没有多线程，没有进程通信
缺点：性能，无法发挥多核的极致，一个handler卡死，导致当前进程无法使用，IO和CPU不匹配
场景：客户端有限，业务处理快，比如redis
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-d410a6277eecae1a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><strong>三、单Reactor多线程</strong></p>
<pre><code>优点：充分利用的CPU
缺点：进程通信，复杂，Reactor承放了太多业务，高并发下可能成为性能瓶颈
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-df0beafafd370a62?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><strong>四、主从Reactor多线程</strong></p>
<pre><code>主Reactor负责建立连接，建立连接后的句柄丢给子Reactor，子Reactor负责监听所有事件进行处理
优点：职责明确，分摊压力
Nginx/netty/memcached都是使用的这
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-4e21da74445bf72e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><strong>五、Proactor 模型（异步IO）</strong></p>
<pre><code>  编程复杂性，由于异步操作流程的事件的初始化和事件完成在时间和空间上都是相互分离的，因此开发异步应用程序更加复杂。应用程序还可能因为反向的流控而变得更加难以 Debug；
  内存使用，缓冲区在读或写操作的时间段内必须保持住，可能造成持续的不确定性，并且每个并发操作都要求有独立的缓存，相比 Reactor 模式，在 Socket 已经准备好读或写前，是不要求开辟缓存的；
  操作系统支持，Windows 下通过 IOCP 实现了真正的异步 I/O，而在 Linux 系统下，Linux 2.6 才引入，目前异步 I/O 还不完善。
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-940d12d2acc853d5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="3-5-Syn攻击原理与防护措施攻击。什么是半连接队列。"><a href="#3-5-Syn攻击原理与防护措施攻击。什么是半连接队列。" class="headerlink" title="3.5 Syn攻击原理与防护措施攻击。什么是半连接队列。"></a>3.5 Syn攻击原理与防护措施攻击。什么是半连接队列。</h2><p><code>SYN</code>攻击（即<code>TCP SYN Flood</code>攻击）是一种常见的拒绝服务（<code>DoS</code>）攻击手段。其基本原理是利用<code>TCP</code>三次握手机制的漏洞向目标服务器发送大量伪造的<code>SYN</code>数据包。攻击者在发送<code>SYN</code>数据包后，不会发送预期的<code>ACK</code>数据包来完成三次握手，从而导致目标服务器维护大量未完成的连接，消耗其资源。当服务器的资源耗尽时，正常的新连接请求将无法处理，导致服务瘫痪。</p>
<p><code>SYN</code>攻击防护措施：</p>
<ul>
<li>增加半连接队列容量： 调整系统参数以增加半连接队列的容量，使其能够容纳更多的半连接，从而降低由<code>SYN</code>攻击导致的服务丢失风险。</li>
<li>减小<code>SYN</code>超时时间： 缩短等待客户端<code>ACK</code>回复的超时时间，使系统能在短时间内回收未被利用的半连接资源。</li>
<li>开启<code>SYN Cookie</code>机制： 启用<code>SYN Cookie</code>功能后，服务器无需为每个<code>SYN</code>连接分配半连接资源。当收到一个<code>SYN</code> 数据包时，服务器会生成一个特殊的<code>Cookie</code>，并将其包含在<code>SYN+ACK</code>数据包中发送给客户端。收到最后的 <code>ACK</code>数据包时，服务器根据<code>Cookie</code>可恢复原始信息。例如，<code>Linux</code>内核中提供的<code>net.ipv4.tcp_syncookies</code>参数可启用<code>SYN Cookie</code>功能。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-0ee1951e25afa0e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="listen().png"></p>
<p><strong>如何知道应用程序的 TCP&nbsp;全连接队列大小？</strong></p>
<p>在服务端可以使用<code>ss</code>命令，来查看<code>TCP</code>全连接队列的情况：</p>
<pre><code>ss -ltn
</code></pre>
<p><strong>全连接队列满了，就只会丢弃连接吗？</strong></p>
<p><code>tcp_abort_on_overflow</code> 共有两个值分别是<code>0</code>和<code>1</code>，其分别表示：</p>
<ul>
<li><code>0</code>：表示如果全连接队列满了，那么<code>server</code>扔掉<code>client</code>发过来的<code>ack</code>；</li>
<li><code>1</code>：表示如果全连接队列满了，那么<code>server</code>发送一个<code>reset</code>包给<code>client</code>，表示废掉这个握手过程和这个连接；</li>
</ul>
<p><strong>如何增大 TCP&nbsp;全连接队列呢？</strong></p>
<p><code>TCP</code>全连接队列足最大值取决于<code>somaxconn</code>和<code>backlog</code>之间的最小值，也就是<code>min(somaxconn, backlog)</code></p>
<p><strong>如何查看 TCP&nbsp;半连接队列长度？</strong></p>
<p>很遗憾，<code>TCP</code>半连接队列长度的长度，没有像全连接队列那样可以用<code>ss</code>命令查看。<br>但是我们可以抓住<code>TCP</code>半连接的特点，就是服务端处于<code>SYN_RECV</code>状态的<code>TCP</code>连接，就是在<code>TCP</code>半连接队列。</p>
<p><strong>如何模拟 TCP&nbsp;半连接队列溢出场景？</strong></p>
<p>模拟<code>TCP</code>半连接溢出场景不难，实际上就是对服务端一直发送<code>TCP SYN</code>包，但是不回第三次握手<code>ACK</code>，这样就会使得服务端有大量的处于<code>SYN_RECV</code>状态的<code>TCP</code>连接。</p>
<p><strong>建链过程中数据包会被丢弃的几种场景</strong></p>
<ul>
<li>如果半连接队列满了，并且没有开启<code>tcp_syncookies</code>，则会丢弃；</li>
<li>若全连接队列满了，且没有重传<code>SYN+ACK</code>包的连接请求多于<code>1</code>个，则会丢弃；</li>
<li>如果没有开启<code>tcp_syncookies</code>，并且<code>max_syn_backlog</code>减去当前半连接队列长度小于 (<code>max_syn_backlog &gt;&gt; 2</code>)，则会丢弃；</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-a6986588fabee2b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="(max_syn_backlog  2).png"></p>
<p><strong>半连接大小由什么决定的？</strong></p>
<p>在<code>Linux 2.6.32</code>内核版本，它们之间的关系，总体可以概况为：</p>
<ul>
<li>当 <code>max_syn_backlog &gt; min(somaxconn, backlog)</code> 时， 半连接队列最大值<code>max_qlen_log = min(somaxconn, backlog) * 2</code>;</li>
<li>当<code>max_syn_backlog &lt; min(somaxconn, backlog)</code>时， 半连接队列最大值<code>max_qlen_log = max_syn_backlog * 2</code>;</li>
</ul>
<h2 id="3-6-Http1-0、Http2-0、Http3-0-区别"><a href="#3-6-Http1-0、Http2-0、Http3-0-区别" class="headerlink" title="3.6 Http1.0、Http2.0、Http3.0 区别"></a>3.6 Http1.0、Http2.0、Http3.0 区别</h2><p><strong>HTTP 1.0 和 HTTP 1.1 的一些区别</strong></p>
<ol>
<li>缓存处理，在<code>HTTP 1.0</code>中主要使用<code>header</code>里的<code>If-Modified-Since</code>,<code>Expires</code>来做为缓存判断的标准，<code>HTTP 1.1</code>则引入了更多的缓存控制策略例如<code>Entity tag</code>，<code>If-Unmodified-Since</code>, <code>If-Match</code>, <code>If-None-Match</code>等更多可供选择的缓存头来控制缓存策略。</li>
<li>带宽优化及网络连接的使用，<code>HTTP 1.0</code>中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，<code>HTTP 1.1</code>则在请求头引入了<code>range</code>头域，它允许只请求资源的某个部分，即返回码是<code>206（Partial Content）</code>，这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li>错误通知的管理，在<code>HTTP 1.1</code>中新增了<code>24</code>个错误状态响应码，如<code>409（Conflict）</code>表示请求的资源与资源的当前状态发生冲突；<code>410（Gone）</code>表示服务器上的某个资源被永久性的删除。</li>
<li><code>Host</code>头处理，在<code>HTTP 1.0</code>中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（<code>hostname</code>）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（<code>Multi-homed Web Servers</code>），并且它们共享一个<code>IP</code>地址。<code>HTTP 1.1</code>的请求消息和响应消息都应支持Host头域，且请求消息中如果没有<code>Host</code>头域会报告一个错误（<code>400 Bad Request</code>）。</li>
<li>长连接，<code>HTTP 1.1</code>支持长连接（<code>PersistentConnection</code>）和请求</li>
<li>流水线（<code>Pipelining</code>）处理，在一个<code>TCP</code>连接上可以传送多个<code>HTTP</code>请求和响应，减少了建立和关闭连接的消耗和延迟，在<code>HTTP 1.1</code>中默认开启<code>Connection:keep-alive</code>，一定程度上弥补了<code>HTTP 1.0</code>每次请求都要创建连接的缺点。 </li>
</ol>
<p><strong>HTTP 2.0</strong></p>
<ul>
<li><strong>二进制分帧层</strong> (<code>Binary Framing Layer</code>)，帧是数据传输的最小单位，每个帧都有不同的类型和用途，规范中定义了<code>10</code>种不同的帧。例如，报头(<code>HEADERS</code>)和数据(<code>DATA</code>)帧组成了基本的<code>HTTP</code> 请求和响应；其他帧例如设置(<code>SETTINGS</code>),窗口更新(<code>WINDOW_UPDATE</code>), 和推送承诺(<code>PUSH_PROMISE</code>)是用来实现<code>HTTP/2</code>的其他功能。那些请求和响应的帧数据通过流来进行数据交换。新的二进制格式是流量控制、优先级、<code>server push</code>等功能的基础</li>
<li><strong>多路复用</strong>：也就是连接共享，刚才说到<code>HTTP1.1</code>的<code>head of line blocking</code>，那么在多路复用的情况下，<code>blocking</code>已经不存在了。每个连接中可以包含多个流，而每个流中交错包含着来自两端的帧。也就是说同一个连接中是来自不同流的数据包混合在一起，如下图所示，每一块代表帧，而相同颜色块来自同一个流，每个流都有自己的<code>ID</code>，在接收端会根据<code>ID</code>进行重装组合，就是通过这样一种方式来实现多路复用。</li>
<li><strong>头部压缩</strong>：<code>HTTP 2.0</code>通过<code>HPACK</code>格式来压缩头部，使用了哈夫曼编码压缩、索引表来对头部大小做优化。索引表是把字符串和数字之间做一个匹配，比如<code>method:GET</code>对应索引表中的<code>2</code>，那么如果之前发送过这个值是，就会缓存起来，之后使用时发现之前发送过该<code>Header</code>字段，并且值相同，就会沿用之前的索引来指代那个<code>Header</code>值。</li>
<li><strong>Server Push</strong>：就是服务端可以主动推送一些东西给客户端，也被称为缓存推送。推送的资源可以备客户端日后之需，需要的时候直接拿出来用，提升了速率。</li>
<li><strong>请求优先级设置</strong>，<code>HTTP/2</code>里的每个<code>stream</code>都可以设置依赖 (<code>Dependency</code>) 和权重，可以按依赖树分配优先级，解决了关键请求被阻塞的问题</li>
<li><strong>流量控制</strong>，每个<code>http2</code>流都拥有自己的公示的流量窗口，它可以限制另一端发送数据。对于每个流来说，两端都必须告诉对方自己还有足够的空间来处理新的数据，而在该窗口被扩大前，另一端只被允许发送这么多数据。</li>
</ul>
<p><strong>HTTP 3.0 (QUIC Quick UDP Internet Connection)</strong></p>
<ul>
<li>线头阻塞(<code>HOL</code>)问题的解决更为彻底：基于<code>TCP</code>的<code>HTTP/2</code>，尽管从逻辑上来说，不同的流之间相互独立，不会相互影响，但在实际传输方面，数据还是要一帧一帧的发送和接收，一旦某一个流的数据有丢包，则同样会阻塞在它之后传输的流数据传输。而基于<code>UDP</code>的<code>QUIC</code>协议则可以更为彻底地解决这样的问题，让不同的流之间真正的实现相互独立传输，互不干扰。</li>
<li>切换网络时的连接保持：当前移动端的应用环境，用户的网络可能会经常切换，比如从办公室或家里出门，<code>WiFi</code>断开，网络切换为<code>3G</code>或<code>4G</code>。基于<code>TCP</code>的协议，由于切换网络之后，<code>IP</code>会改变，因而之前的连接不可能继续保持。而基于<code>UDP</code>的<code>QUIC</code>协议，则可以内建与<code>TCP</code>中不同的连接标识方法，从而在网络完成切换之后，恢复之前与服务器的连接。</li>
</ul>
<p><code>QUIC</code>很好地解决了当今传输层和应用层面临的各种需求，包括处理更多的连接，安全性，和低延迟。<code>QUIC</code>融合了包括<code>TCP</code>，<code>TLS</code>，<code>HTTP/2</code>等协议的特性，但基于<code>UDP</code>传输。<code>QUIC</code>的一个主要目标就是减少连接延迟，当客户端第一次连接服务器时，<code>QUIC</code>只需要<code>1RTT（Round-Trip Time）</code>的延迟就可以建立可靠安全的连接,相对于<code>TCP+TLS</code>的<code>1-3</code>次<code>RTT</code>要更加快捷。之后客户端可以在本地缓存加密的认证信息，在再次与服务器建立连接时可以实现<code>0-RTT</code>的连接建立延迟。<code>QUIC</code>同时复用了<code>HTTP/2</code>协议的多路复用功能（<code>Multiplexing</code>），但由于<code>QUIC</code>基于<code>UDP</code>所以避免了<code>HTTP/2</code>的线头阻塞（<code>Head-of-Line Blocking</code>）问题。因为<code>QUIC</code>基于<code>UDP</code>，运行在用户域而不是系统内核，使得<code>QUIC</code>协议可以快速的更新和部署，从而很好地解决了<code>TCP</code>协议部署及更新的困难。</p>
<h2 id="3-7-http-cache"><a href="#3-7-http-cache" class="headerlink" title="3.7 http-cache"></a>3.7 http-cache</h2><ul>
<li><code>max-age</code>：用来设置资源（<code>representations</code>）可以被缓存多长时间，单位为秒；</li>
<li><code>s-maxage</code>：和<code>max-age</code>是一样的，不过它只针对代理服务器缓存而言；</li>
<li><code>public</code>：指示响应可被任何缓存区缓存；</li>
<li><code>private</code>：只能针对个人用户，而不能被代理服务器缓存；</li>
<li><code>no-cache</code>：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。这个很容易让人产生误解，使人误以为是响应不被缓存。实际上<code>Cache-Control:no-cache</code>是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。</li>
<li><code>no-store</code>：禁止一切缓存（这个才是响应不被缓存的意思）。</li>
</ul>
<h2 id="3-8-什么是XSS攻击、CSRF攻击？有什么常见的预防。"><a href="#3-8-什么是XSS攻击、CSRF攻击？有什么常见的预防。" class="headerlink" title="3.8 什么是XSS攻击、CSRF攻击？有什么常见的预防。"></a>3.8 什么是XSS攻击、CSRF攻击？有什么常见的预防。</h2><p><strong>XSS 攻击（Cross-Site Scripting）：</strong></p>
<p><code>XSS</code>攻击是一种常见的<code>Web</code>安全漏洞。攻击者通过注入恶意脚本（通常为<code>JavaScript</code>代码）到目标网站上的页面中，使用户在浏览该页面时执行这些恶意脚本。执行脚本可能导致用户数据泄露、账户被盗、基于浏览器的攻击等。</p>
<p><strong>XSS 攻击预防：</strong></p>
<ol>
<li>输出转义/编码：对在网页显示的用户输入内容进行转义/编码，以防止<code>HTML/JavaScript</code>代码被执行。</li>
<li>输入验证：确保用户输入仅包含预期的字符集，限制输入长度, 验证格式以防止恶意脚本注入。</li>
<li>采用<code>CSP</code>（内容安全策略）：通过为浏览器设定特定的安全策略来限制代码执行。例如，只允许执行来自可信域名的脚本。</li>
<li>使用<code>HttpOnly Cookie</code>：避免<code>Cookie</code>串中敏感信息被暴露给脚本访问。</li>
<li>移除不需要的<code>XSS</code>攻击点：减少不必要的<code>HTML</code>类型，过滤可执行的脚本标签等。</li>
</ol>
<p><strong>CSRF 攻击（Cross-Site Request Forgery）：</strong></p>
<p><code>CSRF</code>攻击是一种利用用户已登录状态发起非法请求的攻击手法。攻击者通过诱导用户浏览恶意页面或点击链接，利用用户的登录状态和权限在背后执行未经授权的操作。</p>
<p><strong>CSRF 攻击预防：</strong></p>
<ol>
<li>使用<code>CSRF Token</code>：为每个请求生成一个随机的、唯一的<code>CSRF</code>令牌，确保仅允许来自授权请求的操作。</li>
<li>验证<code>HTTP Referer</code>：检查请求的来源，确保请求仅来自合法的站点。</li>
<li>使用<code>SameSite Cookie</code> 属性：限制第三方站点发送带有登录信息的请求，降低<code>CSRF</code>攻击的风险。</li>
<li>添加验证码：对敏感操作添加验证码，确保只有经过人工确认的操作才能执行。</li>
<li>使用强制登录：较短的会话有效期，定期强制用户重新登录，限制攻击者的有效期。</li>
<li>遵循最低权限原则：对用户操作实施权限控制，确保用户只能访问其应有权限的资源和操作。</li>
</ol>
<h2 id="3-9-网络传输协议对比-Thrift-vs-Protobuf"><a href="#3-9-网络传输协议对比-Thrift-vs-Protobuf" class="headerlink" title="3.9 网络传输协议对比 Thrift vs Protobuf"></a>3.9 网络传输协议对比 Thrift vs Protobuf</h2><p><strong>Protobuf 数据压缩方式</strong></p>
<ol>
<li><code>varints</code> 编码 （第一位表示<code>0</code>表示没有，<code>1</code>表示后面还有数据），后<code>7</code>位正常表示</li>
<li><code>Zigzag</code> 编码 （符号位放到最后一位，<code>-1</code>编码成<code>1</code>，<code>1</code>编码从<code>2</code>，<code>-2</code>编码成<code>3</code>）<code>sint32</code>和<code>sint64</code>使用的<code>zigzag</code>编码。</li>
<li><code>PB</code>的<code>tag</code>字段是用的<code>varints</code>编码，第一个<code>bit</code>表示是否有更多，后<code>4</code>位表示<code>tag index</code>（字段的序号为），后<code>3</code>位表示<code>wire_type</code><ul>
<li>0：<code>varints</code> </li>
<li>1：固定<code>64</code>位、</li>
<li>2：表示<code>tag - lenght - value</code>编码</li>
<li>5：表示固定<code>32</code>位</li>
</ul>
</li>
<li><code>string，bytes，message</code>都是采用<code>tlv</code>编码</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-21b379fd867ffdc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Protocol Buffers.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-6ef0b3aa7adab0ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="关键技术—message structure编码.png"></p>
<p><strong>Thrift 数据压缩方式</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-58014e2549beb6ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="E og 4d G1 72 24 60 2a.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-bbc026cddfb67d7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Thrift BinaryProtocol.png"></p>
<h2 id="3-10-Nginx解决惊群现象？"><a href="#3-10-Nginx解决惊群现象？" class="headerlink" title="3.10 Nginx解决惊群现象？"></a>3.10 Nginx解决惊群现象？</h2><p>简而言之，惊群现象（<code>thundering herd</code>）就是当多个进程和线程在同时阻塞等待同一个事件时，如果这个事件发生，会唤醒所有的进程，但最终只可能有一个进程/线程对该事件进行处理，其他进程/线程会在失败后重新休眠，这种性能浪费就是惊群。</p>
<ul>
<li>早期<code>Nginx</code>解决惊群的方式是加锁，多个进程之间共享一个文件锁，只有在抢到这个锁的时候，这个进程才会将要监听的端口放到<code>epoll</code>中，当<code>epoll_wait</code>返回之后，<code>nginx</code>会调用<code>accept</code>把连接取出来，然后释放文件锁，让别的进程去监听。</li>
<li><code>SO_REUSEPORT</code>可以防止惊群效应，<code>nginx</code>在<code>1.11</code>版本以上，已经默认打开了<code>SO_REUSEPORT</code>选项，解决了这个问题。</li>
<li><code>Linux</code>从内核版本<code>4.5</code>开始通过引入<code>EPOLLEXCLUSIVE</code>标志来解决<code>epoll</code>惊群现象。在使用这个标志时，只有一个线程会被唤醒，而不是唤醒所有等待该事件的线程。这可以显著降低在多线程编程中出现的惊群现象。</li>
<li><code>Linux 2.6</code>版本之后，通过引入一个标记位 <code>WQ_FLAG_EXCLUSIVE</code>，解决掉了<code>Accept</code>惊群效应。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/kKyLZqAzDomqDkwXgXGv">Linux 惊群效应之 Nginx 解决方案</a></p>
<h2 id="3-11-Traceroute原理？"><a href="#3-11-Traceroute原理？" class="headerlink" title="3.11 Traceroute原理？"></a>3.11 Traceroute原理？</h2><p><code>Traceroute</code>（又称路由追踪）是一种网络诊断工具，用于确定数据包在源主机和目的主机之间传输的路径。同时，它也提供了关于网络延迟和每个路径上的网络节点的详细信息。<code>Traceroute</code> 主要通过利用互联网协议（<code>IP</code>）和用户数据报协议（<code>UDP</code>）或<code>Internet</code>控制报文协议（<code>ICMP</code>）的特性来实现这个目标。</p>
<p><code>Traceroute</code>的原理如下：</p>
<ol>
<li>发送数据包：<code>Traceroute</code>从源主机（发送方）向目标主机（接收方）发送一系列数据包。这些数据包的<code>Time-To-Live（TTL）</code>值从1逐渐增加。<code>TTL</code>是<code>IP</code>数据包中的一个字段，用于指示数据包在网络上路由的最大跳数。当<code>TTL</code>值为<code>0</code>时，就不再继续进行路由。</li>
<li>路由节点递减 <code>TTL</code>：在路径上的每个路由节点（路由器）在转发数据包时，会将<code>TTL</code>值减<code>1</code>。当<code>TTL</code>变为<code>0</code>时，路由节点会放弃转发该数据包，并通常会向源主机发送<code>ICMP</code>“超时”消息（Time Exceeded）。</li>
<li>获取路径信息：源主机接收到<code>ICMP</code>“超时”消息后，会根据消息中的信息记录发送该消息的路由节点。通过逐步增加<code>TTL</code>值，<code>traceroute</code>可以获取源主机到目标主机之间的每个路径节点。</li>
<li>检测到目标主机：当数据包到达目标主机时，目标主机通常会发送一个<code>ICMP</code>“端口不可达”消息（<code>Port Unreachable</code>），或者某些系统下的<code>TTL 超时</code>消息，以通知源主机。收到这些消息的源主机即可确认路径已经完成，并结束<code>traceroute</code>过程。</li>
<li>计算延迟：<code>Traceroute</code>通常为每个递增的<code>TTL</code>值发送多个数据包以获得准确的平均延迟。它会计算发送数据包和接收<code>ICMP</code>消息之间的时间差，以确定每个路由节点的延迟。</li>
<li>输出结果：最后，<code>traceroute</code>工具以易于阅读的格式显示源主机到目标主机间经过的所有路径节点和延迟信息。</li>
</ol>
<h2 id="3-12-路由协议？-RIP、OSPF、BGP？"><a href="#3-12-路由协议？-RIP、OSPF、BGP？" class="headerlink" title="3.12 路由协议？ RIP、OSPF、BGP？"></a>3.12 路由协议？ RIP、OSPF、BGP？</h2><ul>
<li><code>RIP</code>很早就被用在<code>Internet</code>上，是最简单的路由协议。它是“路由信息协议（<code>Route Information Protocol</code>）”的简写，主要传递路由信息，通过每隔<code>30</code>秒广播一次路由表，维护相邻路由器的位置关系，同时根据收到的路由表信息计算自己的路由表信息。<code>RIP</code>是一个距离矢量路由协议，最大跳数为<code>15</code>跳，超过<code>15</code>跳的网络则认为目标网络不可达。此协议通常用在网络架构较为简单的小型网络环境。分为<code>RIPv1</code>和<code>RIPv2</code>两个版本，后者支持<code>VLSM</code>技术以及一系列技术上的改进。<code>RIP</code>的收敛速度较慢。</li>
<li><code>OSPF</code>协议是“开放式最短路径优先（<code>Open Shortest Path First</code>）”的缩写，属于链路状态路由协议。<code>OSPF</code>提出了“区域（<code>area</code>）”的概念，每个区域中所有路由器维护着一个相同的链路状态数据库（<code>LSDB</code>）。区域又分为骨干区域（骨干区域的编号必须为<code>0</code>）和非骨干区域（非0编号区域），如果一个运行<code>OSPF</code>的网络只存在单一区域，则该区域可以是骨干区域或者非骨干区域。如果该网络存在多个区域，那么必须存在骨干区域，并且所有非骨干区域必须和骨干区域直接相连。<code>OSPF</code>利用所维护的链路状态数据库，通过最短路径优先算法（<code>SPF</code>算法）计算得到路由表。<code>OSPF</code>的收敛速度较快。由于其特有的开放性以及良好的扩展性，<code>OSPF</code>协议在各种网络中广泛部署。</li>
<li><code>BGP</code>为了维护各个<code>ISP</code>的独立利益，标准化组织制定了<code>ISP</code>间的路由协议<code>BGP</code>。<code>BGP</code>是“边界网关协议（<code>Border Gateway Protocol</code>）”的缩写，处理各<code>ISP</code>之间的路由传递。但是<code>BGP</code>运行在相对核心的地位，需要用户对网络的结构有相当的了解，否则可能会造成较大损失。&nbsp;</li>
</ul>
<h2 id="3-13-NAT？P2P穿透？"><a href="#3-13-NAT？P2P穿透？" class="headerlink" title="3.13 NAT？P2P穿透？"></a>3.13 NAT？P2P穿透？</h2><p><strong>NAT分类</strong></p>
<p><code>NAT</code>从表面上看有三种类型：<code>静态NAT</code>、<code>动态地址NAT</code>、<code>地址端口转换NAPT</code>。　　<br>（1）<code>静态NAT</code>：静态地址转换将内部私网地址与合法公网地址进行一对一的转换，且每个内部地址的转换都是确定的。<br>（2）<code>动态NAT</code>：动态地址转换也是将内部本地地址与内部合法地址一对一的转换，但是动态地址转换是从合法地址池中动态选择一个未使用的地址来对内部私有地址进行转换。<br>（3）<code>NAPT</code>：它也是一种动态转换，而且多个内部地址被转换成同一个合法公网地址，使用不同的端口号来区分不同的主机，不同的进程。 </p>
<p>从实现的技术角度，又可以将<code>NAT</code>分成如下几类：<code>全锥NAT(Full Cone NAT)</code>、<code>限制性锥NAT（Restricted Cone NAT）</code>、<code>端口限制性锥NAT( Port Restricted Cone NAT)</code>、<code>对称NAT ( Symmetric NAT)</code>。<br>（1）<code>全锥NAT</code>：<code>全锥NAT</code>把所有来自相同内部<code>IP</code>地址和端口的请求映射到相同的外部<code>IP</code>地址和端口。任何一个外部主机均可通过该映射发送数据包到该内部主机。 （<strong>电信</strong>）<br>（2）<code>限制性锥NAT</code>：<code>限制性锥NAT</code>把所有来自相同内部<code>IP</code>地址和端口的请求映射到相同的外部<code>IP</code>地址和端口。但是,和<code>全锥NAT</code>不同的是：只有当内部主机先给外部主机发送数据包,该外部主机才能向该内部主机发送数据包。<br>（3）<code>端口限制性锥NAT</code>：<code>端口限制性锥NAT</code>与<code>限制性锥NAT</code>类似,只是多了端口号的限制,即只有内部主机先向外部地址：端口号对发送数据包,该外部主机才能使用特定的端口号向内部主机发送数据包。（<strong>联通</strong>）<br>（4）<code>对称NAT</code>：<code>对称NAT</code>与上述3种类型都不同,不管是<code>全锥NAT</code>，<code>限制性锥NAT</code>还是<code>端口限制性锥NAT</code>，它们都属于<code>锥NAT（Cone NAT）</code>。当同一内部主机使用相同的端口与不同地址的外部主机进行通信时, <code>对称NAT</code>会重新建立一个<code>Session</code>，为这个<code>Session</code>分配不同的端口号，或许还会改变<code>IP</code>地址。 </p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-b72e194cf4db641e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Server ( Web、 FIP. POP3、 SMTP、.png"></p>
<h2 id="3-14-操作系统收取数据包原理"><a href="#3-14-操作系统收取数据包原理" class="headerlink" title="3.14 操作系统收取数据包原理"></a>3.14 操作系统收取数据包原理</h2><p><img src="https://upload-images.jianshu.io/upload_images/12321605-b9a1e0c96d187a2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="unknown.png"></p>
<h2 id="3-15-OSI-七层和-TCP-IP-四层"><a href="#3-15-OSI-七层和-TCP-IP-四层" class="headerlink" title="3.15 OSI 七层和 TCP/IP 四层"></a>3.15 OSI 七层和 TCP/IP 四层</h2><p><img src="https://upload-images.jianshu.io/upload_images/12321605-117970b914c75d65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="unknown.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-f07f4e4fca1e35b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="unknown.png"></p>
<h2 id="3-16-网络包接收流程"><a href="#3-16-网络包接收流程" class="headerlink" title="3.16 网络包接收流程"></a>3.16 网络包接收流程</h2><p>网络帧到达网卡-&gt; <code>DMA</code> 把数据放到收到队列 -&gt; 硬中断-&gt; 网卡中断处理程序会为 网络帧分配（<code>SK_Buff</code>）-&gt; 拷贝到 <code>SK_Buff</code>  缓冲区 -&gt; 软中断 -&gt; 通知内核收到行的网络帧<br>接下来内核会从协议栈缓存区 取出 网络帧，从下到上逐层解析比如 -&gt; 链路层检查报文合法性，找出上层协议。<br>-&gt;网络层取出<code>IP</code>头，判断网络包下一步走向，比如是交给上层处理还是转发，当确认是发送到本机以后，就会取出上层协议（<code>TCP</code>还是<code>UDP</code>），去掉IP头给上层处理<br>-&gt; 根据 <code>IP+Port</code> 四元组 做表示 找到对应<code>Socket</code>，把数据拷贝到<code>Scoket</code>接收缓存中。</p>
<h2 id="3-17-其他"><a href="#3-17-其他" class="headerlink" title="3.17 其他"></a>3.17 其他</h2><p><img src="https://upload-images.jianshu.io/upload_images/12321605-a501c30d149ce748.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DAM## (RFC 894).jpg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-94eeb4706996818c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ROSMAC 1M2UC -+1-NO2SNAP•.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-b993f27fac2652b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1-7 数据进入协议栈时的封裘过程.png"></p>
<p><strong>路径MTU</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-c285a742769f76eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.9 路径MTU.png"></p>
<p><strong>ARP</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-327606f6dc015645.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拿段的炎型和长度)。.png"></p>
<p><strong>ICMP</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-00663c9466d37eef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ICMP蛏常被认为是 1P展的一个組成部分。它传递差错级文以及其他需要注意的信息。.png"></p>
<p><strong>ICMP地址掩码请求和应答报文</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-0e62ccbe220908d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15 16.png"></p>
<p><strong>“UDP端口不可达”例子中返回的ICMP报文</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-067ac4e5651e5c1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="KCMPN文.png"></p>
<p><strong>Ping</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-819bd36a5b513142.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.2 Ping程序.png"></p>
<p><strong>RIP</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-8d11d32e2875a1e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.4 RIP：选路信息协议.png"></p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em></section><article class="mt-6 comment-container"><script async repo="fanlv/blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/fanlv"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com/fanlvlgh"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Ryo 2025</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p class="is-flex is-justify-content-center"><a title="备案号：鄂ICP备2022016224号-2" target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn/">备案号：鄂ICP备2022016224号-2 &nbsp;</a></p></div><div><span>博学之，审问之，慎思之，明辨之，笃行之</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>