<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>MySQL 基础</title><meta name="description" content="行万里路，读万卷书"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "https://hm.baidu.com/hm.js?" + '2c076421eb9f21a0a143f8ee9c4ab171';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><meta name="referrer" content="no-referrer"><link rel="icon" href="/null"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="一、基础1.1 常用索引有哪些普通索引、唯一索引、主键索引、组合索引、全文索引
1.2 聚集索引和非聚集索引区别聚集索引（Clustered Index）和非聚集索引（Non-clustered Index）是两种不同类型的数据库索引，它们的区别如下：

聚集索引（Clustered Index）：

聚集索引中的数据行和索引的顺序相同，即它将数据行本身和索引按照相同的排序方式存储在一起。
一个表只能有一个聚集索引，因为数据行只能以一种顺序存储。
聚集索引通常用主键建立，但也可以使用其他具有唯一约束的列。
数据的物理存储顺序与索引的顺序相同，所以聚集索引通常提供较快的数据检索。


非聚集索引（Non-clustered Index）：

非聚集索引与聚集索引分开存储，数据行的顺序与索引的顺序无关。
一个表.."><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Ryo's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">MySQL 基础</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80"><span class="toc-text">一、基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%B8%B8%E7%94%A8%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">1.1 常用索引有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%8C%BA%E5%88%AB"><span class="toc-text">1.2 聚集索引和非聚集索引区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Mysql-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-B-%E6%A0%91%EF%BC%88B-Tree%EF%BC%89%E4%BD%9C%E4%B8%BA%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">1.3 Mysql 为什么使用 B+树（B+Tree）作为存储的数据结构？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Mysql-%E7%9A%84-B-Tree-%E9%9D%9E%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%9C%89%E5%A4%9A%E5%B0%91%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%80%E8%88%AC%E6%9C%89%E5%87%A0%E5%B1%82%E3%80%82"><span class="toc-text">1.4 Mysql 的 B+Tree 非叶子节点有多少数据，一般有几层。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-MyISAM%E3%80%81InnoDB-%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.5 MyISAM、InnoDB 索引实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-MyISAM%E4%B8%8EInnoDB%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1.6 MyISAM与InnoDB的主要区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E5%AD%97%E6%AE%B5%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%A5%BD%E5%A4%84%EF%BC%9F%E6%98%AF%E4%B8%8D%E6%98%AF%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD%EF%BC%9F"><span class="toc-text">1.7 字段建索引好处？是不是越多越好？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-MySQL-%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0"><span class="toc-text">1.8 MySQL 慢查询常见原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-SQL-%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99%EF%BC%8C%E7%B4%A2%E5%BC%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9F"><span class="toc-text">1.9 SQL 优化原则，索引注意事项？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-%E4%BA%8B%E5%8A%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E5%BE%81-ACID"><span class="toc-text">1.10 事务四大特征(ACID)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-11-%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">1.11 事务有哪四种隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-12-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB%EF%BC%9F%E5%AF%B9%E5%BA%94SQL%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">1.12 什么是当前读和快照读？对应SQL怎么实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-13-%E4%BB%80%E4%B9%88%E6%98%AFMVCC%EF%BC%88Multi-Version-Concurrency-Control%EF%BC%8C%E5%8D%B3%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%89%EF%BC%9F"><span class="toc-text">1.13 什么是MVCC（Multi-Version Concurrency Control，即多版本并发控制）？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81MySQL-%E6%97%A5%E5%BF%97%E5%9F%BA%E7%A1%80"><span class="toc-text">二、MySQL 日志基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AF-binlog"><span class="toc-text">2.1 什么是 binlog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E4%BB%80%E4%B9%88%E6%98%AF-redo-log"><span class="toc-text">2.2 什么是 redo log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-binlog-%E5%92%8C-redo-log-%E5%8C%BA%E5%88%AB"><span class="toc-text">2.3 binlog 和 redo log 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-binlog-%E7%9A%84%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-text">2.4 binlog 的写入机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-redo-%E7%9A%84%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-text">2.5 redo 的写入机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-redo-log-%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E6%8F%90%E4%BA%A4%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%9A%84-redo-log-%E6%98%AF%E5%90%A6%E6%9C%89%E5%8F%AF%E8%83%BD%E5%86%99%E5%85%A5%E5%88%B0%E7%A3%81%E7%9B%98%E4%B8%AD%EF%BC%9F"><span class="toc-text">2.6 redo log 存储方式，一个没有提交的事务的 redo log 是否有可能写入到磁盘中？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-redo-log%E7%BB%84%E6%8F%90%E4%BA%A4%EF%BC%88group-commit%EF%BC%89%E6%9C%BA%E5%88%B6"><span class="toc-text">2.7 redo log组提交（group commit）机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-Binlog-%E5%92%8C-Redolog-%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4"><span class="toc-text">2.8 Binlog 和 Redolog 记录如何保持一致</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA-update-%E8%AF%AD%E5%8F%A5%E4%BB%A5%E5%90%8E%EF%BC%8C%E6%88%91%E5%86%8D%E5%8E%BB%E6%89%A7%E8%A1%8C-hexdump-%E5%91%BD%E4%BB%A4%E7%9B%B4%E6%8E%A5%E6%9F%A5%E7%9C%8B-ibd-%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E7%9C%8B%E5%88%B0%E6%95%B0%E6%8D%AE%E6%9C%89%E6%94%B9%E5%8F%98%E5%91%A2"><span class="toc-text">2.9 执行一个 update 语句以后，我再去执行 hexdump 命令直接查看 ibd 文件内容，为什么没有看到数据有改变呢</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-%E4%B8%BA%E4%BB%80%E4%B9%88-binlog-cache-%E6%98%AF%E6%AF%8F%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%87%AA%E5%B7%B1%E7%BB%B4%E6%8A%A4%E7%9A%84%EF%BC%8C%E8%80%8C-redo-log-buffer-%E6%98%AF%E5%85%A8%E5%B1%80%E5%85%B1%E7%94%A8%E7%9A%84"><span class="toc-text">2.10 为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11-%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%9C%9F%E9%97%B4%EF%BC%8C%E8%BF%98%E6%B2%A1%E5%88%B0%E6%8F%90%E4%BA%A4%E9%98%B6%E6%AE%B5%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%8F%91%E7%94%9F-crash-%E7%9A%84%E8%AF%9D%EF%BC%8Credo-log-%E8%82%AF%E5%AE%9A%E4%B8%A2%E4%BA%86%EF%BC%8C%E8%BF%99%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%B8%BB%E5%A4%87%E4%B8%8D%E4%B8%80%E8%87%B4%E5%91%A2%EF%BC%9F"><span class="toc-text">2.11 事务执行期间，还没到提交阶段，如果发生 crash 的话，redo log 肯定丢了，这会不会导致主备不一致呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-12-MySQL-%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93-binlog-%E6%98%AF%E5%AE%8C%E6%95%B4%E7%9A%84"><span class="toc-text">2.12 MySQL 怎么知道 binlog 是完整的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-13-redo-log-%E5%92%8C-binlog-%E6%98%AF%E6%80%8E%E4%B9%88%E5%85%B3%E8%81%94%E8%B5%B7%E6%9D%A5%E7%9A%84"><span class="toc-text">2.13 redo log 和 binlog 是怎么关联起来的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-14-%E5%A4%84%E4%BA%8E-prepare-%E9%98%B6%E6%AE%B5%E7%9A%84-redo-log-%E5%8A%A0%E4%B8%8A%E5%AE%8C%E6%95%B4-binlog%EF%BC%8C%E9%87%8D%E5%90%AF%E5%B0%B1%E8%83%BD%E6%81%A2%E5%A4%8D%EF%BC%8CMySQL-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E4%B9%88%E8%AE%BE%E8%AE%A1"><span class="toc-text">2.14 处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-15-%E5%A6%82%E6%9E%9C%E8%BF%99%E6%A0%B7%E7%9A%84%E8%AF%9D%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%91%A2%EF%BC%9F%E5%B9%B2%E8%84%86%E5%85%88-redo-log-%E5%86%99%E5%AE%8C%EF%BC%8C%E5%86%8D%E5%86%99-binlog%E3%80%82%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%BF%85%E9%A1%BB%E5%BE%97%E4%B8%A4%E4%B8%AA%E6%97%A5%E5%BF%97%E9%83%BD%E5%AE%8C%E6%95%B4%E6%89%8D%E5%8F%AF%E4%BB%A5%E3%80%82%E6%98%AF%E4%B8%8D%E6%98%AF%E4%B8%80%E6%A0%B7%E7%9A%84%E9%80%BB%E8%BE%91"><span class="toc-text">2.15 如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-16-%E8%83%BD%E4%B8%8D%E8%83%BD%E5%8F%AA%E7%94%A8-redo-log%EF%BC%8C%E4%B8%8D%E8%A6%81-binlog"><span class="toc-text">2.16 能不能只用 redo log，不要 binlog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-17-redo-log%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%EF%BC%9F%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E8%90%BD%E7%9B%98%EF%BC%8C%E6%98%AF%E4%BB%8E-redo-log-%E6%9B%B4%E6%96%B0%E8%BF%87%E6%9D%A5%E7%9A%84%E8%BF%98%E6%98%AF%E4%BB%8E-buffer-pool-%E6%9B%B4%E6%96%B0%E8%BF%87%E6%9D%A5%E7%9A%84%E5%91%A2"><span class="toc-text">2.17 redo log崩溃恢复？正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-18-redo-log-buffer-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%98%AF%E5%85%88%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98%EF%BC%8C%E8%BF%98%E6%98%AF%E5%85%88%E5%86%99-redo-log-%E6%96%87%E4%BB%B6"><span class="toc-text">2.18 redo log buffer 是什么？是先修改内存，还是先写 redo log 文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-19-%E4%B8%BA%E4%BB%80%E4%B9%88binlog-%E6%98%AF%E4%B8%8D%E8%83%BD%E2%80%9C%E8%A2%AB%E6%89%93%E6%96%AD%E7%9A%84%E2%80%9D%E7%9A%84"><span class="toc-text">2.19 为什么binlog 是不能“被打断的”的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-20-undolog%E5%B9%B2%E5%98%9B%E7%9A%84%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%88%B0%EF%BC%9F%E9%95%BF%E4%BA%8B%E5%8A%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%9D%8F%E5%A4%84%EF%BC%9F"><span class="toc-text">2.20 undolog干嘛的，什么时候用到？长事务有什么坏处？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-21-binlog-%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A0%BC%E5%BC%8F"><span class="toc-text">2.21 binlog 的三种格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-22-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89-mixed-%E6%A0%BC%E5%BC%8F%E7%9A%84-binlog%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8mixed%E6%A0%BC%E5%BC%8F%E6%97%A5%E5%BF%97%EF%BC%9F"><span class="toc-text">2.22 为什么会有 mixed 格式的 binlog？为什么不用mixed格式日志？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%85%B6%E4%BB%96"><span class="toc-text">三、其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E4%BA%8B%E5%8A%A1%E5%BC%80%E5%A7%8B%E7%9A%84%E6%97%B6%E6%9C%BA%EF%BC%9F"><span class="toc-text">3.1 事务开始的时机？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%BA%8B%E5%8A%A1%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E6%98%AF%E5%A6%82%E4%BD%95%E9%9A%94%E7%A6%BB%E7%9A%84%EF%BC%9F"><span class="toc-text">3.2 事务数据读取是如何隔离的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%84%E8%AF%BB%EF%BC%9F%E9%A2%84%E8%AF%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%95%88%EF%BC%9F"><span class="toc-text">3.3 什么是预读？预读为什么有效？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%86%B2%E6%B1%A0-buffer-pool"><span class="toc-text">3.4 什么是缓冲池(buffer pool)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%86%99%E7%BC%93%E5%86%B2-change-buffer"><span class="toc-text">3.5 写缓冲(change buffer)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-InnoDB%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C"><span class="toc-text">3.6 InnoDB自适应哈希</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E4%B8%80%E4%B8%AA-SQL-%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-text">3.7 一个 SQL 查询过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E4%B8%80%E4%B8%AASQL-%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B"><span class="toc-text">3.8 一个SQL 更新过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-Mysql-%E4%BC%98%E5%8C%96%E5%99%A8-%E4%BC%98%E5%8C%96%E5%99%A8%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%B4%A2%E5%BC%95%E7%9A%84"><span class="toc-text">3.9 Mysql 优化器, 优化器如何选择索引的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-%E4%BB%80%E4%B9%88%E6%98%AF%E8%B4%A6%E9%A1%B5%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%BC%9A%E5%BC%BA%E5%88%B6%E5%88%B7%E8%84%8F%E9%A1%B5%EF%BC%9F"><span class="toc-text">3.10 什么是账页，有哪些场景会强制刷脏页？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-11-%E5%BD%93-MySQL-%E5%8E%BB%E6%9B%B4%E6%96%B0%E4%B8%80%E8%A1%8C%EF%BC%8C%E4%BD%86%E6%98%AF%E8%A6%81%E4%BF%AE%E6%94%B9%E7%9A%84%E5%80%BC%E8%B7%9F%E5%8E%9F%E6%9D%A5%E7%9A%84%E5%80%BC%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%EF%BC%8C%E8%BF%99%E6%97%B6%E5%80%99-MySQL-%E4%BC%9A%E7%9C%9F%E7%9A%84%E5%8E%BB%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E4%BF%AE%E6%94%B9%E5%90%97%EF%BC%9F"><span class="toc-text">3.11 当 MySQL 去更新一行，但是要修改的值跟原来的值是相同的，这时候 MySQL 会真的去执行一次修改吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-12-%E6%88%91%E6%9F%A5%E8%BF%99%E4%B9%88%E5%A4%9A%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AD%98%E6%89%93%E7%88%86"><span class="toc-text">3.12 我查这么多数据，会不会把数据库内存打爆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-13-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%EF%BC%8C%E9%81%87%E5%88%B0%E4%B8%BB%E4%BB%8E%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98%E5%B8%B8%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-text">3.13 读写分离，遇到主从不一致的问题常用的解决方案？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-14-InnoDB%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%94%81%EF%BC%9F"><span class="toc-text">3.14 InnoDB有哪些类型的锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-15-Mysql%E5%8A%A0%E9%94%81%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-text">3.15 Mysql加锁原则？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-16-Mysql%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%EF%BC%9F"><span class="toc-text">3.16 Mysql两阶段锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-17-%E6%AD%BB%E9%94%81%E5%92%8C%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-text">3.17 死锁和死锁检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-18-%E4%BB%80%E4%B9%88%E6%98%AF%E7%83%AD%E7%82%B9%E8%A1%8C"><span class="toc-text">3.18 什么是热点行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-19-mysql-%E5%A6%82%E4%BD%95%E5%AF%B9%E8%AE%B0%E5%BD%95%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%E7%9A%84%EF%BC%8C%E5%86%85%E5%AD%98%E6%8E%92%E5%BA%8F%E3%80%81%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%96%87%E4%BB%B6%E5%90%88%E5%B9%B6%E7%94%A8%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">3.19 mysql 如何对记录进行排序的，内存排序、文件排序，文件合并用归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-20-mysql-join-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E3%80%82join%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88"><span class="toc-text">3.20 mysql join 如何实现的。join的时候需要注意什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-21-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E5%A4%A7%E8%A1%A8join%EF%BC%9F"><span class="toc-text">3.21 为什么不要大表join？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-22-%E5%86%85%E5%AD%98%E4%B8%B4%E6%97%B6%E8%A1%A8"><span class="toc-text">3.22 内存临时表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-23-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E4%B8%B4%E6%97%B6%E8%A1%A8"><span class="toc-text">3.23 什么时候会使用临时表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-24-distinct-%E5%92%8C-group-by-%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-text">3.24 distinct 和 group by 的性能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-25-count-%E3%80%81count-%E4%B8%BB%E9%94%AE-id-%E5%92%8C-count-1"><span class="toc-text">3.25 count(*)、count(主键 id) 和 count(1)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-26-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E8%A1%A8%EF%BC%9F"><span class="toc-text">3.26 什么是内存表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-27-%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%EF%BC%9F%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E5%8F%AF%E8%83%BD%E4%B8%8D%E8%BF%9E%E7%BB%AD%EF%BC%9F"><span class="toc-text">3.27 自增主键为什么不是连续的？什么场景下自增主键可能不连续？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-28-%E4%BD%BF%E7%94%A8limit-offset-%E5%88%86%E9%A1%B5%E6%97%B6%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B6%8A%E5%BE%80%E5%90%8E%E7%BF%BB%E8%B6%8A%E6%85%A2%EF%BC%9F"><span class="toc-text">3.28 使用limit offset 分页时，为什么越往后翻越慢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-29-%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7-mysqldumpslow"><span class="toc-text">3.29 慢查询工具 mysqldumpslow</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-30-SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E7%9A%84%E4%B8%BB%E8%A6%81%E5%9B%A0%E7%B4%A0"><span class="toc-text">3.30 SQL语句执行效率的主要因素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-31-SQL%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF"><span class="toc-text">3.31 SQL优化思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-32-DDL-%E5%87%A0%E7%A7%8D%E5%BD%A2%E5%BC%8F"><span class="toc-text">3.32 DDL 几种形式</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/ele"><i class="tag post-item-tag">ele</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">MySQL 基础</h1><time class="has-text-grey" datetime="2023-06-23T04:08:00.000Z">2023-06-23</time><article class="mt-2 post-content"><h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><h2 id="1-1-常用索引有哪些"><a href="#1-1-常用索引有哪些" class="headerlink" title="1.1 常用索引有哪些"></a>1.1 常用索引有哪些</h2><p>普通索引、唯一索引、主键索引、组合索引、全文索引</p>
<h2 id="1-2-聚集索引和非聚集索引区别"><a href="#1-2-聚集索引和非聚集索引区别" class="headerlink" title="1.2 聚集索引和非聚集索引区别"></a>1.2 聚集索引和非聚集索引区别</h2><p>聚集索引（<code>Clustered Index</code>）和非聚集索引（<code>Non-clustered Index</code>）是两种不同类型的数据库索引，它们的区别如下：</p>
<ol>
<li><p><strong>聚集索引（Clustered Index）</strong>：</p>
<ul>
<li>聚集索引中的数据行和索引的顺序相同，即它将数据行本身和索引按照相同的排序方式存储在一起。</li>
<li>一个表只能有一个聚集索引，因为数据行只能以一种顺序存储。</li>
<li>聚集索引通常用主键建立，但也可以使用其他具有唯一约束的列。</li>
<li>数据的物理存储顺序与索引的顺序相同，所以聚集索引通常提供较快的数据检索。</li>
</ul>
</li>
<li><p><strong>非聚集索引（Non-clustered Index）</strong>：</p>
<ul>
<li>非聚集索引与聚集索引分开存储，数据行的顺序与索引的顺序无关。</li>
<li>一个表可以有多个非聚集索引；</li>
<li>非聚集索引包含用于检索的键值和一个指针，指向行数据的实际位置。</li>
<li>非聚集索引通常用于在不同于主键的其他列上提高查询性能。</li>
</ul>
</li>
</ol>
<p>总结：聚集索引按照索引顺序存储数据行，而非聚集索引将索引与数据行分开存储。一个表只能有一个聚集索引，但可以有多个非聚集索引。在查询性能上，聚集索引通常提供较快的数据检索，而非聚集索引则在其他列上提高查询性能。</p>
<h2 id="1-3-Mysql-为什么使用-B-树（B-Tree）作为存储的数据结构？"><a href="#1-3-Mysql-为什么使用-B-树（B-Tree）作为存储的数据结构？" class="headerlink" title="1.3 Mysql 为什么使用 B+树（B+Tree）作为存储的数据结构？"></a>1.3 Mysql 为什么使用 B+树（B+Tree）作为存储的数据结构？</h2><p><code>MySQL</code> 使用 <code>B+</code>树（<code>B+Tree</code>）作为存储数据结构的主要原因是其在查询性能、空间利用和磁盘<code>IO</code>效率方面的优势。以下是 <code>B+</code>树在数据库中具有优势的几个方面：</p>
<ol>
<li><p><strong>查询性能</strong>：<code>B+</code>树是一种自平衡的多路搜索树，这意味着它能够在树的深度方面保持相对均衡。这样，在查找数据时，即使数据量非常大，也能保证较低的查询成本。</p>
</li>
<li><p><strong>范围查询</strong>：<code>B+</code>树的叶子节点上的记录（或键值）是有序的，这使得它非常适合范围查询。当需要对数据库进行范围查询时，<code>B+</code>树可以从范围起始点开始进行快速检索，并顺序访问叶子节点直到范围结束，性能非常高。</p>
</li>
<li><p><strong>磁盘 IO 效率</strong>：数据库系统往往需要将数据持久化到磁盘以保证数据的完整性和安全。<code>B+</code>树的结构使其能够很好地处理磁盘<code>IO</code>。在<code>B+</code>树中，所有的数据记录都存储在叶子节点上，非叶子节点只包含索引信息。这样，在从磁盘读取时<code>IO</code>次数会相对较少，从而提高查询性能。</p>
</li>
<li><p><strong>空间利用</strong>：<code>B+</code>树相较于其他树结构，如红黑树或<code>AVL</code>树，更具有空间利用性。因为在B+树内部节点只存储索引信息而不存储实际数据，所以每个内部节点可容纳的索引量更多，树的高度将更低。这就意味着磁盘空间被更有效地利用，查询更快。</p>
</li>
</ol>
<h2 id="1-4-Mysql-的-B-Tree-非叶子节点有多少数据，一般有几层。"><a href="#1-4-Mysql-的-B-Tree-非叶子节点有多少数据，一般有几层。" class="headerlink" title="1.4 Mysql 的 B+Tree 非叶子节点有多少数据，一般有几层。"></a>1.4 Mysql 的 B+Tree 非叶子节点有多少数据，一般有几层。</h2><p><strong>InnoDB 存储引擎中页的大小为 16KB，一般表的主键类型为 INT（占用 4 个字节）或 BIGINT（占用 8 个字节），指针类型也一般为 4 或 8 个字节，也就是说一个页（B+Tree 中的一个节点）中大概存储 16KB/(8B+8B)=1K 个键值（因为是估值，为方便计算，这里的 K 取值为〖10〗^3）。也就是说一个深度为 3 的 B+Tree 索引可以维护 10^3 _ 10^3 _ 10^3 = 10 亿 条记录。</strong></p>
<p>实际情况中每个节点可能不能填充满，因此在数据库中，<code>B+Tree</code> 的高度一般都在<code>2~4</code>层。<code>mysql</code>的<code>InnoDB</code>存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要<code>1~3</code>次磁盘<code>I/O</code>操作。</p>
<h2 id="1-5-MyISAM、InnoDB-索引实现"><a href="#1-5-MyISAM、InnoDB-索引实现" class="headerlink" title="1.5 MyISAM、InnoDB 索引实现"></a>1.5 MyISAM、InnoDB 索引实现</h2><p><code>MyISAM</code>引擎使用<code>B+Tree</code>作为索引结构，叶节点的<code>data</code>域存放的是数据记录的地址。下图是<code>MyISAM</code>索引的原理图：</p>
<p>在<code>MyISAM</code>中，主索引和辅助索引（<code>Secondary key</code>）在结构上没有任何区别，只是主索引要求<code>key</code>是唯一的，而辅助索引的<code>key</code>可以重复。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-bc1ea670502dd64b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Primary Key.png"></p>
<p>第一个重大区别是<code>InnoDB</code>的数据文件本身就是索引文件。从上文知道，<code>MyISAM</code>索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在 <code>InnoDB</code> 中，表数据文件本身就是按<code>B+Tree</code>组织的一个索引结构，这棵树的叶节点<code>data</code>域保存了完整的数据记录。这个索引的<code>key</code>是数据表的主键，因此<code>InnoDB</code>表数据文件本身就是主索引。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-ce53084f3a2cc566.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Primary Key.png"></p>
<h2 id="1-6-MyISAM与InnoDB的主要区别？"><a href="#1-6-MyISAM与InnoDB的主要区别？" class="headerlink" title="1.6 MyISAM与InnoDB的主要区别？"></a>1.6 MyISAM与InnoDB的主要区别？</h2><p><code>MyISAM</code>和<code>InnoDB</code>是<code>MySQL</code>数据库中两种常见的存储引擎，它们之间存在着一些主要区别：</p>
<p><strong>1. 事务支持 (Transaction Support)</strong></p>
<ul>
<li><p><strong>MyISAM</strong>：MyISAM 存储引擎不支持事务。因此，它不适用于需要处理复杂事务和严格保证数据完整性的场景。</p>
</li>
<li><p><strong>InnoDB</strong>：InnoDB 存储引擎支持事务（ACID 属性），提供了提交、回滚等事务相关的操作，适用于处理复杂业务并确保数据完整性。</p>
</li>
</ul>
<p><strong>2. 行级锁定 (Row-Level Locking)</strong></p>
<ul>
<li><p><strong>MyISAM</strong>：MyISAM使用表级锁定，当对表进行写操作（如插入、更新或删除）时，会锁定整个表。这会降低高并发环境下的数据处理能力。</p>
</li>
<li><p><strong>InnoDB</strong>：InnoDB 使用行级锁定，这允许在高并发环境下同时对多个记录进行读写访问，提高了数据库性能。</p>
</li>
</ul>
<p><strong>3. 数据存储和索引</strong></p>
<ul>
<li><p><strong>MyISAM</strong>：MyISAM 存储引擎将数据文件和索引文件分开存储。它主要支持非聚集索引。</p>
</li>
<li><p><strong>InnoDB</strong>：InnoDB 以聚集的方式组织存储，它支持聚集索引和非聚集索引。数据和索引按照相同顺序存储，提高了查询性能。</p>
</li>
</ul>
<p><strong>4. 数据完整性 (Data Integrity)</strong></p>
<ul>
<li><p><strong>MyISAM</strong>：MyISAM 存储引擎不支持外键约束，无法确保数据间的引用完整性。</p>
</li>
<li><p><strong>InnoDB</strong>：InnoDB 支持外键约束，可以在数据表之间维护引用关系，确保数据的完整性。</p>
</li>
</ul>
<p><strong>5. 崩溃恢复 (Crash Recovery)</strong></p>
<ul>
<li><p><strong>MyISAM</strong>：MyISAM 不具备原生的崩溃恢复能力。在数据库意外崩溃或电源故障等情况下，可能造成数据损坏或丢失。</p>
</li>
<li><p><strong>InnoDB</strong>：InnoDB 提供了日志和检查点（Checkpoint）机制，支持故障现场恢复。因此，在数据库崩溃的情况下，InnoDB 更有可能保护数据并重新启动数据库。</p>
</li>
</ul>
<p><strong>6. 全文搜索 (Full-text Search)</strong></p>
<ul>
<li><p><strong>MyISAM</strong>：MyISAM 存储引擎提供原生的全文搜索功能。</p>
</li>
<li><p><strong>InnoDB</strong>：早期版本的 InnoDB 不支持全文索引搜索，但从 MySQL 5.6.4 开始，InnoDB 同样支持全文搜索功能。</p>
</li>
</ul>
<p>总结：<code>MyISAM</code>更适合用于读取速度要求高、不要求事务支持和数据完整性严格保障的简单查询场景。InnoDB 更适合事务处理、并发读写较高且需要保证数据完整性的场景。在实际应用中，根据不同的需求和场景选择合适的存储引擎非常重要。</p>
<h2 id="1-7-字段建索引好处？是不是越多越好？"><a href="#1-7-字段建索引好处？是不是越多越好？" class="headerlink" title="1.7 字段建索引好处？是不是越多越好？"></a>1.7 字段建索引好处？是不是越多越好？</h2><p>为<code>MySQL</code>字段建索引可以带来一些优势，但并不是索引越多越好。以下是建立索引的好处和需要考虑的因素：</p>
<p><strong>建立索引的好处：</strong></p>
<ol>
<li><p><strong>提高查询速度</strong>：索引可以显著提高数据查询的速度。通过使用索引，数据库可以避免全表扫描，而是直接定位到符合条件的记录，从而节省查询时间。</p>
</li>
<li><p><strong>加速排序和分组</strong>：索引可以帮助数据库引擎对排序和分组操作进行优化，提高查询性能。</p>
</li>
<li><p><strong>支持外键约束</strong>：在 InnoDB 存储引擎中，索引用于支持外键约束，确保数据引用的完整性。</p>
</li>
</ol>
<p>然而，在创建索引时，需要权衡一些因素，过多的索引并不一定总是好的。</p>
<p><strong>需要考虑的因素：</strong></p>
<ol>
<li><p><strong>存储空间</strong>：索引需要额外的存储空间。过多的索引会占用更多的磁盘空间。</p>
</li>
<li><p><strong>数据插入、更新、删除性能</strong>：每增加一个索引，数据库在插入、更新或删除数据时，都需要维护相关的索引。过多的索引会导致这些操作的性能降低。</p>
</li>
<li><p><strong>索引维护成本</strong>：索引需要维护，包括碎片整理、索引重建等操作。过多的索引意味着更高的维护成本。</p>
</li>
</ol>
<p>总之，创建索引可以提高数据库查询性能，但是过多的索引会导致额外的存储空间和性能开销。在创建索引时，应根据实际需求进行适当的权衡。</p>
<h2 id="1-8-MySQL-慢查询常见原因"><a href="#1-8-MySQL-慢查询常见原因" class="headerlink" title="1.8 MySQL 慢查询常见原因"></a>1.8 MySQL 慢查询常见原因</h2><p><code>MySQL</code>慢查询可能出现的原因有很多。以下是一些常见的慢查询原因：</p>
<ol>
<li><p><strong>缺少索引或使用不当</strong>：未对查询中的关键字段创建索引、索引选取不当或统计信息不准确，导致 MySQL 无法高效地查询数据，从而降低查询速度。</p>
</li>
<li><p><strong>查询语句设计不合理</strong>：复杂的子查询、使用了大量的临时表、笛卡尔积查询等，可能导致查询性能低下。</p>
</li>
<li><p><strong>数据量过大</strong>：当表中的数据量过大时，未经优化的查询可能需要处理大量数据，从而降低查询速度。</p>
</li>
<li><p><strong>锁争用</strong>：在高并发读写的场景下，如果 MySQL 存储引擎（如 MyISAM）使用表级锁或行级锁锁定不当，可能导致锁争用，进而降低查询性能。</p>
</li>
<li><p><strong>硬件资源限制</strong>：如 CPU、内存、磁盘和网络等硬件资源不足，可能导致查询性能低下。</p>
</li>
<li><p><strong>MySQL 配置不当</strong>：MySQL 的配置参数未经优化，可能在一定程度上影响查询性能（如缓冲区大小不合适、连接数设置不正确等）。</p>
</li>
<li><p><strong>数据分布不均</strong>：在使用分布式数据库或分区表时，如果数据分布不均匀，可能导致部分查询性能较低。</p>
</li>
<li><p><strong>过时的统计信息</strong>：MySQL 使用统计信息来选择最佳索引。如果统计信息过时或不准确，可能导致 MySQL 选择不佳的查询计划。</p>
</li>
</ol>
<p>针对这些常见的慢查询原因，可以采取相应措施进行优化。例如：创建和优化索引、改进查询语句、调整硬件配置、优化 <code>MySQL</code>参数设置等。同时，可以开启慢查询日志来分析和诊断慢查询问题。</p>
<h2 id="1-9-SQL-优化原则，索引注意事项？"><a href="#1-9-SQL-优化原则，索引注意事项？" class="headerlink" title="1.9 SQL 优化原则，索引注意事项？"></a>1.9 SQL 优化原则，索引注意事项？</h2><p>以下是一些建议的 SQL 优化原则和索引注意事项：</p>
<p><strong>SQL 优化原则:</strong></p>
<ol>
<li><p><strong>减少数据请求量</strong>：尽量减少请求的数据量，只请求需要的列和必要的记录。</p>
</li>
<li><p><strong>避免 SELECT * 查询</strong>：仅查询所需的列，以减少数据传输和处理的开销。</p>
</li>
<li><p><strong>优化连接和子查询</strong>：连接查询时，避免全外连接（Full Outer Join）和笛卡尔积连接，而使用内连接（Inner Join）或左（右）连接（Left/Right Join）。尽量减少子查询，考虑使用连接查询或者临时表代替。</p>
</li>
<li><p><strong>分批处理数据</strong>：如果需要处理大量数据，可以使用分页查询、limit 语句或其他批处理技术，以降低数据处理压力。</p>
</li>
<li><p><strong>利用索引</strong>：在查询语句中使用索引相关的列，尽量避免对索引字段进行计算、函数或表达式操作，以充分利用现有索引加速查询。</p>
</li>
<li><p><strong>避免隐式类型转换</strong>：确保在查询中进行比较或计算的字段类型匹配，以避免隐式类型转换导致查询性能下降。</p>
</li>
<li><p><strong>聚合操作优化</strong>：在对大量数据执行聚合查询（如求和、计数等）时，尽量使用索引进行覆盖查询，减少数据扫描量。</p>
</li>
</ol>
<p><strong>索引注意事项:</strong></p>
<ol>
<li><p><strong>选择合适的索引列</strong>：在查询中常用作过滤、连接和排序的列是创建索引的最佳候选。另外，考虑数据的区分度，数据分布较均匀且重复值较少的列更适合创建索引。</p>
</li>
<li><p><strong>避免过多索引</strong>：索引虽然可以提高查询性能，但它会占用额外的存储空间并影响数据的插入、更新和删除操作。因此，应权衡实际情况，充分考虑查询需求和数据变更频率，以避免过多索引。</p>
</li>
<li><p><strong>使用组合索引</strong>：在多个字段上经常一起进行查询的场景，可以创建组合索引。但应注意，组合索引的顺序会影响到查询性能。</p>
</li>
<li><p><strong>避免在索引列上进行计算、函数或表达式操作</strong>：在 SQL 查询中，尽量不要对索引列进行计算、使用函数或进行表达式操作，这会导致索引失效。</p>
</li>
<li><p><strong>定期评估索引效果</strong>：定期评估现有索引的使用情况、查询性能和索引开销等方面，根据实际需求添加、删除或调整索引。</p>
</li>
<li><p><strong>考虑使用部分索引</strong>：如果某个列上只有部分数据需要被查询，可以考虑创建部分索引，以降低索引维护成本。</p>
</li>
</ol>
<p>结合实际数据库使用情况调整和优化 SQL 查询语句以及索引策略，有助于提升数据库查询性能和整体性能。所采取的优化措施应根据业务需求、数据量级和具体场景进行调整。</p>
<h2 id="1-10-事务四大特征-ACID"><a href="#1-10-事务四大特征-ACID" class="headerlink" title="1.10 事务四大特征(ACID)"></a>1.10 事务四大特征(ACID)</h2><ul>
<li>原子性（<code>Atomicity</code>）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li>
<li>一致性（<code>Consistent</code>）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如 B 树索引或双向链表）也都必须是正确的。</li>
<li>隔离性（<code>Isolation</code>）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li>
<li>持久性（<code>Durable</code>）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li>
</ul>
<h2 id="1-11-事务有哪四种隔离级别"><a href="#1-11-事务有哪四种隔离级别" class="headerlink" title="1.11 事务有哪四种隔离级别"></a>1.11 事务有哪四种隔离级别</h2><table>
<thead>
<tr>
<th align="left">读数据一致性及并发副作用</th>
<th align="center">读数据一致性</th>
<th align="right">脏读</th>
<th align="right">不可重复读</th>
<th align="right">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="left">未提交读(read uncommitted)</td>
<td align="center">最低级别，不读物理上顺坏的数据</td>
<td align="right">是</td>
<td align="right">是</td>
<td align="right">是</td>
</tr>
<tr>
<td align="left">已提交读(read committed)</td>
<td align="center">语句级</td>
<td align="right">否</td>
<td align="right">是</td>
<td align="right">是</td>
</tr>
<tr>
<td align="left">可重复读(Repeatable read)</td>
<td align="center">事务级</td>
<td align="right">否</td>
<td align="right">否</td>
<td align="right">是</td>
</tr>
<tr>
<td align="left">可序列化(Serializable)</td>
<td align="center">最高级别，事务级</td>
<td align="right">否</td>
<td align="right">否</td>
<td align="right">否</td>
</tr>
</tbody></table>
<ul>
<li>更新丢失（<code>Lost Update</code>）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更新覆盖了由其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的更改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题。</li>
<li>脏读（<code>Dirty Reads</code>）：一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做”脏读”。</li>
<li>不可重复读（<code>Non-Repeatable Reads</code>）：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。</li>
<li>幻读（<code>Phantom Reads</code>）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。</li>
</ul>
<h2 id="1-12-什么是当前读和快照读？对应SQL怎么实现？"><a href="#1-12-什么是当前读和快照读？对应SQL怎么实现？" class="headerlink" title="1.12 什么是当前读和快照读？对应SQL怎么实现？"></a>1.12 什么是当前读和快照读？对应SQL怎么实现？</h2><p><strong>当前读：</strong>像<code>select lock in share mode</code>(共享锁), <code>select for update</code> ; <code>update</code>, <code>insert</code> ,<code>delete</code>(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。<br><strong>快照读：</strong>像不加锁的<code>select</code>操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即<code>MVCC</code>,可以认为<code>MVCC</code>是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本 <br><img src="https://upload-images.jianshu.io/upload_images/12321605-1cb575899ed08080.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="leck in shave mwe.png"></p>
<h2 id="1-13-什么是MVCC（Multi-Version-Concurrency-Control，即多版本并发控制）？"><a href="#1-13-什么是MVCC（Multi-Version-Concurrency-Control，即多版本并发控制）？" class="headerlink" title="1.13 什么是MVCC（Multi-Version Concurrency Control，即多版本并发控制）？"></a>1.13 什么是MVCC（Multi-Version Concurrency Control，即多版本并发控制）？</h2><p><code>MVCC</code>（<code>Multi-Version Concurrency Control</code>，多版本并发控制）是一种允许多个事务同时访问数据库的技术，旨在提高数据库系统在高并发环境下的性能。<code>MVCC</code>的核心思想是在同一个事务中对同一个数据的多次查询始终保持一致性，而不加锁来实现隔离，从而避免了加锁所带来的性能开销。</p>
<p><code>MVCC</code>通过为每一行数据生成多个版本，在不同事务中访问不同版本的数据，实现并发控制。每个事务在开始时都会获得一个唯一的事务<code>ID</code>，读取到的数据行版本要满足以下条件：</p>
<ul>
<li>数据行的创建版本要小于等于事务<code>ID</code>。</li>
<li>数据行的删除版本要大于等于事务<code>ID</code>，或者未被删除。</li>
</ul>
<p>这样，每个事务将能以一致的快照（<code>Snapshot</code>）视图访问数据库，并且互不影响。</p>
<p>每行记录除了我们自定义的字段外，还有数据库隐式定义的<code>DB_TRX_ID</code>,<code>DB_ROLL_PTR</code>,<code>DB_ROW_ID</code>等字段</p>
<ul>
<li><code>DB_TRX_ID</code>，<code>6byte</code>，最近修改(修改/插入)事务<code>ID</code>：记录创建这条记录/最后一次修改该记录的事务<code>ID</code></li>
<li><code>DB_ROLL_PTR</code>，<code>7byte</code>，回滚指针，指向这条记录的上一个版本（存储于<code>rollback segment</code>里）</li>
<li><code>DB_ROW_ID</code>，<code>6byte</code>，隐含的自增<code>ID</code>（隐藏主键），如果数据表没有主键，<code>InnoDB</code>会自动以<code>DB_ROW_ID</code>产生一个聚簇索引</li>
<li>实际还有一个删除<code>flag</code>隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除<code>flag</code>变了。 </li>
</ul>
<h1 id="二、MySQL-日志基础"><a href="#二、MySQL-日志基础" class="headerlink" title="二、MySQL 日志基础"></a>二、MySQL 日志基础</h1><h2 id="2-1-什么是-binlog"><a href="#2-1-什么是-binlog" class="headerlink" title="2.1 什么是 binlog"></a>2.1 什么是 binlog</h2><ul>
<li><code>binlog</code>是逻辑日志，记录的是这个语句的原始逻辑/变化，比如<code>给 ID=2 这一行的 c 字段加 1</code>。</li>
<li><code>binlog</code>是追加写，不会覆盖之前的数据，可以提供完整的数据归档的能力。</li>
</ul>
<h2 id="2-2-什么是-redo-log"><a href="#2-2-什么是-redo-log" class="headerlink" title="2.2 什么是 redo log"></a>2.2 什么是 redo log</h2><ul>
<li><code>redo log</code>是物理日志，记录的是<code>在某个数据页上做了什么修改</code>；</li>
<li><code>redo log</code>提供<code>crash-safe</code>能力。</li>
<li>一般只有<code>4G</code> ，<code>4</code>个文件，循环复写。</li>
</ul>
<h2 id="2-3-binlog-和-redo-log-区别"><a href="#2-3-binlog-和-redo-log-区别" class="headerlink" title="2.3 binlog 和 redo log 区别"></a>2.3 binlog 和 redo log 区别</h2><p>因为最开始<code>MySQL</code>里并没有<code>InnoDB</code>引擎。<code>MySQL</code>自带的引擎是<code>MyISAM</code>，但是<code>MyISAM</code>没有<code>crash-safe</code>的能力，<code>binlog</code>日志只能用于归档。而<code>InnoDB</code>是另一个公司以插件形式引入<code>MySQL</code>的，既然只依靠<code>binlog</code>是没有<code>crash-safe</code>能力的，所以<code>InnoDB</code>使用另外一套日志系统——也就是<code>redo log</code>来实现<code>crash-safe</code>能力。</p>
<ol>
<li><code>redo log</code>是<code>InnoDB</code>引擎特有的；<code>binlog</code>是<code>MySQL</code>的<code>Server</code>层实现的，所有引擎都可以使用。</li>
<li><code>redo log</code>是物理日志，记录的是<code>在某个数据页上做了什么修改</code>；<code>binlog</code>是逻辑日志，记录的是这个语句的原始逻辑，比如<code>给 ID=2 这一行的 c 字段加 1</code>。</li>
<li><code>redo log</code>是循环写的，空间固定会用完；<code>binlog</code>是可以追加写入的。“追加写”是指<code>binlog</code>文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ol>
<h2 id="2-4-binlog-的写入机制"><a href="#2-4-binlog-的写入机制" class="headerlink" title="2.4 binlog 的写入机制"></a>2.4 binlog 的写入机制</h2><p>其实，<code>binlog</code>的写入逻辑比较简单：事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把 <code>binlog cache</code>写到<code>binlog</code>文件中。</p>
<p>一个事务的<code>binlog</code>是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。这就涉及到了<code>binlog cache</code>的保存问题。</p>
<p>系统给<code>binlog cache</code>分配了一片内存，每个线程一个，参数<code>binlog_cache_size</code>用于控制单个线程内<code>binlog cache</code>所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p>
<p>事务提交的时候，执行器把<code>binlog cache</code>里的完整事务写入到<code>binlog</code>中，并清空<code>binlog cache</code>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-42950c1d7f363434.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="2-5-redo-的写入机制"><a href="#2-5-redo-的写入机制" class="headerlink" title="2.5 redo 的写入机制"></a>2.5 redo 的写入机制</h2><p>事务在执行过程中，生成的<code>redo log</code>是要先写到<code>redo log buffer</code>的。</p>
<p><code>redo log buffer</code> 里面的内容，是不是每次生成后都要直接持久化到磁盘呢？答案是，不需要。</p>
<p>如果事务执行期间<code>MySQL</code>发生异常重启，那这部分日志就丢了。由于事务并没有提交，所以这时日志丢了也不会有损失。<br>那么，另外一个问题是，事务还没提交的时候，<code>redo log buffer</code>中的部分日志有没有可能被持久化到磁盘呢？答案是，确实会有。</p>
<p>这个问题，要从 <code>redo log</code> 可能存在的三种状态说起。这三种状态，对应的就是下图中的三个颜色块。</p>
<ol>
<li>存在<code>redo log buffer</code>中，物理上是在<code>MySQL</code>进程内存中，就是图中的红色部分；</li>
<li>写到磁盘 (<code>write</code>)，但是没有持久化（<code>fsync</code>)，物理上是在文件系统的<code>page cache</code>里面，也就是图中的黄色部分；</li>
<li>持久化到磁盘，对应的是<code>hard disk</code>，也就是图中的绿色部分。</li>
</ol>
<p>日志写到<code>redo log buffer</code>是很快的，<code>wirte</code>到<code>page cache</code>也差不多，但是持久化到磁盘的速度就慢多了。</p>
<p>为了控制<code>redo log</code>的写入策略，<code>InnoDB</code> 提供了<code>innodb_flush_log_at_trx_commit</code>参数，它有三种可能取值：</p>
<ul>
<li>设置为<code>0</code>的时候，表示每次事务提交时都只是把<code>redo log</code>留在<code>redo log buffer</code>中 ;</li>
<li>设置为<code>1</code>的时候，表示每次事务提交时都将<code>redo log</code>直接持久化到磁盘；</li>
<li>设置为<code>2</code>的时候，表示每次事务提交时都只是把<code>redo log</code>写到<code>page cache</code>。</li>
</ul>
<p><code>InnoDB</code>有一个后台线程，每隔<code>1</code>秒，就会把<code>redo log buffer</code>中的日志，调用<code>write</code>写到文件系统的<code>page cache</code>，然后调用<code>fsync</code>持久化到磁盘。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-2e007b0a214cacd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Server.png"></p>
<h2 id="2-6-redo-log-存储方式，一个没有提交的事务的-redo-log-是否有可能写入到磁盘中？"><a href="#2-6-redo-log-存储方式，一个没有提交的事务的-redo-log-是否有可能写入到磁盘中？" class="headerlink" title="2.6 redo log 存储方式，一个没有提交的事务的 redo log 是否有可能写入到磁盘中？"></a>2.6 redo log 存储方式，一个没有提交的事务的 redo log 是否有可能写入到磁盘中？</h2><p><img src="https://upload-images.jianshu.io/upload_images/12321605-1922169ffa8b3ca2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="write POs.png"></p>
<p><code>write pos</code>是当前记录的位置，一边写一边后移，写到第<code>3</code>号文件末尾后就回到<code>0</code>号文件开头。<code>checkpoint</code>是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p><code>write pos</code>和<code>checkpoint</code>之间的是还空着的部分，可以用来记录新的操作。如果<code>write pos</code>追上<code>checkpoint</code>，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把<code>checkpoint</code>推进一下。</p>
<p>有了<code>redo log</code>，<code>InnoDB</code>就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<code>crash-safe</code>。</p>
<p><code>redo log</code>用于保证<code>crash-safe</code>能力。<code>innodb_flush_log_at_trx_commit</code>这个参数设置成<code>1</code>的时候，表示每次事务的<code>redo log</code>都直接持久化到磁盘。这个参数我建议你设置成<code>1</code>，这样可以保证<code>MySQL</code>异常重启之后数据不丢失。</p>
<p>注意，事务执行中间过程的<code>redo log</code>也是直接写在<code>redo log buffer</code>中的，这些<code>redo log</code>也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的<code>redo log</code>，也是可能已经持久化到磁盘的。</p>
<p>实际上，除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的<code>redo log</code>写入到磁盘中。</p>
<ol>
<li>一种是，<code>redo log buffer</code>占用的空间即将达到<code>innodb_log_buffer_size</code>一半的时候，后台线程会主动写盘。注意，由于这个事务并没有提交，所以这个写盘动作只是<code>write</code>，而没有调用<code>fsync</code>，也就是只留在了文件系统的<code>page cache</code>。</li>
<li>另一种是，并行的事务提交的时候，顺带将这个事务的<code>redo log buffer</code>持久化到磁盘。假设一个事务<code>A</code>执行到一半，已经写了一些<code>redo log</code>到<code>buffer</code>中，这时候有另外一个线程的事务<code>B</code>提交，如果 <code>innodb_flush_log_at_trx_commit</code> 设置的是<code>1</code>，那么按照这个参数的逻辑，事务<code>B</code>要把<code>redo log buffer</code> 里的日志全部持久化到磁盘。这时候，就会带上事务<code>A</code>在<code>redo log buffer</code>里的日志一起持久化到磁盘。</li>
</ol>
<h2 id="2-7-redo-log组提交（group-commit）机制"><a href="#2-7-redo-log组提交（group-commit）机制" class="headerlink" title="2.7 redo log组提交（group commit）机制"></a>2.7 redo log组提交（group commit）机制</h2><p>日志逻辑序列号（<code>log sequence number，LSN</code>）。<code>LSN</code>是单调递增的，用来对应<code>redo log</code>的一个个写入点。每次写入长度为<code>length</code>的<code>redo log</code>，<code>LSN</code>的值就会加上<code>length</code>。<br><code>LSN</code>也会写到<code>InnoDB</code>的数据页中，来确保数据页不会被多次执行重复的<code>redo log</code>。<br>如图<code>3</code>所示，是三个并发事务 (<code>trx1, trx2, trx3</code>) 在<code>prepare</code>阶段，都写完<code>redo log buffer</code>，持久化到磁盘的过程，对应的<code>LSN</code>分别是<code>50</code>、<code>120</code>和<code>160</code>。</p>
<p><code>trx1</code>是第一个到达的，会被选为这组的<code>leader</code>；等<code>trx1</code>要开始写盘的时候，这个组里面已经有了三个事务，这时候<code>LSN</code>也变成了<code>160</code>；<code>trx1</code>去写盘的时候，带的就是<code>LSN=160</code>，因此等<code>trx1</code>返回时，所有<code>LSN</code>小于等于<code>160</code>的<code>redo log</code>，都已经被持久化到磁盘；这时候<code>trx2</code> 和<code>trx3</code>就可以直接返回了。</p>
<p>所以，一次组提交里面，组员越多，节约磁盘<code>IOPS</code>的效果越好。但如果只有单线程压测，那就只能老老实实地一个事务对应一次持久化操作了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-15bec2ee5bc42da0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="2-8-Binlog-和-Redolog-记录如何保持一致"><a href="#2-8-Binlog-和-Redolog-记录如何保持一致" class="headerlink" title="2.8 Binlog 和 Redolog 记录如何保持一致"></a>2.8 Binlog 和 Redolog 记录如何保持一致</h2><p>两阶段提交、<code>redo log prepare write</code> -&gt; <code>binlog write</code> -&gt; <code>redo log commit write</code></p>
<p><code>MySQL</code>为了让组提交的效果更好，把<code>redo log</code>做<code>fsync</code>的时间拖到了步骤<code>1</code>之后。也就是说，上面的图变成了这样：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-704f6253ac3fa51e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="log prepore.png"></p>
<h2 id="2-9-执行一个-update-语句以后，我再去执行-hexdump-命令直接查看-ibd-文件内容，为什么没有看到数据有改变呢"><a href="#2-9-执行一个-update-语句以后，我再去执行-hexdump-命令直接查看-ibd-文件内容，为什么没有看到数据有改变呢" class="headerlink" title="2.9 执行一个 update 语句以后，我再去执行 hexdump 命令直接查看 ibd 文件内容，为什么没有看到数据有改变呢"></a>2.9 执行一个 update 语句以后，我再去执行 hexdump 命令直接查看 ibd 文件内容，为什么没有看到数据有改变呢</h2><p>这可能是因为<code>WAL</code>机制的原因。<code>update</code>语句执行完成后，<code>InnoDB</code>只保证写完了<code>redo log</code>、内存，可能还没来得及将数据写到磁盘。</p>
<h2 id="2-10-为什么-binlog-cache-是每个线程自己维护的，而-redo-log-buffer-是全局共用的"><a href="#2-10-为什么-binlog-cache-是每个线程自己维护的，而-redo-log-buffer-是全局共用的" class="headerlink" title="2.10 为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的"></a>2.10 为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的</h2><p><code>MySQL</code>这么设计的主要原因是，binlog 是不能“被打断的”。一个事务的 binlog 必须连续写，因此要整个事务完成后，再一起写到文件里。</p>
<p>而<code>redo log</code>并没有这个要求，中间有生成的日志可以写到<code>redo log buffer</code>中。<code>redo log buffer</code>中的内容还能“搭便车”，其他事务提交的时候可以被一起写到磁盘中。</p>
<p>还有一点，<code>binlog</code>存储是以<code>statement</code>或者<code>row</code>格式存储的，而<code>redo log</code>是以<code>page</code>页格式存储的。<code>page</code>格式，天生就是共有的，而<code>row</code>格式，只跟当前事务相关。</p>
<h2 id="2-11-事务执行期间，还没到提交阶段，如果发生-crash-的话，redo-log-肯定丢了，这会不会导致主备不一致呢？"><a href="#2-11-事务执行期间，还没到提交阶段，如果发生-crash-的话，redo-log-肯定丢了，这会不会导致主备不一致呢？" class="headerlink" title="2.11 事务执行期间，还没到提交阶段，如果发生 crash 的话，redo log 肯定丢了，这会不会导致主备不一致呢？"></a>2.11 事务执行期间，还没到提交阶段，如果发生 crash 的话，redo log 肯定丢了，这会不会导致主备不一致呢？</h2><p>不会。因为这时候<code>binlog</code>也还在<code>binlog cache</code>里，没发给备库。<code>crash</code>以后<code>redo log</code>和<code>binlog</code>都没有了，从业务角度看这个事务也没有提交，所以数据是一致的。</p>
<h2 id="2-12-MySQL-怎么知道-binlog-是完整的"><a href="#2-12-MySQL-怎么知道-binlog-是完整的" class="headerlink" title="2.12 MySQL 怎么知道 binlog 是完整的?"></a>2.12 MySQL 怎么知道 binlog 是完整的?</h2><p>一个事务的<code>binlog</code>是有完整格式的：<code>statement</code>格式的<code>binlog</code>，最后会有<code>COMMIT</code>；<code>row</code>格式的<code>binlog</code>，最后会有一个<code>XID event</code>。</p>
<p>另外，在<code>MySQL 5.6.2</code>版本以后，还引入了<code>binlog-checksum</code>参数，用来验证<code>binlog</code>内容的正确性。对于 <code>binlog</code>日志由于磁盘原因，可能会在日志中间出错的情况，<code>MySQL</code>可以通过校验<code>checksum</code>的结果来发现。所以，<code>MySQL</code>还是有办法验证事务<code>binlog</code>的完整性的。</p>
<h2 id="2-13-redo-log-和-binlog-是怎么关联起来的"><a href="#2-13-redo-log-和-binlog-是怎么关联起来的" class="headerlink" title="2.13 redo log 和 binlog 是怎么关联起来的?"></a>2.13 redo log 和 binlog 是怎么关联起来的?</h2><p>它们有一个共同的数据字段，叫<code>XID</code>。崩溃恢复的时候，会按顺序扫描<code>redo log</code>：如果碰到既有<code>prepare</code>、又有 <code>commit</code>的<code>redo log</code>，就直接提交；如果碰到只有<code>parepare</code>、而没有<code>commit</code>的<code>redo log</code>，就拿着<code>XID</code>去<code>binlog</code>找对应的事务。</p>
<h2 id="2-14-处于-prepare-阶段的-redo-log-加上完整-binlog，重启就能恢复，MySQL-为什么要这么设计"><a href="#2-14-处于-prepare-阶段的-redo-log-加上完整-binlog，重启就能恢复，MySQL-为什么要这么设计" class="headerlink" title="2.14 处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计"></a>2.14 处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计</h2><p>其实，这个问题还是跟我们在反证法中说到的数据与备份的一致性有关。在 <code>binlog</code> 写完以后<code>MySQL</code>发生崩溃，这时候<code>binlog</code>已经写入了，之后就会被从库（或者用这个<code>binlog</code>恢复出来的库）使用。</p>
<p>所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。</p>
<h2 id="2-15-如果这样的话，为什么还要两阶段提交呢？干脆先-redo-log-写完，再写-binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑"><a href="#2-15-如果这样的话，为什么还要两阶段提交呢？干脆先-redo-log-写完，再写-binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑" class="headerlink" title="2.15 如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑"></a>2.15 如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑</h2><p>其实，两阶段提交是经典的分布式系统问题，并不是<code>MySQL</code>独有的。如果必须要举一个场景，来说明这么做的必要性的话，那就是事务的持久性问题。对于 <code>InnoDB</code> 引擎来说，如果<code>redo log</code>提交完成了，事务就不能回滚（如果这还允许回滚，就可能覆盖掉别的事务的更新）。而如果<code>redo log</code>直接提交，然后<code>binlog</code>写入的时候失败，<code>InnoDB</code>又回滚不了，数据和<code>binlog</code>日志又不一致了。两阶段提交就是为了给所有人一个机会，当每个人都说<code>我 ok</code>的时候，再一起提交。</p>
<h2 id="2-16-能不能只用-redo-log，不要-binlog"><a href="#2-16-能不能只用-redo-log，不要-binlog" class="headerlink" title="2.16 能不能只用 redo log，不要 binlog"></a>2.16 能不能只用 redo log，不要 binlog</h2><p>如果只从崩溃恢复的角度来讲是可以的。你可以把<code>binlog</code>关掉，这样就没有两阶段提交了，但系统依然是<code>crash-safe</code>的。因为<code>binlog</code>有着<code>redo log</code>无法替代的功能。一个是归档。<code>redo log</code>是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留，<code>redo log</code>也就起不到归档的作用。</p>
<p>一个就是<code>MySQL</code>系统依赖于<code>binlog</code>。<code>binlog</code>作为<code>MySQL</code>一开始就有的功能，被用在了很多地方。其中，<code>MySQL</code>系统高可用的基础，就是<code>binlog</code>复制。</p>
<h2 id="2-17-redo-log崩溃恢复？正常运行中的实例，数据写入后的最终落盘，是从-redo-log-更新过来的还是从-buffer-pool-更新过来的呢"><a href="#2-17-redo-log崩溃恢复？正常运行中的实例，数据写入后的最终落盘，是从-redo-log-更新过来的还是从-buffer-pool-更新过来的呢" class="headerlink" title="2.17 redo log崩溃恢复？正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢"></a>2.17 redo log崩溃恢复？正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢</h2><p>实际上，<code>redo log</code>并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页，也就不存在“数据最终落盘，是由<code>redo log</code>更新过去”的情况。</p>
<p>如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与<code>redo log</code>毫无关系。</p>
<p>在崩溃恢复场景中，<code>InnoDB</code>如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让 <code>redo log</code>更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。</p>
<h2 id="2-18-redo-log-buffer-是什么？是先修改内存，还是先写-redo-log-文件"><a href="#2-18-redo-log-buffer-是什么？是先修改内存，还是先写-redo-log-文件" class="headerlink" title="2.18 redo log buffer 是什么？是先修改内存，还是先写 redo log 文件"></a>2.18 redo log buffer 是什么？是先修改内存，还是先写 redo log 文件</h2><pre><code>begin;
insert into t1 ...
insert into t2 ...
commit;
</code></pre>
<p>这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在还没<code>commit</code>的时候就直接写到<code>redo log</code>文件里。</p>
<p>所以，<code>redo log buffer</code>就是一块内存，用来先存<code>redo</code>日志的。也就是说，在执行第一个<code>insert</code>的时候，数据的内存被修改了，<code>redo log buffer</code>也写入了日志。</p>
<p>但是，真正把日志写到<code>redo log</code>文件（文件名是<code>ib_logfile+</code>数字），是在执行<code>commit</code>语句的时候做的。（这里说的是事务执行过程中不会“主动去刷盘”，以减少不必要的<code>IO</code>消耗。但是可能会出现“被动写入磁盘”，比如内存不够、其他事务提交等情况）</p>
<h2 id="2-19-为什么binlog-是不能“被打断的”的"><a href="#2-19-为什么binlog-是不能“被打断的”的" class="headerlink" title="2.19 为什么binlog 是不能“被打断的”的"></a>2.19 为什么binlog 是不能“被打断的”的</h2><p><strong>一个线程只能同时有一个事务在执行</strong>。由于这个设定，所以每当执行一个<code>begin/start transaction</code>的时候，就会默认提交上一个事务；这样如果一个事务的<code>binlog</code>被拆开的时候，在备库执行就会被当做多个事务分段执行，这样破坏了原子性，是有问题的。</p>
<h2 id="2-20-undolog干嘛的，什么时候用到？长事务有什么坏处？"><a href="#2-20-undolog干嘛的，什么时候用到？长事务有什么坏处？" class="headerlink" title="2.20 undolog干嘛的，什么时候用到？长事务有什么坏处？"></a>2.20 undolog干嘛的，什么时候用到？长事务有什么坏处？</h2><p><code>undo</code>用来回滚行记录到某个版本。<code>undo log</code>一般是逻辑日志，根据每行记录进行记录。</p>
<p><strong>undo log&nbsp;也是&nbsp;MVCC(多版本并发控制)实现的关键</strong></p>
<p>你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p>
<p>在<code>MySQL 5.5</code>及以前的版本，回滚日志是跟数据字典一起放在<code>ibdata</code>文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。</p>
<p>我见过数据只有<code>20GB</code>，而回滚段有<code>200GB</code>的库。最终只好为了清理回滚段，重建整个库。</p>
<p><strong>除了对回滚段的影响，长事务还占用锁资源</strong>，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。</p>
<h2 id="2-21-binlog-的三种格式"><a href="#2-21-binlog-的三种格式" class="headerlink" title="2.21 binlog 的三种格式"></a>2.21 binlog 的三种格式</h2><ol>
<li><code>STATEMENT</code>模式（<code>SBR</code>），每一条会修改数据的<code>sql</code>语句会记录到<code>binlog</code>中。优点是并不需要记录每一条<code>sql</code>语句和每一行的数据变化，减少了<code>binlog</code>日志量，节约<code>IO</code>，提高性能。缺点是在某些情况下会导致<code>master-slave</code>中的数据不一致(如 <code>sleep()</code>函数， <code>last_insert_id()</code>，以及<code>user-defined functions(udf)</code>等会出现问题)</li>
<li><code>ROW</code>模式（<code>RBR</code>），不记录每条<code>sql</code>语句的上下文信息，仅需记录哪条数据被修改了，修改成什么样了。而且不会出现某些特定情况下的存储过程、或<code>function</code>、或<code>trigger</code>的调用和触发无法被正确复制的问题。缺点是会产生大量的日志，尤其是<code>alter table</code>的时候会让日志暴涨。</li>
<li><code>MIXED</code>模式（<code>MBR</code>）,以上两种模式的混合使用，一般的复制使用<code>STATEMENT</code>模式保存<code>binlog</code>，对于 <code>STATEMENT</code>模式无法复制的操作使用<code>ROW</code>模式保存<code>binlog</code>，<code>MySQL</code>会根据执行的<code>SQL</code>语句选择日志保存方式。</li>
</ol>
<p><strong>STATEMENT</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-8695cb955b769a8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="master.000001.png"></p>
<p><strong>ROW</strong></p>
<p>可以看到，与<code>statement</code>格式的<code>binlog</code>相比，前后的<code>BEGIN</code>和<code>COMMIT</code>是一样的。但是，<code>row</code>格式的<code>binlog</code>里没有了<code>SQL</code>语句的原文，而是替换成了两个<code>event：Table_map</code>和<code>Delete_rows</code>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-9d3b96d95b46192e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-6ba7c89966b9b3a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="2-22-为什么会有-mixed-格式的-binlog？为什么不用mixed格式日志？"><a href="#2-22-为什么会有-mixed-格式的-binlog？为什么不用mixed格式日志？" class="headerlink" title="2.22 为什么会有 mixed 格式的 binlog？为什么不用mixed格式日志？"></a>2.22 为什么会有 mixed 格式的 binlog？为什么不用mixed格式日志？</h2><p>因为有些<code>statement</code>格式的<code>binlog</code>可能会导致主备不一致，所以要使用<code>row</code>格式。但<code>row</code>格式的缺点是，很占空间。比如你用一个<code>delete</code>语句删掉<code>10</code>万行数据，用<code>statement</code>的话就是一个<code>SQL</code>语句被记录到<code>binlog</code>中，占用几十个字节的空间。但如果用<code>row</code>格式的<code>binlog</code>，就要把这<code>10</code>条记录都写到<code>binlog</code>中。这样做，不仅会占用更大的空间，同时写<code>binlog</code>也要耗费<code>IO</code>资源，影响执行速度。</p>
<p>所以，<code>MySQL</code>就取了个折中方案，也就是有了<code>mixed</code>格式的<code>binlog</code>。<code>mixed</code>格式的意思是，<code>MySQL</code>自己会判断这条<code>SQL</code>语句是否可能引起主备不一致，如果有可能，就用<code>row</code>格式，否则就用<code>statement</code>格式。</p>
<p>也就是说，<code>mixed</code>格式可以利用<code>statment</code>格式的优点，同时又避免了数据不一致的风险。</p>
<p>因此，如果你的线上<code>MySQL</code>设置的<code>binlog</code>格式是<code>statement</code>的话，那基本上就可以认为这是一个不合理的设置。你至少应该把<code>binlog</code>的格式设置为<code>mixed</code>。</p>
<p>当然我要说的是，现在越来越多的场景要求把<strong>MySQL 的 binlog 格式设置成 row</strong>。这么做的理由有很多，我来给你举一个可以直接看出来的好处：<strong>恢复数据</strong>。</p>
<p>即使我执行的是<code>delete</code>语句，<code>row</code>格式的<code>binlog</code>也会把被删掉的行的整行信息保存起来。所以，如果你在执行完一条 <code>delete</code>语句以后，发现删错数据了，可以直接把<code>binlog</code>中记录的<code>delete</code>语句转成<code>insert</code>，把被错删的数据插入回去就可以恢复了。</p>
<h1 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h1><h2 id="3-1-事务开始的时机？"><a href="#3-1-事务开始的时机？" class="headerlink" title="3.1 事务开始的时机？"></a>3.1 事务开始的时机？</h2><p><code>begin/start transaction</code>命令并不是一个事务的起点，在执行到它们之后的第一个操作<code>InnoDB</code>表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用<code>start transaction with consistent snapshot</code>这个命令。</p>
<ul>
<li>第一种启动方式，一致性视图是在执行第一个快照读语句时创建的；</li>
<li>第二种启动方式，一致性视图是在执行<code>start transaction with consistent snapshot</code>时创建的。</li>
</ul>
<p>默认<code>autocommit=1</code>，当<code>autocommit</code>为开启状态时，即使没有手动<code>start transaction</code>开启事务，<code>mysql</code>默认也会将用户的操作当做事务即时提交。</p>
<h2 id="3-2-事务数据读取是如何隔离的？"><a href="#3-2-事务数据读取是如何隔离的？" class="headerlink" title="3.2 事务数据读取是如何隔离的？"></a>3.2 事务数据读取是如何隔离的？</h2><p>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</p>
<ul>
<li>版本未提交，不可见；</li>
<li>版本已提交，但是是在视图创建后提交的，不可见；</li>
<li>版本已提交，而且是在视图创建前提交的，可见。</li>
</ul>
<p>这时，事务<code>A</code>的查询语句的视图数组是在执行这个语句的时候创建的，时序上<code>(1,2)、(1,3) </code>的生成时间都在创建这个视图数组的时刻之前。但是，在这个时刻：</p>
<ul>
<li><code>(1,3)</code> 还没提交，属于情况<code>1</code>，不可见；</li>
<li><code>(1,2)</code> 提交了，属于情况<code>3</code>，可见。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-1ceabb7085e47712.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="3-3-什么是预读？预读为什么有效？"><a href="#3-3-什么是预读？预读为什么有效？" class="headerlink" title="3.3 什么是预读？预读为什么有效？"></a>3.3 什么是预读？预读为什么有效？</h2><p>磁盘读写，并不是按需读取，而是按页读取，<strong>一次至少读一页数据（一般是4K）</strong>，如果未来要读取的数据就在页中，就能够省去后续的磁盘<code>IO</code>，提高效率。</p>
<p>数据访问，通常都遵循<code>集中读写</code>的原则，使用一些数据，大概率会使用附近的数据，这就是所谓的<code>局部性原理</code>，它表明提前加载是有效的，确实能够减少磁盘<code>IO</code>。</p>
<h2 id="3-4-什么是缓冲池-buffer-pool"><a href="#3-4-什么是缓冲池-buffer-pool" class="headerlink" title="3.4 什么是缓冲池(buffer pool)"></a>3.4 什么是缓冲池(buffer pool)</h2><ol>
<li>缓冲池(<code>buffer pool</code>)是一种常见的降低磁盘访问的机制；</li>
<li>缓冲池通常以页(<code>page</code>)为单位缓存数据；</li>
<li>缓冲池的常见管理算法是<code>LRU，memcache，OS，InnoDB</code>都使用了这种算法；</li>
<li><code>InnoDB</code>对普通<code>LRU</code>进行了优化：<ul>
<li>将缓冲池分为<strong>老生代和新生代</strong>，入缓冲池的页，优先进入老生代，页被访问，才进入新生代，以解决预读失效的问题</li>
<li>页被访问，且在老生代<strong>停留时间超过配置阈值</strong>的，才进入新生代，以解决批量数据访问，大量热数据淘汰的问题</li>
</ul>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-844598262c87ebab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="head new-sublist.png"></p>
<h2 id="3-5-写缓冲-change-buffer"><a href="#3-5-写缓冲-change-buffer" class="headerlink" title="3.5 写缓冲(change buffer)"></a>3.5 写缓冲(change buffer)</h2><p>假如要修改页号为<code>40</code>的索引页，而这个页正好不在缓冲池内。加入写缓冲优化后，流程优化为：</p>
<ol>
<li>在写缓冲中记录这个操作，一次内存操作；</li>
<li>写入<code>redo log</code>，一次磁盘顺序写操作；</li>
</ol>
<p>除了数据页被访问，<strong>还有哪些场景会触发刷写缓冲中的数据呢</strong>？</p>
<p>还有这么几种情况，会刷写缓冲中的数据：</p>
<ol>
<li>有一个后台线程，会认为数据库空闲时；</li>
<li>数据库缓冲池不够用时；</li>
<li>数据库正常关闭时；</li>
<li><code>redo log</code>写满时；</li>
</ol>
<p><strong>画外音：几乎不会出现redo log写满，此时整个数据库处于无法写入的不可用状态。</strong></p>
<p><strong>先说什么时候不适合</strong>，如上文分析，当：</p>
<ol>
<li>数据库都是唯一索引；</li>
<li>写入一个数据后，会立刻读取它；</li>
</ol>
<p>这两类场景，在写操作进行时（进行后），本来就要进行进行页读取，本来相应页面就要入缓冲池，此时写缓存反倒成了负担，增加了复杂度。</p>
<p>什么时候适合使用写缓冲，如果：</p>
<ol>
<li>数据库大部分是非唯一索引；</li>
<li>业务是写多读少，或者不是写后立刻读取；</li>
</ol>
<p>可以使用写缓冲，将原本每次写入都需要进行磁盘<code>IO</code>的<code>SQL</code>，优化定期批量写磁盘。</p>
<p>画外音：例如，账单流水业务。</p>
<p>参数：<code>innodb_change_buffer_max_size</code></p>
<p>介绍：配置写缓冲的大小，占整个缓冲池的比例，默认值是<code>25%</code>，最大值是<code>50%</code>。</p>
<p>画外音：写多读少的业务，才需要调大这个值，读多写少的业务，<code>25%</code>其实也多了。<br>&nbsp;<br>参数：<code>innodb_change_buffering</code></p>
<p>介绍：配置哪些写操作启用写缓冲，可以设置成<code>all/none/inserts/deletes</code>等。</p>
<p>带<code>change buffer</code>的更新过程，<code>Page 2</code>没有在内存中，就在内存的<code>change buffer</code>区域，记录下“我要往<code>Page 2</code>插入一行”这个信息将上述动作记入<code>redo log</code>中。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-278ec31495ac9718.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="InnoDB bufler pool.png"></p>
<p><code>change buffer</code>的读过程，要读<code>Page 2</code>的时候，需要把<code>Page 2</code>从磁盘读入内存中，然后应用<code>change buffer</code>里面的操作日志，生成一个正确的版本并返回结果。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-833a84b7bb0f88b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="InnolB buffer pool.png"></p>
<h2 id="3-6-InnoDB自适应哈希"><a href="#3-6-InnoDB自适应哈希" class="headerlink" title="3.6 InnoDB自适应哈希"></a>3.6 InnoDB自适应哈希</h2><p>在<code>MySQL</code>运行的过程中，如果<code>InnoDB</code>发现，有很多<code>SQL</code>存在这类很长的寻路，并且有很多<code>SQL</code>会命中相同的页面(<code>page</code>)，<code>InnoDB</code>会在自己的内存缓冲区(<code>Buffer</code>)里，开辟一块区域，建立自适应哈希所有AHI，以加速查询。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-67875b9a2a76d53c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>系统自己判断<code>应该可以加速查询</code>而建立的，不需要用户手动建立，故称<code>自适应</code>。</p>
<p>既然是哈希，<code>key</code>是什么，<code>value</code>是什么？</p>
<ul>
<li><code>key</code>是索引键值（或者键值前缀）。</li>
<li><code>value</code>是索引记录页面位置。</li>
</ul>
<p>当业务场景为下面几种情况时：</p>
<ul>
<li>很多单行记录查询（例如<code>passport</code>，用户中心等业务）</li>
<li>索引范围查询（此时AHI可以快速定位首行记录）</li>
<li>所有记录内存能放得下</li>
</ul>
<p><code>AHI</code>往往是有效的。</p>
<p>画外音：任何脱离业务的技术方案，都是耍流氓。</p>
<p>当业务有大量<code>like</code>或者<code>join</code>，<code>AHI</code>的维护反而可能成为负担，降低系统效率，此时可以手动关闭<code>AHI</code>功能。</p>
<h2 id="3-7-一个-SQL-查询过程"><a href="#3-7-一个-SQL-查询过程" class="headerlink" title="3.7 一个 SQL 查询过程"></a>3.7 一个 SQL 查询过程</h2><p><img src="https://upload-images.jianshu.io/upload_images/12321605-2ed73dabb7611594.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="优化器.png"></p>
<h2 id="3-8-一个SQL-更新过程"><a href="#3-8-一个SQL-更新过程" class="headerlink" title="3.8 一个SQL 更新过程"></a>3.8 一个SQL 更新过程</h2><p>这个是没有<code>change buffer</code>的情况。有<code>change buffer</code>的情况，看上面<code>change buffer</code>写入。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-1c31a76c36f7ccf4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="写入新行.png"></p>
<h2 id="3-9-Mysql-优化器-优化器如何选择索引的"><a href="#3-9-Mysql-优化器-优化器如何选择索引的" class="headerlink" title="3.9 Mysql 优化器, 优化器如何选择索引的"></a>3.9 Mysql 优化器, 优化器如何选择索引的</h2><p>而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的<code>CPU</code>资源越少。</p>
<p>当然，扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。</p>
<p>我们这个简单的查询语句并没有涉及到临时表和排序，所以<code>MySQL</code>选错索引肯定是在判断扫描行数的时候出问题了。</p>
<p>那么，问题就是：扫描行数是怎么判断的？</p>
<p>这个统计信息就是索引的“<strong>区分度</strong>”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“<strong>基数</strong>”（<code>cardinality</code>）。也就是说，这个基数越大，索引的区分度越好。</p>
<p>我们可以使用<code>show index</code>方法，看到一个索引的基数。如图所示。虽然这个表的每一行的三个字段值都是一样的，但是在统计信息中，这三个索引的基数值并不同，而且其实都不准确。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-465b7795f0bf4519.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mysql.png"></p>
<p>那么，<code>MySQL</code>是怎样得到索引的基数的呢？这里，我给你简单介绍一下<code>MySQL</code>采样统计的方法。</p>
<p>为什么要采样统计呢？因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太高了，所以只能选择“采样统计”。</p>
<p>采样统计的时候，<code>InnoDB</code>默认会选择<code>N</code>个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。</p>
<p>而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过<code>1/M</code>的时候，会自动触发重新做一次索引统计。</p>
<p>在<code>MySQL</code>中，有两种存储索引统计的方式，可以通过设置参数<code>innodb_stats_persistent</code>的值来选择：</p>
<ul>
<li>设置为<code>on</code>的时候，表示统计信息会持久化存储。这时，默认的<code>N</code>是<code>20</code>，<code>M</code>是<code>10</code>。</li>
<li>设置为<code>off</code>的时候，表示统计信息只存储在内存中。这时，默认的<code>N</code>是<code>8</code>，<code>M</code>是<code>16</code>。</li>
</ul>
<p>既然是统计信息不对，那就修正。<code>analyze table t</code>命令，可以用来重新统计索引信息。</p>
<h2 id="3-10-什么是账页，有哪些场景会强制刷脏页？"><a href="#3-10-什么是账页，有哪些场景会强制刷脏页？" class="headerlink" title="3.10 什么是账页，有哪些场景会强制刷脏页？"></a>3.10 什么是账页，有哪些场景会强制刷脏页？</h2><p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“<strong>脏页</strong>”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“<strong>干净页</strong>”。部分刷账页可能导致<code>Mysql</code>抖动。</p>
<p>强制刷脏页的场景</p>
<ol>
<li><code>InnoDB</code>的<code>redo log</code>写满了。这时候系统会停止所有更新操作，把<code>checkpoint</code>往前推进，<code>redo log</code>留出空间可以继续写。</li>
<li>系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。你一定会说，这时候难道不能直接把内存淘汰掉，下次需要请求的时候，从磁盘读入数据页，然后拿<code>redo log</code>出来应用不就行了？这里其实是从性能考虑的。如果刷脏页一定会写盘，就保证了每个数据页有两种状态：<ul>
<li>一种是内存里存在，内存里就肯定是正确的结果，直接返回；</li>
<li>另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。这样的效率最高。</li>
</ul>
</li>
<li><code>MySQL</code>认为系统“空闲”的时候。当然，<code>MySQL</code>“这家酒店”的生意好起来可是会很快就能把粉板记满的，所以“掌柜”要合理地安排时间，即使是“生意好”的时候，也要见缝插针地找时间，只要有机会就刷一点“脏页”。</li>
<li><code>MySQL</code>正常关闭的情况。这时候，<code>MySQL</code> 会把内存的脏页都<code>flush</code>到磁盘上，这样下次<code>MySQL</code>启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</li>
</ol>
<p>第一种是“<strong>redo log 写满了，要 flush 脏页</strong>”，这种情况是<code>InnoDB</code>要尽量避免的。因为出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果你从监控上看，这时候更新数会跌为<code>0</code>。</p>
<p>第二种是“<strong>内存不够用了，要先将脏页写到磁盘</strong>”，这种情况其实是常态。<code>InnoDB</code>用缓冲池（<code>buffer pool</code>）管理内存，缓冲池中的内存页有三种状态：</p>
<ul>
<li>第一种是，还没有使用的；</li>
<li>第二种是，使用了并且是干净页；</li>
<li>第三种是，使用了并且是脏页。</li>
</ul>
<p>而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</p>
<p>所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：</p>
<ul>
<li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</li>
<li>日志写满，更新全部堵住，写性能跌为<code>0</code>，这种情况对敏感业务来说，是不能接受的。</li>
</ul>
<h2 id="3-11-当-MySQL-去更新一行，但是要修改的值跟原来的值是相同的，这时候-MySQL-会真的去执行一次修改吗？"><a href="#3-11-当-MySQL-去更新一行，但是要修改的值跟原来的值是相同的，这时候-MySQL-会真的去执行一次修改吗？" class="headerlink" title="3.11 当 MySQL 去更新一行，但是要修改的值跟原来的值是相同的，这时候 MySQL 会真的去执行一次修改吗？"></a>3.11 当 MySQL 去更新一行，但是要修改的值跟原来的值是相同的，这时候 MySQL 会真的去执行一次修改吗？</h2><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/73479">参考</a></p>
<p><code>InnoDB</code> 认真执行了“把这个值修改成 (1,2)”这个操作，该加锁的加锁，该更新的更新。</p>
<h2 id="3-12-我查这么多数据，会不会把数据库内存打爆"><a href="#3-12-我查这么多数据，会不会把数据库内存打爆" class="headerlink" title="3.12 我查这么多数据，会不会把数据库内存打爆"></a>3.12 我查这么多数据，会不会把数据库内存打爆</h2><p>我经常会被问到这样一个问题：我的主机内存只有 <code>100G</code>，现在要对一个<code>200G</code>的大表做全表扫描，会不会把数据库主机的内存用光了？</p>
<p>实际上，服务端并不需要保存一个完整的结果集。取数据和发数据的流程是这样的：</p>
<ol>
<li>获取一行，写到<code>net_buffer</code>中。这块内存的大小是由参数<code>net_buffer_length</code>定义的，默认是<code>16k</code>。</li>
<li>重复获取行，直到<code>net_buffer</code>写满，调用网络接口发出去。</li>
<li>如果发送成功，就清空<code>net_buffer</code>，然后继续取下一行，并写入<code>net_buffer</code>。</li>
<li>如果发送函数返回<code>EAGAIN</code>或<code>WSAEWOULDBLOCK</code>，就表示本地网络栈（<code>socket send buffer</code>）写满了，进入等待。直到网络栈重新可写，再继续发送。</li>
</ol>
<p>也就是说，<code>MySQL</code>是“<strong>边读边发的</strong>”，这个概念很重要。这就意味着，如果客户端接收得慢，会导致<code>MySQL</code>服务端由于结果发不出去，这个事务的执行时间变长。</p>
<h2 id="3-13-读写分离，遇到主从不一致的问题常用的解决方案？"><a href="#3-13-读写分离，遇到主从不一致的问题常用的解决方案？" class="headerlink" title="3.13 读写分离，遇到主从不一致的问题常用的解决方案？"></a>3.13 读写分离，遇到主从不一致的问题常用的解决方案？</h2><ol>
<li>强制走主库方案；</li>
<li><code>sleep</code>方案；</li>
<li>判断主备无延迟方案；<code>show slave status</code>&nbsp;，判断<code>seconds_behind_master</code>是否已经等于<code>0</code>。如果还不等于 <code>0</code> ，那就必须等到这个参数变为<code>0</code>才能执行查询请求。</li>
<li>配合<code>semi-sync</code>方案，要解决这个问题，就要引入半同步复制，也就是<code>semi-sync replication</code>，<ul>
<li>事务提交的时候，主库把<code>binlog</code>发给从库；</li>
<li>从库收到<code>binlog</code>以后，发回给主库一个<code>ack</code>，表示收到了；</li>
<li>主库收到这个<code>ack</code>以后，才能给客户端返回“事务完成”的确认。</li>
<li>也就是说，如果启用了<code>semi-sync</code>，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。</li>
</ul>
</li>
<li>等主库位点方案；<ul>
<li><code>Master_Log_File</code>和<code>Read_Master_Log_Pos</code>，表示的是读到的主库的最新位点；</li>
<li><code>Relay_Master_Log_File</code>和<code>Exec_Master_Log_Pos</code>，表示的是备库执行的最新位点。</li>
<li>如果<code>Master_Log_File</code>和<code>Relay_Master_Log_File</code>、<code>Read_Master_Log_Pos</code>和<code>Exec_Master_Log_Pos</code>这两组值完全相同，就表示接收到的日志已经同步完成。</li>
</ul>
</li>
<li>等 <code>GTID</code> 方案，对比 <code>GTID</code> 集合确保主备无延迟。<ul>
<li><code>Auto_Position=1</code>，表示这对主备关系使用了<code>GTID</code>协议。</li>
<li><code>Retrieved_Gtid_Set</code>，是备库收到的所有日志的<code>GTID</code>集合；</li>
<li><code>Executed_Gtid_Set</code>，是备库所有已经执行完成的<code>GTID</code>集合。</li>
</ul>
</li>
</ol>
<h2 id="3-14-InnoDB有哪些类型的锁？"><a href="#3-14-InnoDB有哪些类型的锁？" class="headerlink" title="3.14 InnoDB有哪些类型的锁？"></a>3.14 InnoDB有哪些类型的锁？</h2><p>排它锁、共享锁、意向排他锁、意向共享锁、自增锁、间隙锁、临键锁、记录锁</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-71c1a9b9180a84af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="3-15-Mysql加锁原则？"><a href="#3-15-Mysql加锁原则？" class="headerlink" title="3.15 Mysql加锁原则？"></a>3.15 Mysql加锁原则？</h2><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/75659">为什么我只改一行的语句，锁这么多？</a></p>
<ul>
<li>原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。</li>
<li>原则 2：查找过程中访问到的对象才会加锁。</li>
<li>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</li>
<li>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</li>
<li>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ul>
<h2 id="3-16-Mysql两阶段锁？"><a href="#3-16-Mysql两阶段锁？" class="headerlink" title="3.16 Mysql两阶段锁？"></a>3.16 Mysql两阶段锁？</h2><p>在一个事务里面，分为加锁(<code>lock</code>)阶段和解锁(<code>unlock</code>)阶段,也即所有的<code>lock</code>操作都在<code>unlock</code>操作之前</p>
<p>事务分为两个阶段：</p>
<ul>
<li>第一阶段是获得封锁，也称为扩展阶段；</li>
<li>第二阶段是释放封锁，也称为收缩阶段。</li>
</ul>
<p>也就是说，在 InnoDB 事务中，<strong>行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议</strong>。</p>
<h2 id="3-17-死锁和死锁检测"><a href="#3-17-死锁和死锁检测" class="headerlink" title="3.17 死锁和死锁检测"></a>3.17 死锁和死锁检测</h2><p>这时候，事务<code>A</code>在等待事务<code>B</code>释放<code>id=2</code> 的行锁，而事务<code>B</code>在等待事务<code>A</code>释放<code>id=1</code>的行锁。 事务<code>A</code>和事务<code>B</code>在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p>
<ul>
<li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数<code>innodb_lock_wait_timeout</code>来设置。</li>
<li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数<code>innodb_deadlock_detect</code>设置为<code>on</code>，表示开启这个逻辑。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-2768e8dd91976627.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="事务A.png"></p>
<h2 id="3-18-什么是热点行"><a href="#3-18-什么是热点行" class="headerlink" title="3.18 什么是热点行"></a>3.18 什么是热点行</h2><p>那如果是我们上面说到的所有事务都要更新同一行的场景呢？ 每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是<code>O(n)</code>的操作。假设有<code>1000</code>个并发线程要同时更新同一行，那么死锁检测操作就是<code>100</code>万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的<code>CPU</code>资源。因此，你就会看到<code>CPU</code>利用率很高，但是每秒却执行不了几个事务。</p>
<p>根据上面的分析，我们来讨论一下，怎么解决由这种热点行更新导致的性能问题呢？问题的症结在于，死锁检测要耗费大量的 <code>CPU</code>资源。</p>
<ul>
<li>一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。</li>
<li>另一个思路是控制并发度。根据上面的分析，你会发现如果并发能够控制住，比如同一行同时最多只有<code>10</code>个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多。我见过一个应用，有<code>600</code>个客户端，这样即使每个客户端控制到只有<code>5</code>个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到<code>3000</code>。</li>
</ul>
<p>因此，这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改<code>MySQL</code>源码的人，也可以做在<code>MySQL</code>里面。基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在<code>InnoDB</code>内部就不会有大量的死锁检测工作了。</p>
<p>要访问的行上有锁，他才要死锁检测。</p>
<h2 id="3-19-mysql-如何对记录进行排序的，内存排序、文件排序，文件合并用归并排序"><a href="#3-19-mysql-如何对记录进行排序的，内存排序、文件排序，文件合并用归并排序" class="headerlink" title="3.19 mysql 如何对记录进行排序的，内存排序、文件排序，文件合并用归并排序"></a>3.19 mysql 如何对记录进行排序的，内存排序、文件排序，文件合并用归并排序</h2><pre><code>show variables like '%sort_buffer_size%'; //8M ，生成环境是8M
</code></pre>
<p><code>sort_buffer_size</code>，就是<code>MySQL</code>为排序开辟的内存（<code>sort_buffer</code>）的大小。如果要排序的数据量小于<code>sort_buffer_size</code>，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p>
<p><code>number_of_tmp_files</code>表示的是，排序过程中使用的临时文件数。你一定奇怪，为什么需要<code>12</code>个文件？内存放不下时，就需要使用外部排序，<strong>外部排序一般使用归并排序算法</strong>。可以这么简单理解，<code>MySQL</code>将需要排序的数据分成<code>12</code>份，每一份单独排序后存在这些临时文件中。然后把这<code>12</code>个有序文件再合并成一个有序的大文件。</p>
<pre><code>select from t where city='杭州' order by name limit 1000  ;
</code></pre>
<ol>
<li>初始化<code>sort_buffer</code>，确定放入<code>name、city、age</code>这三个字段；</li>
<li>从索引<code>city</code>找到第一个满足<code>city='杭州’</code>条件的主键<code>id</code>，也就是图中的<code>ID_X</code>；</li>
<li>到主键<code>id</code>索引取出整行，取<code>name、city、age</code>三个字段的值，存入<code>sort_buffer</code>中；</li>
<li>从索引<code>city</code>取下一个记录的主键<code>id</code>；</li>
<li>重复步骤<code>3、4</code>直到<code>city</code>的值不满足查询条件为止，对应的主键<code>id</code>也就是图中的<code>ID_Y</code>；</li>
<li>对<code>sort_buffer</code>中的数据按照字段<code>name</code>做快速排序；按照排序结果取前<code>1000</code>行返回给客户端。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-9bc5611abd2e517b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>rowid 排序</strong></p>
<p>如果<code>MySQL</code>认为排序的单行长度太大会怎么做呢？<br><code>max_length_for_sort_data</code>，是<code>MySQL</code>中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，<code>MySQL</code> 就认为单行太大，要换一个算法。</p>
<p>新的算法放入<code>sort_buffer</code>的字段，只有要排序的列（即<code>name</code>字段）和主键<code>id</code>。</p>
<ol>
<li>始化<code>sort_buffer</code>，确定放入两个字段，即<code>name</code>和<code>id</code>；</li>
<li>从索引<code>city</code>找到第一个满足<code>city='杭州’</code>条件的主键<code>id</code>，也就是图中的<code>ID_X</code>；</li>
<li>到主键 <code>id</code> 索引取出整行，取 <code>name、id</code> 这两个字段，存入<code>sort_buffer</code>中；</li>
<li>从索引<code>city</code>取下一个记录的主键 id；</li>
<li>重复步骤<code>3、4</code>直到不满足<code>city='杭州’</code>条件为止，也就是图中的<code>ID_Y</code>；</li>
<li>对<code>sort_buffer</code>中的数据按照字段<code>name</code>进行排序；</li>
<li>遍历排序结果，取前<code>1000</code>行，并按照<code>id</code>的值回到原表中取出<code>city、name</code>和<code>age</code>三个字段返回给客户端。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-70c103f7d262963e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="name.png"></p>
<h2 id="3-20-mysql-join-如何实现的。join的时候需要注意什么"><a href="#3-20-mysql-join-如何实现的。join的时候需要注意什么" class="headerlink" title="3.20 mysql join 如何实现的。join的时候需要注意什么"></a>3.20 mysql join 如何实现的。join的时候需要注意什么</h2><pre><code>show variables like '%join_buffer_size%';  //8M
</code></pre>
<p><code>select * from t1 straight_join t2 on (t1.a=t2.b);</code></p>
<ol>
<li>扫描表<code>t1</code>，顺序读取数据行放入<code>join_buffer</code> 中，放完第<code>88</code>行<code>join_buffer</code>满了，继续第<code>2</code>步；</li>
<li>扫描表<code>t2</code>，把<code>t2</code>中的每一行取出来，跟<code>join_buffer</code>中的数据做对比，满足<code>join</code>条件的，作为结果集的一部分返回；</li>
<li>清空<code>join_buffer</code>；</li>
<li>继续扫描表<code>t1</code>，顺序读取最后的<code>12</code>行数据放入<code>join_buffer</code>中，继续执行第<code>2</code>步。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/12321605-52947fa74c8f5642.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="R100.png"></p>
<p>第一个问题：能不能使用 <code>join</code> 语句？</p>
<ol>
<li>如果可以使用<code>Index Nested-Loop Join</code>算法，也就是说可以用上被驱动表上的索引，其实是没问题的；</li>
<li>如果使用<code>Block Nested-Loop Join</code>算法，扫描行数就会过多。尤其是在大表上的<code>join</code>操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种<code>join</code>尽量不要用。</li>
</ol>
<p>第二个问题是：如果要使用<code>join</code>，应该选择大表做驱动表还是选择小表做驱动表？</p>
<ol>
<li>如果是<code>Index Nested-Loop Join</code>算法，应该选择小表做驱动表；</li>
<li>如果是<code>Block Nested-Loop Join</code>算法：<ul>
<li>在<code>join_buffer_size</code>足够大的时候，是一样的；</li>
<li>在<code>join_buffer_size</code>不够大的时候（这种情况更常见），应该选择小表做驱动表。</li>
</ul>
</li>
</ol>
<h2 id="3-21-为什么不要大表join？"><a href="#3-21-为什么不要大表join？" class="headerlink" title="3.21 为什么不要大表join？"></a>3.21 为什么不要大表join？</h2><p><strong>污染缓存池</strong></p>
<p>由于优化机制的存在，一个正常访问的数据页，要进入<code>young</code>区域，需要隔<code>1</code>秒后再次被访问到。但是，由于我们的 <code>join</code>语句在循环读磁盘和淘汰内存页，进入<code>old</code>区域的数据页，很可能在<code>1</code>秒之内就被淘汰了。这样，就会导致这个 <code>MySQL</code>实例的<code>Buffer Pool</code>在这段时间内，<code>young</code>区域的数据页没有被合理地淘汰。</p>
<p>大表<code>join</code>操作虽然对<code>IO</code>有影响，但是在语句执行结束后，对<code>IO</code>的影响也就结束了。但是，对<code>Buffer Pool</code>的影响就是持续性的，需要依靠后续的查询请求慢慢恢复内存命中率。</p>
<p>为了减少这种影响，你可以考虑增大<code>join_buffer_size</code>的值，减少对被驱动表的扫描次数。</p>
<h2 id="3-22-内存临时表"><a href="#3-22-内存临时表" class="headerlink" title="3.22 内存临时表"></a>3.22 内存临时表</h2><ol>
<li>建表语法是 <code>create temporary table</code></li>
<li>一个临时表只能被创建它的<code>session</code>访问，对其他线程不可见。所以，图中<code>session A</code>创建的临时表<code>t</code>，对于 <code>session B</code>就是不可见的。</li>
<li>临时表可以与普通表同名。</li>
<li><code>session A</code>内有同名的临时表和普通表的时候，<code>show create</code>语句，以及增删改查语句访问的是临时表。<code>session A</code>内有同名的临时表和普通表的时候，<code>show create</code>语句，以及增删改查语句访问的是临时表。</li>
<li><code>show tables</code>命令不显示临时表。</li>
</ol>
<p>由于临时表只能被创建它的<code>session</code>访问，所以在这个<code>session</code>结束的时候，会自动删除临时表。也正是由于这个特性，临时表就特别适合我们文章开头的<code>join</code>优化这种场景。为什么呢？</p>
<p>原因主要包括以下两个方面：</p>
<ol>
<li>不同<code>session</code>的临时表是可以重名的，如果有多个<code>session</code>同时执行<code>join</code>优化，不需要担心表名重复导致建表失败的问题。</li>
<li>不需要担心数据删除问题。如果使用普通表，在流程执行过程中客户端发生了异常断开，或者数据库发生异常重启，还需要专门来清理中间过程中生成的数据表。而临时表由于会自动回收，所以不需要这个额外的操作。</li>
</ol>
<p><strong>磁盘临时表</strong></p>
<p>其实不是的。<code>tmp_table_size</code>这个配置限制了内存临时表的大小，默认值是<code>16M</code>。如果临时表大小超过了<code>tmp_table_size</code>，那么内存临时表就会转成磁盘临时表。</p>
<h2 id="3-23-什么时候会使用临时表"><a href="#3-23-什么时候会使用临时表" class="headerlink" title="3.23 什么时候会使用临时表"></a>3.23 什么时候会使用临时表</h2><p><strong>union</strong></p>
<p><code>(select 1000 as f) union (select id from t1 order by id desc limit 2);</code></p>
<p>这个语句的执行流程是这样的：</p>
<ol>
<li>创建一个内存临时表，这个临时表只有一个整型字段<code>f</code>，并且<code>f</code>是主键字段。</li>
<li>执行第一个子查询，得到<code>1000</code>这个值，并存入临时表中。</li>
<li>执行第二个子查询：<ul>
<li>拿到第一行<code>id=1000</code>，试图插入临时表中。但由于<code>1000</code>这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行；</li>
<li>取到第二行<code>id=999</code>，插入临时表成功。</li>
</ul>
</li>
<li>从临时表中按行取出数据，返回结果，并删除临时表，结果中包含两行数据分别是<code>1000</code>和<code>999</code>。</li>
</ol>
<p><strong>group by 执行流程</strong></p>
<p><code>select id%10 as m, count(*) as c from t1 group by m;</code></p>
<p>这个语句的执行流程是这样的：</p>
<ol>
<li>创建内存临时表，表里有两个字段<code>m</code>和<code>c</code>，主键是<code>m</code>；</li>
<li>扫描表<code>t1</code>的索引<code>a</code>，依次取出叶子节点上的<code>id</code>值，计算<code>id%10</code>的结果，记为<code>x</code>；<ul>
<li>如果临时表中没有主键为<code>x</code>的行，就插入一个记录<code>(x,1)</code>;</li>
<li>如果表中有主键为<code>x</code>的行，就将<code>x</code>这一行的<code>c</code>值加<code>1</code>；</li>
</ul>
</li>
<li>遍历完成后，再根据字段<code>m</code>做排序，得到结果集返回给客户端。</li>
</ol>
<h2 id="3-24-distinct-和-group-by-的性能"><a href="#3-24-distinct-和-group-by-的性能" class="headerlink" title="3.24 distinct 和 group by 的性能"></a>3.24 distinct 和 group by 的性能</h2><pre><code>select a from t group by a order by null;
select distinct a from t;
</code></pre>
<p>首先需要说明的是，这种<code>group by</code>的写法，并不是<code>SQL</code>标准的写法。标准的<code>group by</code>语句，是需要在<code>select</code>部分加一个聚合函数，比如：</p>
<pre><code>select a,count(*) from t group by a order by null;
</code></pre>
<p>这条语句的逻辑是：按照字段<code>a</code>分组，计算每组的<code>a</code>出现的次数。在这个结果里，由于做的是聚合计算，相同的<code>a</code>只出现一次。</p>
<p>没有了<code>count(*)</code>以后，也就是不再需要执行“计算总数”的逻辑时，第一条语句的逻辑就变成是：按照字段<code>a</code>做分组，相同的<code>a</code>的值只返回一行。而这就是<code>distinct</code>的语义，所以不需要执行聚合函数时，<strong>distinct和group by这两条语句的语义和执行流程是相同的，因此执行性能也相同。</strong></p>
<p><strong>group by 指导原则</strong></p>
<ol>
<li>如果对<code>group by</code>语句的结果没有排序要求，要在语句后面加<code>order by null</code>；</li>
<li>尽量让<code>group by</code>过程用上表的索引，确认方法是<code>explain</code>结果里没有<code>Using temporary</code>和<code>Using filesort</code>；</li>
<li>如果<code>group by</code>需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大<code>tmp_table_size</code>参数，来避免用到磁盘临时表；</li>
<li>如果数据量实在太大，使用<code>SQL_BIG_RESULT</code>这个提示，来告诉优化器直接使用排序算法得到<code>group by</code>的结果。</li>
</ol>
<h2 id="3-25-count-、count-主键-id-和-count-1"><a href="#3-25-count-、count-主键-id-和-count-1" class="headerlink" title="3.25 count(*)、count(主键 id) 和 count(1)"></a>3.25 count(*)、count(主键 id) 和 count(1)</h2><p>对于<code>count(主键 id)</code>来说，<code>InnoDB</code>引擎会遍历整张表，把每一行的<code>id</code>值都取出来，返回给<code>server</code>层。<code>server</code>层拿到<code>id</code>后，判断是不可能为空的，就按行累加。</p>
<p>对于<code>count(1)</code>来说，<code>InnoDB</code>引擎遍历整张表，但不取值。<code>server</code>层对于返回的每一行，放一个数字“<code>1</code>”进去，判断是不可能为空的，按行累加。</p>
<p>对于<code>count(字段)</code>来说：</p>
<ol>
<li>如果这个“字段”是定义为<code>not null</code>的话，一行行地从记录里面读出这个字段，判断不能为<code>null</code>，按行累加；</li>
<li>如果这个“字段”定义允许为<code>null</code>，那么执行的时候，判断到有可能是<code>null</code>，还要把值取出来再判断一下，不是 <code>null</code>才累加。<br>但是<code>count(*)&nbsp;</code>是例外，并不会把全部字段取出来，而是专门做了优化，不取值。<code>count(*)</code>肯定不是<code>null</code>，按行累加。</li>
</ol>
<p>所以结论是：按照效率排序的话，<code>count(字段)&lt; count(主键 id) &lt; count(1) ≈count()</code>，所以我建议你，尽量使用 <code>count()</code>。</p>
<h2 id="3-26-什么是内存表？"><a href="#3-26-什么是内存表？" class="headerlink" title="3.26 什么是内存表？"></a>3.26 什么是内存表？</h2><p>可见，<code>InnoDB</code>和<code>Memory</code>引擎的数据组织方式是不同的：</p>
<ul>
<li><code>InnoDB</code>引擎把数据放在主键索引上，其他索引上保存的是主键<code>id</code>。这种方式，我们称之为索引组织表（<code>Index Organizied Table</code>）。</li>
<li>而<code>Memory</code>引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之为堆组织表（<code>Heap Organizied Table</code>）。</li>
</ul>
<p>从中我们可以看出，这两个引擎的一些典型不同：</p>
<ol>
<li><code>InnoDB</code>表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；</li>
<li>当数据文件有空洞的时候，<code>InnoDB</code>表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值；</li>
<li>数据位置发生变化的时候，<code>InnoDB</code>表只需要修改主键索引，而内存表需要修改所有索引；</li>
<li><code>InnoDB</code>表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。</li>
<li><code>InnoDB</code>支持变长数据类型，不同记录的长度可能不同；内存表不支持<code>Blob</code>和<code>Text</code>字段，并且即使定义了 <code>varchar(N)</code>，实际也当作<code>char(N)</code>，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。</li>
<li>内存表不支持行锁，只支持表锁。因此，一张表只要有更新，就会堵住其他所有在这个表上的读写操作。</li>
<li>数据放在内存中，是内存表的优势，但也是一个劣势。因为，数据库重启的时候，所有的内存表都会被清空。<br>由于内存表的这些特性，每个数据行被删除以后，空出的这个位置都可以被接下来要插入的数据复用。比如，如果要在表<code>t1</code>中执行：</li>
</ol>
<p>基于内存表的特性，我们还分析了它的一个适用场景，就是内存临时表。内存表支持<code>hash</code>索引，这个特性利用起来，对复杂查询的加速效果还是很不错的。</p>
<h2 id="3-27-自增主键为什么不是连续的？什么场景下自增主键可能不连续？"><a href="#3-27-自增主键为什么不是连续的？什么场景下自增主键可能不连续？" class="headerlink" title="3.27 自增主键为什么不是连续的？什么场景下自增主键可能不连续？"></a>3.27 自增主键为什么不是连续的？什么场景下自增主键可能不连续？</h2><p>深层次原因是，<strong>不判断自增主键是否已存在可减少加锁的时间范围和粒度</strong>-&gt;为了更高的性能-&gt;自增主键不能回退-&gt;自增主键不连续</p>
<p>在什么场景下自增主键可能不连续</p>
<ol>
<li>唯一键冲突 </li>
<li>事务回滚 </li>
<li>自增主键的批量申请</li>
</ol>
<h2 id="3-28-使用limit-offset-分页时，为什么越往后翻越慢？"><a href="#3-28-使用limit-offset-分页时，为什么越往后翻越慢？" class="headerlink" title="3.28 使用limit offset 分页时，为什么越往后翻越慢？"></a>3.28 使用limit offset 分页时，为什么越往后翻越慢？</h2><p>但当执行<code>select * from table limit 800000，20</code>的时候数据读取就很慢，<code>limit 800000，20</code>的意思扫描满足条件的<code>800020</code>行，扔掉前面的<code>800000</code>行，返回最后的<code>20</code>行，可想而知这时会很慢，测试了一下达到<code>37.44</code>秒之久。</p>
<h2 id="3-29-慢查询工具-mysqldumpslow"><a href="#3-29-慢查询工具-mysqldumpslow" class="headerlink" title="3.29 慢查询工具 mysqldumpslow"></a>3.29 慢查询工具 mysqldumpslow</h2><p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具&nbsp;mysqldumpslow</p>
<ul>
<li>s: 是表示按照何种方式排序</li>
<li>c: 访问次数</li>
<li>l: 锁定时间</li>
<li>r: 返回记录</li>
<li>t: 查询时间</li>
<li>al:平均锁定时间</li>
<li>ar:平均返回记录数</li>
<li>at:平均查询时间</li>
<li>t:即为返回前面多少条的数据</li>
<li>g:后边搭配一个正则匹配模式，大小写不敏感的</li>
</ul>
<h2 id="3-30-SQL语句执行效率的主要因素"><a href="#3-30-SQL语句执行效率的主要因素" class="headerlink" title="3.30 SQL语句执行效率的主要因素"></a>3.30 SQL语句执行效率的主要因素</h2><ol>
<li>数据量<ul>
<li>SQL执行后返回给客户端的数据量的大小</li>
<li>数据量越大需要扫描的I/O次数越多，数据库服务器的IO更容易成为瓶颈。</li>
</ul>
</li>
<li>取数据的方式<ul>
<li>数据在缓存中还是在磁盘上;</li>
<li>是否能够通过全局索引快速寻址;</li>
<li>是否结合谓词条件命中全局索引加速扫描;</li>
</ul>
</li>
<li>数据加工的方式<ul>
<li>排序、子查询、聚合、关联等，一般需要先把数据取到临时表中，再对数据进行加工;</li>
<li>对干数据量比较多的计算，会消耗大量计算节点的CPU资源，让数据加工变得更加缓慢;</li>
<li>是否选择了合适的<code>join</code>方式</li>
</ul>
</li>
</ol>
<h2 id="3-31-SQL优化思路"><a href="#3-31-SQL优化思路" class="headerlink" title="3.31 SQL优化思路"></a>3.31 SQL优化思路</h2><ol>
<li>减少数据扫描 (减少磁盘访问)<ul>
<li>尽量在查询中加入一些可以提前过滤数据的谓词条件，比如按照时间过滤数据等，可以减少数据的扫描量，对查询更友好;</li>
<li>在扫描大表数据时是否可以命中索引，减少回表代价，避免全表扫描</li>
</ul>
</li>
<li>返回更少数据 (减少网络传输或磁盘访问)</li>
<li>减少交互次数(减少网络传输)<ul>
<li>将数据存放在更快的地方.</li>
<li>某条查询涉及到大表，无法进一步优化，如果返回的数据量不大且变化频率不高但访问频率很高，此时应该考虑将返回的数据放在应用端的缓存当中或者Redis这样的缓存当中，以提高存取速度.</li>
</ul>
</li>
<li>减少服务器<code>CPU</code>开销 (减少<code>CPU</code>及内存开销)</li>
<li>避免大事务操作</li>
<li>利用更多资源 (增加资源)</li>
</ol>
<h2 id="3-32-DDL-几种形式"><a href="#3-32-DDL-几种形式" class="headerlink" title="3.32 DDL 几种形式"></a>3.32 DDL 几种形式</h2><p><img src="https://upload-images.jianshu.io/upload_images/12321605-9ab3ba3c912290da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="COPY OFFLINE.png"></p>
<pre><code>show variables like '%join_buffer_size%';  //8M
show variables like '%sort_buffer_size%'; //8M
show variables like '%innodb_buffer_pool_size%'; // 64G
</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023/07/16/chat-room-with-rust/" title="《基于 Rust 实现一个加密的 IM 聊天室》"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 《基于 Rust 实现一个加密的 IM 聊天室》</span></a><a class="button is-default" href="/2023/06/23/nonviolent-communication-father/" title="《非暴力沟通的父母语言》"><span class="has-text-weight-semibold">下一页: 《非暴力沟通的父母语言》</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="fanlv/blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/fanlv"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com/fanlvlgh"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Ryo 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p class="is-flex is-justify-content-center"><a title="备案号：鄂ICP备2022016224号-2" target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn/">备案号：鄂ICP备2022016224号-2 &nbsp;</a></p></div><div><span>博学之，审问之，慎思之，明辨之，笃行之</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>